// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "equip_module.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message EquipDeletePush
 */
export interface EquipDeletePush {
    /**
     * @generated from protobuf field: repeated int64 uids = 1;
     */
    uids: bigint[];
}
/**
 * @generated from protobuf message EquipLockRequest
 */
export interface EquipLockRequest {
    /**
     * @generated from protobuf field: optional int64 targetUid = 1;
     */
    targetUid?: bigint;
    /**
     * @generated from protobuf field: optional bool lock = 2;
     */
    lock?: boolean;
}
/**
 * @generated from protobuf message EquipRefineRequest
 */
export interface EquipRefineRequest {
    /**
     * @generated from protobuf field: optional int64 targetUid = 1;
     */
    targetUid?: bigint;
    /**
     * @generated from protobuf field: repeated int64 eatUids = 2;
     */
    eatUids: bigint[];
}
/**
 * @generated from protobuf message EquipDecomposeReply
 */
export interface EquipDecomposeReply {
    /**
     * @generated from protobuf field: repeated int64 equipUids = 1;
     */
    equipUids: bigint[];
}
/**
 * @generated from protobuf message EquipBreakReply
 */
export interface EquipBreakReply {
}
/**
 * @generated from protobuf message EquipStrengthenReply
 */
export interface EquipStrengthenReply {
    /**
     * @generated from protobuf field: optional int64 targetUid = 1;
     */
    targetUid?: bigint;
    /**
     * @generated from protobuf field: repeated EatEquip eatEquips = 2;
     */
    eatEquips: EatEquip[];
}
/**
 * @generated from protobuf message EquipComposeRequest
 */
export interface EquipComposeRequest {
    /**
     * @generated from protobuf field: repeated int32 equipIds = 1;
     */
    equipIds: number[];
}
/**
 * @generated from protobuf message GetEquipInfoReply
 */
export interface GetEquipInfoReply {
    /**
     * @generated from protobuf field: repeated Equip equips = 1;
     */
    equips: Equip[];
}
/**
 * @generated from protobuf message EquipLockReply
 */
export interface EquipLockReply {
    /**
     * @generated from protobuf field: optional int64 targetUid = 1;
     */
    targetUid?: bigint;
    /**
     * @generated from protobuf field: optional bool lock = 2;
     */
    lock?: boolean;
}
/**
 * @generated from protobuf message EquipBreakRequest
 */
export interface EquipBreakRequest {
    /**
     * @generated from protobuf field: optional int64 targetUid = 1;
     */
    targetUid?: bigint;
}
/**
 * @generated from protobuf message EquipUpdatePush
 */
export interface EquipUpdatePush {
    /**
     * @generated from protobuf field: repeated Equip equips = 1;
     */
    equips: Equip[];
}
/**
 * @generated from protobuf message Equip
 */
export interface Equip {
    /**
     * @generated from protobuf field: optional int32 equipId = 1;
     */
    equipId?: number;
    /**
     * @generated from protobuf field: optional int64 uid = 2;
     */
    uid?: bigint;
    /**
     * @generated from protobuf field: optional int32 level = 3;
     */
    level?: number;
    /**
     * @generated from protobuf field: optional int32 exp = 4;
     */
    exp?: number;
    /**
     * @generated from protobuf field: optional int32 breakLv = 5;
     */
    breakLv?: number;
    /**
     * @generated from protobuf field: optional int32 count = 7;
     */
    count?: number;
    /**
     * @generated from protobuf field: optional bool isLock = 8;
     */
    isLock?: boolean;
    /**
     * @generated from protobuf field: optional int32 refineLv = 9;
     */
    refineLv?: number;
}
/**
 * @generated from protobuf message EquipStrengthenRequest
 */
export interface EquipStrengthenRequest {
    /**
     * @generated from protobuf field: optional int64 targetUid = 1;
     */
    targetUid?: bigint;
    /**
     * @generated from protobuf field: repeated EatEquip eatEquips = 2;
     */
    eatEquips: EatEquip[];
}
/**
 * @generated from protobuf message EquipDecomposeRequest
 */
export interface EquipDecomposeRequest {
    /**
     * @generated from protobuf field: repeated int64 equipUids = 1;
     */
    equipUids: bigint[];
}
/**
 * @generated from protobuf message EatEquip
 */
export interface EatEquip {
    /**
     * @generated from protobuf field: optional int64 eatUid = 1;
     */
    eatUid?: bigint;
    /**
     * @generated from protobuf field: optional int32 count = 2;
     */
    count?: number;
}
/**
 * @generated from protobuf message GetEquipInfoRequest
 */
export interface GetEquipInfoRequest {
}
/**
 * @generated from protobuf message EquipComposeReply
 */
export interface EquipComposeReply {
    /**
     * @generated from protobuf field: repeated int32 equipIds = 1;
     */
    equipIds: number[];
}
/**
 * @generated from protobuf message EquipRefineReply
 */
export interface EquipRefineReply {
    /**
     * @generated from protobuf field: optional int64 targetUid = 1;
     */
    targetUid?: bigint;
    /**
     * @generated from protobuf field: repeated int64 eatUids = 2;
     */
    eatUids: bigint[];
}
// @generated message type with reflection information, may provide speed optimized methods
class EquipDeletePush$Type extends MessageType<EquipDeletePush> {
    constructor() {
        super("EquipDeletePush", [
            { no: 1, name: "uids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EquipDeletePush>): EquipDeletePush {
        const message = { uids: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EquipDeletePush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EquipDeletePush): EquipDeletePush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int64 uids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.uids.push(reader.int64().toBigInt());
                    else
                        message.uids.push(reader.int64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EquipDeletePush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int64 uids = 1; */
        for (let i = 0; i < message.uids.length; i++)
            writer.tag(1, WireType.Varint).int64(message.uids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EquipDeletePush
 */
export const EquipDeletePush = new EquipDeletePush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EquipLockRequest$Type extends MessageType<EquipLockRequest> {
    constructor() {
        super("EquipLockRequest", [
            { no: 1, name: "targetUid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "lock", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EquipLockRequest>): EquipLockRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EquipLockRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EquipLockRequest): EquipLockRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 targetUid */ 1:
                    message.targetUid = reader.int64().toBigInt();
                    break;
                case /* optional bool lock */ 2:
                    message.lock = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EquipLockRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 targetUid = 1; */
        if (message.targetUid !== undefined)
            writer.tag(1, WireType.Varint).int64(message.targetUid);
        /* optional bool lock = 2; */
        if (message.lock !== undefined)
            writer.tag(2, WireType.Varint).bool(message.lock);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EquipLockRequest
 */
export const EquipLockRequest = new EquipLockRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EquipRefineRequest$Type extends MessageType<EquipRefineRequest> {
    constructor() {
        super("EquipRefineRequest", [
            { no: 1, name: "targetUid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "eatUids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EquipRefineRequest>): EquipRefineRequest {
        const message = { eatUids: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EquipRefineRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EquipRefineRequest): EquipRefineRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 targetUid */ 1:
                    message.targetUid = reader.int64().toBigInt();
                    break;
                case /* repeated int64 eatUids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.eatUids.push(reader.int64().toBigInt());
                    else
                        message.eatUids.push(reader.int64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EquipRefineRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 targetUid = 1; */
        if (message.targetUid !== undefined)
            writer.tag(1, WireType.Varint).int64(message.targetUid);
        /* repeated int64 eatUids = 2; */
        for (let i = 0; i < message.eatUids.length; i++)
            writer.tag(2, WireType.Varint).int64(message.eatUids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EquipRefineRequest
 */
export const EquipRefineRequest = new EquipRefineRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EquipDecomposeReply$Type extends MessageType<EquipDecomposeReply> {
    constructor() {
        super("EquipDecomposeReply", [
            { no: 1, name: "equipUids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EquipDecomposeReply>): EquipDecomposeReply {
        const message = { equipUids: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EquipDecomposeReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EquipDecomposeReply): EquipDecomposeReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int64 equipUids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.equipUids.push(reader.int64().toBigInt());
                    else
                        message.equipUids.push(reader.int64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EquipDecomposeReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int64 equipUids = 1; */
        for (let i = 0; i < message.equipUids.length; i++)
            writer.tag(1, WireType.Varint).int64(message.equipUids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EquipDecomposeReply
 */
export const EquipDecomposeReply = new EquipDecomposeReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EquipBreakReply$Type extends MessageType<EquipBreakReply> {
    constructor() {
        super("EquipBreakReply", []);
    }
    create(value?: PartialMessage<EquipBreakReply>): EquipBreakReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EquipBreakReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EquipBreakReply): EquipBreakReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: EquipBreakReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EquipBreakReply
 */
export const EquipBreakReply = new EquipBreakReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EquipStrengthenReply$Type extends MessageType<EquipStrengthenReply> {
    constructor() {
        super("EquipStrengthenReply", [
            { no: 1, name: "targetUid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "eatEquips", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => EatEquip }
        ]);
    }
    create(value?: PartialMessage<EquipStrengthenReply>): EquipStrengthenReply {
        const message = { eatEquips: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EquipStrengthenReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EquipStrengthenReply): EquipStrengthenReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 targetUid */ 1:
                    message.targetUid = reader.int64().toBigInt();
                    break;
                case /* repeated EatEquip eatEquips */ 2:
                    message.eatEquips.push(EatEquip.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EquipStrengthenReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 targetUid = 1; */
        if (message.targetUid !== undefined)
            writer.tag(1, WireType.Varint).int64(message.targetUid);
        /* repeated EatEquip eatEquips = 2; */
        for (let i = 0; i < message.eatEquips.length; i++)
            EatEquip.internalBinaryWrite(message.eatEquips[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EquipStrengthenReply
 */
export const EquipStrengthenReply = new EquipStrengthenReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EquipComposeRequest$Type extends MessageType<EquipComposeRequest> {
    constructor() {
        super("EquipComposeRequest", [
            { no: 1, name: "equipIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<EquipComposeRequest>): EquipComposeRequest {
        const message = { equipIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EquipComposeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EquipComposeRequest): EquipComposeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 equipIds */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.equipIds.push(reader.int32());
                    else
                        message.equipIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EquipComposeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 equipIds = 1; */
        for (let i = 0; i < message.equipIds.length; i++)
            writer.tag(1, WireType.Varint).int32(message.equipIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EquipComposeRequest
 */
export const EquipComposeRequest = new EquipComposeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEquipInfoReply$Type extends MessageType<GetEquipInfoReply> {
    constructor() {
        super("GetEquipInfoReply", [
            { no: 1, name: "equips", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Equip }
        ]);
    }
    create(value?: PartialMessage<GetEquipInfoReply>): GetEquipInfoReply {
        const message = { equips: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetEquipInfoReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEquipInfoReply): GetEquipInfoReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated Equip equips */ 1:
                    message.equips.push(Equip.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEquipInfoReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated Equip equips = 1; */
        for (let i = 0; i < message.equips.length; i++)
            Equip.internalBinaryWrite(message.equips[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetEquipInfoReply
 */
export const GetEquipInfoReply = new GetEquipInfoReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EquipLockReply$Type extends MessageType<EquipLockReply> {
    constructor() {
        super("EquipLockReply", [
            { no: 1, name: "targetUid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "lock", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EquipLockReply>): EquipLockReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EquipLockReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EquipLockReply): EquipLockReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 targetUid */ 1:
                    message.targetUid = reader.int64().toBigInt();
                    break;
                case /* optional bool lock */ 2:
                    message.lock = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EquipLockReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 targetUid = 1; */
        if (message.targetUid !== undefined)
            writer.tag(1, WireType.Varint).int64(message.targetUid);
        /* optional bool lock = 2; */
        if (message.lock !== undefined)
            writer.tag(2, WireType.Varint).bool(message.lock);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EquipLockReply
 */
export const EquipLockReply = new EquipLockReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EquipBreakRequest$Type extends MessageType<EquipBreakRequest> {
    constructor() {
        super("EquipBreakRequest", [
            { no: 1, name: "targetUid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EquipBreakRequest>): EquipBreakRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EquipBreakRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EquipBreakRequest): EquipBreakRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 targetUid */ 1:
                    message.targetUid = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EquipBreakRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 targetUid = 1; */
        if (message.targetUid !== undefined)
            writer.tag(1, WireType.Varint).int64(message.targetUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EquipBreakRequest
 */
export const EquipBreakRequest = new EquipBreakRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EquipUpdatePush$Type extends MessageType<EquipUpdatePush> {
    constructor() {
        super("EquipUpdatePush", [
            { no: 1, name: "equips", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Equip }
        ]);
    }
    create(value?: PartialMessage<EquipUpdatePush>): EquipUpdatePush {
        const message = { equips: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EquipUpdatePush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EquipUpdatePush): EquipUpdatePush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated Equip equips */ 1:
                    message.equips.push(Equip.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EquipUpdatePush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated Equip equips = 1; */
        for (let i = 0; i < message.equips.length; i++)
            Equip.internalBinaryWrite(message.equips[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EquipUpdatePush
 */
export const EquipUpdatePush = new EquipUpdatePush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Equip$Type extends MessageType<Equip> {
    constructor() {
        super("Equip", [
            { no: 1, name: "equipId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "uid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "level", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "exp", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "breakLv", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "isLock", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "refineLv", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Equip>): Equip {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Equip>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Equip): Equip {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 equipId */ 1:
                    message.equipId = reader.int32();
                    break;
                case /* optional int64 uid */ 2:
                    message.uid = reader.int64().toBigInt();
                    break;
                case /* optional int32 level */ 3:
                    message.level = reader.int32();
                    break;
                case /* optional int32 exp */ 4:
                    message.exp = reader.int32();
                    break;
                case /* optional int32 breakLv */ 5:
                    message.breakLv = reader.int32();
                    break;
                case /* optional int32 count */ 7:
                    message.count = reader.int32();
                    break;
                case /* optional bool isLock */ 8:
                    message.isLock = reader.bool();
                    break;
                case /* optional int32 refineLv */ 9:
                    message.refineLv = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Equip, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 equipId = 1; */
        if (message.equipId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.equipId);
        /* optional int64 uid = 2; */
        if (message.uid !== undefined)
            writer.tag(2, WireType.Varint).int64(message.uid);
        /* optional int32 level = 3; */
        if (message.level !== undefined)
            writer.tag(3, WireType.Varint).int32(message.level);
        /* optional int32 exp = 4; */
        if (message.exp !== undefined)
            writer.tag(4, WireType.Varint).int32(message.exp);
        /* optional int32 breakLv = 5; */
        if (message.breakLv !== undefined)
            writer.tag(5, WireType.Varint).int32(message.breakLv);
        /* optional int32 count = 7; */
        if (message.count !== undefined)
            writer.tag(7, WireType.Varint).int32(message.count);
        /* optional bool isLock = 8; */
        if (message.isLock !== undefined)
            writer.tag(8, WireType.Varint).bool(message.isLock);
        /* optional int32 refineLv = 9; */
        if (message.refineLv !== undefined)
            writer.tag(9, WireType.Varint).int32(message.refineLv);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Equip
 */
export const Equip = new Equip$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EquipStrengthenRequest$Type extends MessageType<EquipStrengthenRequest> {
    constructor() {
        super("EquipStrengthenRequest", [
            { no: 1, name: "targetUid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "eatEquips", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => EatEquip }
        ]);
    }
    create(value?: PartialMessage<EquipStrengthenRequest>): EquipStrengthenRequest {
        const message = { eatEquips: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EquipStrengthenRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EquipStrengthenRequest): EquipStrengthenRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 targetUid */ 1:
                    message.targetUid = reader.int64().toBigInt();
                    break;
                case /* repeated EatEquip eatEquips */ 2:
                    message.eatEquips.push(EatEquip.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EquipStrengthenRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 targetUid = 1; */
        if (message.targetUid !== undefined)
            writer.tag(1, WireType.Varint).int64(message.targetUid);
        /* repeated EatEquip eatEquips = 2; */
        for (let i = 0; i < message.eatEquips.length; i++)
            EatEquip.internalBinaryWrite(message.eatEquips[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EquipStrengthenRequest
 */
export const EquipStrengthenRequest = new EquipStrengthenRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EquipDecomposeRequest$Type extends MessageType<EquipDecomposeRequest> {
    constructor() {
        super("EquipDecomposeRequest", [
            { no: 1, name: "equipUids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EquipDecomposeRequest>): EquipDecomposeRequest {
        const message = { equipUids: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EquipDecomposeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EquipDecomposeRequest): EquipDecomposeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int64 equipUids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.equipUids.push(reader.int64().toBigInt());
                    else
                        message.equipUids.push(reader.int64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EquipDecomposeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int64 equipUids = 1; */
        for (let i = 0; i < message.equipUids.length; i++)
            writer.tag(1, WireType.Varint).int64(message.equipUids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EquipDecomposeRequest
 */
export const EquipDecomposeRequest = new EquipDecomposeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EatEquip$Type extends MessageType<EatEquip> {
    constructor() {
        super("EatEquip", [
            { no: 1, name: "eatUid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<EatEquip>): EatEquip {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EatEquip>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EatEquip): EatEquip {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 eatUid */ 1:
                    message.eatUid = reader.int64().toBigInt();
                    break;
                case /* optional int32 count */ 2:
                    message.count = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EatEquip, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 eatUid = 1; */
        if (message.eatUid !== undefined)
            writer.tag(1, WireType.Varint).int64(message.eatUid);
        /* optional int32 count = 2; */
        if (message.count !== undefined)
            writer.tag(2, WireType.Varint).int32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EatEquip
 */
export const EatEquip = new EatEquip$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEquipInfoRequest$Type extends MessageType<GetEquipInfoRequest> {
    constructor() {
        super("GetEquipInfoRequest", []);
    }
    create(value?: PartialMessage<GetEquipInfoRequest>): GetEquipInfoRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetEquipInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEquipInfoRequest): GetEquipInfoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetEquipInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetEquipInfoRequest
 */
export const GetEquipInfoRequest = new GetEquipInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EquipComposeReply$Type extends MessageType<EquipComposeReply> {
    constructor() {
        super("EquipComposeReply", [
            { no: 1, name: "equipIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<EquipComposeReply>): EquipComposeReply {
        const message = { equipIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EquipComposeReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EquipComposeReply): EquipComposeReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 equipIds */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.equipIds.push(reader.int32());
                    else
                        message.equipIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EquipComposeReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 equipIds = 1; */
        for (let i = 0; i < message.equipIds.length; i++)
            writer.tag(1, WireType.Varint).int32(message.equipIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EquipComposeReply
 */
export const EquipComposeReply = new EquipComposeReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EquipRefineReply$Type extends MessageType<EquipRefineReply> {
    constructor() {
        super("EquipRefineReply", [
            { no: 1, name: "targetUid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "eatUids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<EquipRefineReply>): EquipRefineReply {
        const message = { eatUids: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EquipRefineReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EquipRefineReply): EquipRefineReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 targetUid */ 1:
                    message.targetUid = reader.int64().toBigInt();
                    break;
                case /* repeated int64 eatUids */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.eatUids.push(reader.int64().toBigInt());
                    else
                        message.eatUids.push(reader.int64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EquipRefineReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 targetUid = 1; */
        if (message.targetUid !== undefined)
            writer.tag(1, WireType.Varint).int64(message.targetUid);
        /* repeated int64 eatUids = 2; */
        for (let i = 0; i < message.eatUids.length; i++)
            writer.tag(2, WireType.Varint).int64(message.eatUids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EquipRefineReply
 */
export const EquipRefineReply = new EquipRefineReply$Type();
