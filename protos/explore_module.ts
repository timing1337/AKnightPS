// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "explore_module.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { HeroGroupInfo } from "./hero_def";
import { MaterialData } from "./material_module";
/**
 * @generated from protobuf message StartExplorePush
 */
export interface StartExplorePush {
    /**
     * @generated from protobuf field: optional ExploreInfoNO exploreInfo = 1;
     */
    exploreInfo?: ExploreInfoNO;
}
/**
 * @generated from protobuf message GetExploreSimpleInfoReply
 */
export interface GetExploreSimpleInfoReply {
    /**
     * @generated from protobuf field: int32 chapterIds = 1;
     */
    chapterIds: number;
    /**
     * @generated from protobuf field: int32 interactNum = 2;
     */
    interactNum: number;
}
/**
 * @generated from protobuf message ExploreInteractSetStepRequest
 */
export interface ExploreInteractSetStepRequest {
    /**
     * @generated from protobuf field: optional int32 type = 1;
     */
    type?: number;
    /**
     * @generated from protobuf field: optional int32 id = 2;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional int32 step = 3;
     */
    step?: number;
}
/**
 * @generated from protobuf message ExploreSetAreaVisibleReply
 */
export interface ExploreSetAreaVisibleReply {
    /**
     * @generated from protobuf field: optional int32 mapId = 1;
     */
    mapId?: number;
    /**
     * @generated from protobuf field: optional int32 areaId = 2;
     */
    areaId?: number;
    /**
     * @generated from protobuf field: optional bool visible = 3;
     */
    visible?: boolean;
}
/**
 * @generated from protobuf message ExploreForeverInfoNO
 */
export interface ExploreForeverInfoNO {
    /**
     * @generated from protobuf field: optional int32 mapId = 1;
     */
    mapId?: number;
    /**
     * @generated from protobuf field: optional int32 interactType = 2;
     */
    interactType?: number;
    /**
     * @generated from protobuf field: optional int32 finishCount = 3;
     */
    finishCount?: number;
}
/**
 * @generated from protobuf message ExploreMoveReply
 */
export interface ExploreMoveReply {
}
/**
 * @generated from protobuf message ExploreItemInteractReply
 */
export interface ExploreItemInteractReply {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional string params = 2;
     */
    params?: string;
    /**
     * @generated from protobuf field: ExploreInteractNO interacts = 3;
     */
    interacts?: ExploreInteractNO;
    /**
     * @generated from protobuf field: ExploreInteractNO deleteInteracts = 4;
     */
    deleteInteracts?: ExploreInteractNO;
}
/**
 * @generated from protobuf message EnterChapterRequest
 */
export interface EnterChapterRequest {
    /**
     * @generated from protobuf field: optional int32 chapterId = 1;
     */
    chapterId?: number;
}
/**
 * @generated from protobuf message ExploreInteractReply
 */
export interface ExploreInteractReply {
    /**
     * @generated from protobuf field: optional int32 mapId = 1;
     */
    mapId?: number;
    /**
     * @generated from protobuf field: optional int32 id = 2;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional string params = 3;
     */
    params?: string;
    /**
     * @generated from protobuf field: MaterialData dataList = 4;
     */
    dataList?: MaterialData;
    /**
     * @generated from protobuf field: ExploreInteractNO interacts = 5;
     */
    interacts?: ExploreInteractNO;
    /**
     * @generated from protobuf field: ExploreInteractNO deleteInteracts = 6;
     */
    deleteInteracts?: ExploreInteractNO;
}
/**
 * @generated from protobuf message ExploreInteractSetStatusRequest
 */
export interface ExploreInteractSetStatusRequest {
    /**
     * @generated from protobuf field: optional int32 type = 1;
     */
    type?: number;
    /**
     * @generated from protobuf field: optional int32 id = 2;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional int32 status = 3;
     */
    status?: number;
}
/**
 * @generated from protobuf message ExploreItemChangePush
 */
export interface ExploreItemChangePush {
    /**
     * @generated from protobuf field: ExploreItemNO exploreItems = 1;
     */
    exploreItems?: ExploreItemNO;
}
/**
 * @generated from protobuf message ExploreInteractSetStatus2Reply
 */
export interface ExploreInteractSetStatus2Reply {
    /**
     * @generated from protobuf field: optional int32 mapId = 1;
     */
    mapId?: number;
    /**
     * @generated from protobuf field: optional int32 type = 2;
     */
    type?: number;
    /**
     * @generated from protobuf field: optional int32 id = 3;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional string status2 = 4;
     */
    status2?: string;
}
/**
 * @generated from protobuf message ExploreUseItemRequest
 */
export interface ExploreUseItemRequest {
    /**
     * @generated from protobuf field: optional int64 uid = 1;
     */
    uid?: bigint;
    /**
     * @generated from protobuf field: optional int32 posx = 2;
     */
    posx?: number;
    /**
     * @generated from protobuf field: optional int32 posy = 3;
     */
    posy?: number;
    /**
     * @generated from protobuf field: optional int32 interactId = 4;
     */
    interactId?: number;
}
/**
 * @generated from protobuf message ExploreSeatNO
 */
export interface ExploreSeatNO {
    /**
     * @generated from protobuf field: optional int32 areaId = 1;
     */
    areaId?: number;
    /**
     * @generated from protobuf field: optional int32 x = 2;
     */
    x?: number;
    /**
     * @generated from protobuf field: optional int32 y = 3;
     */
    y?: number;
}
/**
 * @generated from protobuf message GetExploreInfoRequest
 */
export interface GetExploreInfoRequest {
}
/**
 * @generated from protobuf message ExploreInteractRequest
 */
export interface ExploreInteractRequest {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional int32 step = 2;
     */
    step?: number;
    /**
     * @generated from protobuf field: optional string params = 3;
     */
    params?: string;
}
/**
 * @generated from protobuf message GetExploreSimpleInfoRequest
 */
export interface GetExploreSimpleInfoRequest {
}
/**
 * @generated from protobuf message ExploreMapNO
 */
export interface ExploreMapNO {
    /**
     * @generated from protobuf field: optional int32 mapId = 1;
     */
    mapId?: number;
    /**
     * @generated from protobuf field: optional int32 posx = 2;
     */
    posx?: number;
    /**
     * @generated from protobuf field: optional int32 posy = 3;
     */
    posy?: number;
    /**
     * @generated from protobuf field: ExploreInteractNO interacts = 4;
     */
    interacts?: ExploreInteractNO;
    /**
     * @generated from protobuf field: ExploreAreaSightNO areaSights = 5;
     */
    areaSights?: ExploreAreaSightNO;
    /**
     * @generated from protobuf field: optional int32 lastInteractType = 6;
     */
    lastInteractType?: number;
    /**
     * @generated from protobuf field: optional int32 lastInteract = 7;
     */
    lastInteract?: number;
    /**
     * @generated from protobuf field: optional int32 bonusNum = 8;
     */
    bonusNum?: number;
    /**
     * @generated from protobuf field: optional int32 goldCoin = 9;
     */
    goldCoin?: number;
    /**
     * @generated from protobuf field: optional int32 purpleCoin = 10;
     */
    purpleCoin?: number;
}
/**
 * @generated from protobuf message GetExploreInfoReply
 */
export interface GetExploreInfoReply {
    /**
     * @generated from protobuf field: optional ExploreInfoNO exploreInfo = 1;
     */
    exploreInfo?: ExploreInfoNO;
    /**
     * @generated from protobuf field: ExploreForeverInfoNO foreverInfos = 2;
     */
    foreverInfos?: ExploreForeverInfoNO;
}
/**
 * @generated from protobuf message ExploreInteractSetStatusReply
 */
export interface ExploreInteractSetStatusReply {
    /**
     * @generated from protobuf field: optional int32 mapId = 1;
     */
    mapId?: number;
    /**
     * @generated from protobuf field: optional int32 type = 2;
     */
    type?: number;
    /**
     * @generated from protobuf field: optional int32 id = 3;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional int32 status = 4;
     */
    status?: number;
}
/**
 * @generated from protobuf message ExploreItemInteractRequest
 */
export interface ExploreItemInteractRequest {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional string params = 2;
     */
    params?: string;
}
/**
 * @generated from protobuf message ExploreInteractNO
 */
export interface ExploreInteractNO {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional int32 type = 2;
     */
    type?: number;
    /**
     * @generated from protobuf field: optional int32 status = 3;
     */
    status?: number;
    /**
     * @generated from protobuf field: optional string status2 = 4;
     */
    status2?: string;
    /**
     * @generated from protobuf field: optional int32 step = 5;
     */
    step?: number;
    /**
     * @generated from protobuf field: optional int32 posx = 6;
     */
    posx?: number;
    /**
     * @generated from protobuf field: optional int32 posy = 7;
     */
    posy?: number;
    /**
     * @generated from protobuf field: optional int32 dir = 8;
     */
    dir?: number;
}
/**
 * @generated from protobuf message ChangeMapRequest
 */
export interface ChangeMapRequest {
    /**
     * @generated from protobuf field: optional int32 mapId = 1;
     */
    mapId?: number;
    /**
     * @generated from protobuf field: optional int32 posx = 2;
     */
    posx?: number;
    /**
     * @generated from protobuf field: optional int32 posy = 3;
     */
    posy?: number;
}
/**
 * @generated from protobuf message ExploreUseItemReply
 */
export interface ExploreUseItemReply {
    /**
     * @generated from protobuf field: ExploreInteractNO interacts = 1;
     */
    interacts?: ExploreInteractNO;
    /**
     * @generated from protobuf field: ExploreInteractNO deleteInteracts = 2;
     */
    deleteInteracts?: ExploreInteractNO;
    /**
     * @generated from protobuf field: optional int64 useItemUid = 3;
     */
    useItemUid?: bigint;
}
/**
 * @generated from protobuf message ExploreItemNO
 */
export interface ExploreItemNO {
    /**
     * @generated from protobuf field: optional int64 uid = 1;
     */
    uid?: bigint;
    /**
     * @generated from protobuf field: optional int32 itemId = 2;
     */
    itemId?: number;
    /**
     * @generated from protobuf field: optional int32 quantity = 3;
     */
    quantity?: number;
    /**
     * @generated from protobuf field: optional int32 status = 4;
     */
    status?: number;
}
/**
 * @generated from protobuf message ExploreAreaSightNO
 */
export interface ExploreAreaSightNO {
    /**
     * @generated from protobuf field: optional int32 areaId = 1;
     */
    areaId?: number;
    /**
     * @generated from protobuf field: optional bytes sight = 2;
     */
    sight?: Uint8Array;
    /**
     * @generated from protobuf field: optional bool visible = 3;
     */
    visible?: boolean;
}
/**
 * @generated from protobuf message ChangeMapReply
 */
export interface ChangeMapReply {
    /**
     * @generated from protobuf field: optional int32 mapId = 1;
     */
    mapId?: number;
    /**
     * @generated from protobuf field: optional int32 posx = 2;
     */
    posx?: number;
    /**
     * @generated from protobuf field: optional int32 posy = 3;
     */
    posy?: number;
    /**
     * @generated from protobuf field: optional ExploreInfoNO exploreInfo = 4;
     */
    exploreInfo?: ExploreInfoNO;
}
/**
 * @generated from protobuf message ExploreInteractSetStatus2Request
 */
export interface ExploreInteractSetStatus2Request {
    /**
     * @generated from protobuf field: optional int32 type = 1;
     */
    type?: number;
    /**
     * @generated from protobuf field: optional int32 id = 2;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional string status2 = 3;
     */
    status2?: string;
}
/**
 * @generated from protobuf message ExploreMoveRequest
 */
export interface ExploreMoveRequest {
    /**
     * @generated from protobuf field: optional int32 posx = 1;
     */
    posx?: number;
    /**
     * @generated from protobuf field: optional int32 posy = 2;
     */
    posy?: number;
    /**
     * @generated from protobuf field: ExploreSeatNO sightChange = 3;
     */
    sightChange?: ExploreSeatNO;
    /**
     * @generated from protobuf field: optional int32 interactId = 4;
     */
    interactId?: number;
}
/**
 * @generated from protobuf message ExploreSetAreaVisibleRequest
 */
export interface ExploreSetAreaVisibleRequest {
    /**
     * @generated from protobuf field: optional int32 areaId = 1;
     */
    areaId?: number;
    /**
     * @generated from protobuf field: optional bool visible = 2;
     */
    visible?: boolean;
}
/**
 * @generated from protobuf message ExploreInfoNO
 */
export interface ExploreInfoNO {
    /**
     * @generated from protobuf field: optional ExploreMapNO exploreMap = 1;
     */
    exploreMap?: ExploreMapNO;
    /**
     * @generated from protobuf field: optional HeroGroupInfo heroGroupSnapshot = 2;
     */
    heroGroupSnapshot?: HeroGroupInfo;
    /**
     * @generated from protobuf field: ExploreItemNO exploreItems = 3;
     */
    exploreItems?: ExploreItemNO;
    /**
     * @generated from protobuf field: optional int64 useItemUid = 4;
     */
    useItemUid?: bigint;
}
/**
 * @generated from protobuf message EnterChapterReply
 */
export interface EnterChapterReply {
    /**
     * @generated from protobuf field: optional int32 chapterId = 1;
     */
    chapterId?: number;
    /**
     * @generated from protobuf field: optional ExploreInfoNO exploreInfo = 2;
     */
    exploreInfo?: ExploreInfoNO;
}
/**
 * @generated from protobuf message ExploreInteractSetStepReply
 */
export interface ExploreInteractSetStepReply {
    /**
     * @generated from protobuf field: optional int32 mapId = 1;
     */
    mapId?: number;
    /**
     * @generated from protobuf field: optional int32 type = 2;
     */
    type?: number;
    /**
     * @generated from protobuf field: optional int32 id = 3;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional int32 step = 4;
     */
    step?: number;
}
// @generated message type with reflection information, may provide speed optimized methods
class StartExplorePush$Type extends MessageType<StartExplorePush> {
    constructor() {
        super("StartExplorePush", [
            { no: 1, name: "exploreInfo", kind: "message", T: () => ExploreInfoNO }
        ]);
    }
    create(value?: PartialMessage<StartExplorePush>): StartExplorePush {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StartExplorePush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartExplorePush): StartExplorePush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional ExploreInfoNO exploreInfo */ 1:
                    message.exploreInfo = ExploreInfoNO.internalBinaryRead(reader, reader.uint32(), options, message.exploreInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartExplorePush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional ExploreInfoNO exploreInfo = 1; */
        if (message.exploreInfo)
            ExploreInfoNO.internalBinaryWrite(message.exploreInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StartExplorePush
 */
export const StartExplorePush = new StartExplorePush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetExploreSimpleInfoReply$Type extends MessageType<GetExploreSimpleInfoReply> {
    constructor() {
        super("GetExploreSimpleInfoReply", [
            { no: 1, name: "chapterIds", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "interactNum", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetExploreSimpleInfoReply>): GetExploreSimpleInfoReply {
        const message = { chapterIds: 0, interactNum: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetExploreSimpleInfoReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetExploreSimpleInfoReply): GetExploreSimpleInfoReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 chapterIds */ 1:
                    message.chapterIds = reader.int32();
                    break;
                case /* int32 interactNum */ 2:
                    message.interactNum = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetExploreSimpleInfoReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 chapterIds = 1; */
        if (message.chapterIds !== 0)
            writer.tag(1, WireType.Varint).int32(message.chapterIds);
        /* int32 interactNum = 2; */
        if (message.interactNum !== 0)
            writer.tag(2, WireType.Varint).int32(message.interactNum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetExploreSimpleInfoReply
 */
export const GetExploreSimpleInfoReply = new GetExploreSimpleInfoReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExploreInteractSetStepRequest$Type extends MessageType<ExploreInteractSetStepRequest> {
    constructor() {
        super("ExploreInteractSetStepRequest", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "step", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ExploreInteractSetStepRequest>): ExploreInteractSetStepRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExploreInteractSetStepRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExploreInteractSetStepRequest): ExploreInteractSetStepRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional int32 id */ 2:
                    message.id = reader.int32();
                    break;
                case /* optional int32 step */ 3:
                    message.step = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExploreInteractSetStepRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional int32 id = 2; */
        if (message.id !== undefined)
            writer.tag(2, WireType.Varint).int32(message.id);
        /* optional int32 step = 3; */
        if (message.step !== undefined)
            writer.tag(3, WireType.Varint).int32(message.step);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExploreInteractSetStepRequest
 */
export const ExploreInteractSetStepRequest = new ExploreInteractSetStepRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExploreSetAreaVisibleReply$Type extends MessageType<ExploreSetAreaVisibleReply> {
    constructor() {
        super("ExploreSetAreaVisibleReply", [
            { no: 1, name: "mapId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "areaId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "visible", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ExploreSetAreaVisibleReply>): ExploreSetAreaVisibleReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExploreSetAreaVisibleReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExploreSetAreaVisibleReply): ExploreSetAreaVisibleReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 mapId */ 1:
                    message.mapId = reader.int32();
                    break;
                case /* optional int32 areaId */ 2:
                    message.areaId = reader.int32();
                    break;
                case /* optional bool visible */ 3:
                    message.visible = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExploreSetAreaVisibleReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 mapId = 1; */
        if (message.mapId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.mapId);
        /* optional int32 areaId = 2; */
        if (message.areaId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.areaId);
        /* optional bool visible = 3; */
        if (message.visible !== undefined)
            writer.tag(3, WireType.Varint).bool(message.visible);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExploreSetAreaVisibleReply
 */
export const ExploreSetAreaVisibleReply = new ExploreSetAreaVisibleReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExploreForeverInfoNO$Type extends MessageType<ExploreForeverInfoNO> {
    constructor() {
        super("ExploreForeverInfoNO", [
            { no: 1, name: "mapId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "interactType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "finishCount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ExploreForeverInfoNO>): ExploreForeverInfoNO {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExploreForeverInfoNO>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExploreForeverInfoNO): ExploreForeverInfoNO {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 mapId */ 1:
                    message.mapId = reader.int32();
                    break;
                case /* optional int32 interactType */ 2:
                    message.interactType = reader.int32();
                    break;
                case /* optional int32 finishCount */ 3:
                    message.finishCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExploreForeverInfoNO, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 mapId = 1; */
        if (message.mapId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.mapId);
        /* optional int32 interactType = 2; */
        if (message.interactType !== undefined)
            writer.tag(2, WireType.Varint).int32(message.interactType);
        /* optional int32 finishCount = 3; */
        if (message.finishCount !== undefined)
            writer.tag(3, WireType.Varint).int32(message.finishCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExploreForeverInfoNO
 */
export const ExploreForeverInfoNO = new ExploreForeverInfoNO$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExploreMoveReply$Type extends MessageType<ExploreMoveReply> {
    constructor() {
        super("ExploreMoveReply", []);
    }
    create(value?: PartialMessage<ExploreMoveReply>): ExploreMoveReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExploreMoveReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExploreMoveReply): ExploreMoveReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ExploreMoveReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExploreMoveReply
 */
export const ExploreMoveReply = new ExploreMoveReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExploreItemInteractReply$Type extends MessageType<ExploreItemInteractReply> {
    constructor() {
        super("ExploreItemInteractReply", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "params", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "interacts", kind: "message", T: () => ExploreInteractNO },
            { no: 4, name: "deleteInteracts", kind: "message", T: () => ExploreInteractNO }
        ]);
    }
    create(value?: PartialMessage<ExploreItemInteractReply>): ExploreItemInteractReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExploreItemInteractReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExploreItemInteractReply): ExploreItemInteractReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* optional string params */ 2:
                    message.params = reader.string();
                    break;
                case /* ExploreInteractNO interacts */ 3:
                    message.interacts = ExploreInteractNO.internalBinaryRead(reader, reader.uint32(), options, message.interacts);
                    break;
                case /* ExploreInteractNO deleteInteracts */ 4:
                    message.deleteInteracts = ExploreInteractNO.internalBinaryRead(reader, reader.uint32(), options, message.deleteInteracts);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExploreItemInteractReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* optional string params = 2; */
        if (message.params !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.params);
        /* ExploreInteractNO interacts = 3; */
        if (message.interacts)
            ExploreInteractNO.internalBinaryWrite(message.interacts, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* ExploreInteractNO deleteInteracts = 4; */
        if (message.deleteInteracts)
            ExploreInteractNO.internalBinaryWrite(message.deleteInteracts, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExploreItemInteractReply
 */
export const ExploreItemInteractReply = new ExploreItemInteractReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnterChapterRequest$Type extends MessageType<EnterChapterRequest> {
    constructor() {
        super("EnterChapterRequest", [
            { no: 1, name: "chapterId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<EnterChapterRequest>): EnterChapterRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EnterChapterRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnterChapterRequest): EnterChapterRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterId */ 1:
                    message.chapterId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EnterChapterRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterId = 1; */
        if (message.chapterId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EnterChapterRequest
 */
export const EnterChapterRequest = new EnterChapterRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExploreInteractReply$Type extends MessageType<ExploreInteractReply> {
    constructor() {
        super("ExploreInteractReply", [
            { no: 1, name: "mapId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "params", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "dataList", kind: "message", T: () => MaterialData },
            { no: 5, name: "interacts", kind: "message", T: () => ExploreInteractNO },
            { no: 6, name: "deleteInteracts", kind: "message", T: () => ExploreInteractNO }
        ]);
    }
    create(value?: PartialMessage<ExploreInteractReply>): ExploreInteractReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExploreInteractReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExploreInteractReply): ExploreInteractReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 mapId */ 1:
                    message.mapId = reader.int32();
                    break;
                case /* optional int32 id */ 2:
                    message.id = reader.int32();
                    break;
                case /* optional string params */ 3:
                    message.params = reader.string();
                    break;
                case /* MaterialData dataList */ 4:
                    message.dataList = MaterialData.internalBinaryRead(reader, reader.uint32(), options, message.dataList);
                    break;
                case /* ExploreInteractNO interacts */ 5:
                    message.interacts = ExploreInteractNO.internalBinaryRead(reader, reader.uint32(), options, message.interacts);
                    break;
                case /* ExploreInteractNO deleteInteracts */ 6:
                    message.deleteInteracts = ExploreInteractNO.internalBinaryRead(reader, reader.uint32(), options, message.deleteInteracts);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExploreInteractReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 mapId = 1; */
        if (message.mapId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.mapId);
        /* optional int32 id = 2; */
        if (message.id !== undefined)
            writer.tag(2, WireType.Varint).int32(message.id);
        /* optional string params = 3; */
        if (message.params !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.params);
        /* MaterialData dataList = 4; */
        if (message.dataList)
            MaterialData.internalBinaryWrite(message.dataList, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* ExploreInteractNO interacts = 5; */
        if (message.interacts)
            ExploreInteractNO.internalBinaryWrite(message.interacts, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* ExploreInteractNO deleteInteracts = 6; */
        if (message.deleteInteracts)
            ExploreInteractNO.internalBinaryWrite(message.deleteInteracts, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExploreInteractReply
 */
export const ExploreInteractReply = new ExploreInteractReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExploreInteractSetStatusRequest$Type extends MessageType<ExploreInteractSetStatusRequest> {
    constructor() {
        super("ExploreInteractSetStatusRequest", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "status", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ExploreInteractSetStatusRequest>): ExploreInteractSetStatusRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExploreInteractSetStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExploreInteractSetStatusRequest): ExploreInteractSetStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional int32 id */ 2:
                    message.id = reader.int32();
                    break;
                case /* optional int32 status */ 3:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExploreInteractSetStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional int32 id = 2; */
        if (message.id !== undefined)
            writer.tag(2, WireType.Varint).int32(message.id);
        /* optional int32 status = 3; */
        if (message.status !== undefined)
            writer.tag(3, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExploreInteractSetStatusRequest
 */
export const ExploreInteractSetStatusRequest = new ExploreInteractSetStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExploreItemChangePush$Type extends MessageType<ExploreItemChangePush> {
    constructor() {
        super("ExploreItemChangePush", [
            { no: 1, name: "exploreItems", kind: "message", T: () => ExploreItemNO }
        ]);
    }
    create(value?: PartialMessage<ExploreItemChangePush>): ExploreItemChangePush {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExploreItemChangePush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExploreItemChangePush): ExploreItemChangePush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ExploreItemNO exploreItems */ 1:
                    message.exploreItems = ExploreItemNO.internalBinaryRead(reader, reader.uint32(), options, message.exploreItems);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExploreItemChangePush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ExploreItemNO exploreItems = 1; */
        if (message.exploreItems)
            ExploreItemNO.internalBinaryWrite(message.exploreItems, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExploreItemChangePush
 */
export const ExploreItemChangePush = new ExploreItemChangePush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExploreInteractSetStatus2Reply$Type extends MessageType<ExploreInteractSetStatus2Reply> {
    constructor() {
        super("ExploreInteractSetStatus2Reply", [
            { no: 1, name: "mapId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "status2", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExploreInteractSetStatus2Reply>): ExploreInteractSetStatus2Reply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExploreInteractSetStatus2Reply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExploreInteractSetStatus2Reply): ExploreInteractSetStatus2Reply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 mapId */ 1:
                    message.mapId = reader.int32();
                    break;
                case /* optional int32 type */ 2:
                    message.type = reader.int32();
                    break;
                case /* optional int32 id */ 3:
                    message.id = reader.int32();
                    break;
                case /* optional string status2 */ 4:
                    message.status2 = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExploreInteractSetStatus2Reply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 mapId = 1; */
        if (message.mapId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.mapId);
        /* optional int32 type = 2; */
        if (message.type !== undefined)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* optional int32 id = 3; */
        if (message.id !== undefined)
            writer.tag(3, WireType.Varint).int32(message.id);
        /* optional string status2 = 4; */
        if (message.status2 !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.status2);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExploreInteractSetStatus2Reply
 */
export const ExploreInteractSetStatus2Reply = new ExploreInteractSetStatus2Reply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExploreUseItemRequest$Type extends MessageType<ExploreUseItemRequest> {
    constructor() {
        super("ExploreUseItemRequest", [
            { no: 1, name: "uid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "posx", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "posy", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "interactId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ExploreUseItemRequest>): ExploreUseItemRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExploreUseItemRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExploreUseItemRequest): ExploreUseItemRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 uid */ 1:
                    message.uid = reader.int64().toBigInt();
                    break;
                case /* optional int32 posx */ 2:
                    message.posx = reader.int32();
                    break;
                case /* optional int32 posy */ 3:
                    message.posy = reader.int32();
                    break;
                case /* optional int32 interactId */ 4:
                    message.interactId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExploreUseItemRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 uid = 1; */
        if (message.uid !== undefined)
            writer.tag(1, WireType.Varint).int64(message.uid);
        /* optional int32 posx = 2; */
        if (message.posx !== undefined)
            writer.tag(2, WireType.Varint).int32(message.posx);
        /* optional int32 posy = 3; */
        if (message.posy !== undefined)
            writer.tag(3, WireType.Varint).int32(message.posy);
        /* optional int32 interactId = 4; */
        if (message.interactId !== undefined)
            writer.tag(4, WireType.Varint).int32(message.interactId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExploreUseItemRequest
 */
export const ExploreUseItemRequest = new ExploreUseItemRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExploreSeatNO$Type extends MessageType<ExploreSeatNO> {
    constructor() {
        super("ExploreSeatNO", [
            { no: 1, name: "areaId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "x", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "y", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ExploreSeatNO>): ExploreSeatNO {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExploreSeatNO>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExploreSeatNO): ExploreSeatNO {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 areaId */ 1:
                    message.areaId = reader.int32();
                    break;
                case /* optional int32 x */ 2:
                    message.x = reader.int32();
                    break;
                case /* optional int32 y */ 3:
                    message.y = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExploreSeatNO, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 areaId = 1; */
        if (message.areaId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.areaId);
        /* optional int32 x = 2; */
        if (message.x !== undefined)
            writer.tag(2, WireType.Varint).int32(message.x);
        /* optional int32 y = 3; */
        if (message.y !== undefined)
            writer.tag(3, WireType.Varint).int32(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExploreSeatNO
 */
export const ExploreSeatNO = new ExploreSeatNO$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetExploreInfoRequest$Type extends MessageType<GetExploreInfoRequest> {
    constructor() {
        super("GetExploreInfoRequest", []);
    }
    create(value?: PartialMessage<GetExploreInfoRequest>): GetExploreInfoRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetExploreInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetExploreInfoRequest): GetExploreInfoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetExploreInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetExploreInfoRequest
 */
export const GetExploreInfoRequest = new GetExploreInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExploreInteractRequest$Type extends MessageType<ExploreInteractRequest> {
    constructor() {
        super("ExploreInteractRequest", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "step", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "params", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExploreInteractRequest>): ExploreInteractRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExploreInteractRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExploreInteractRequest): ExploreInteractRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* optional int32 step */ 2:
                    message.step = reader.int32();
                    break;
                case /* optional string params */ 3:
                    message.params = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExploreInteractRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* optional int32 step = 2; */
        if (message.step !== undefined)
            writer.tag(2, WireType.Varint).int32(message.step);
        /* optional string params = 3; */
        if (message.params !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.params);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExploreInteractRequest
 */
export const ExploreInteractRequest = new ExploreInteractRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetExploreSimpleInfoRequest$Type extends MessageType<GetExploreSimpleInfoRequest> {
    constructor() {
        super("GetExploreSimpleInfoRequest", []);
    }
    create(value?: PartialMessage<GetExploreSimpleInfoRequest>): GetExploreSimpleInfoRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetExploreSimpleInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetExploreSimpleInfoRequest): GetExploreSimpleInfoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetExploreSimpleInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetExploreSimpleInfoRequest
 */
export const GetExploreSimpleInfoRequest = new GetExploreSimpleInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExploreMapNO$Type extends MessageType<ExploreMapNO> {
    constructor() {
        super("ExploreMapNO", [
            { no: 1, name: "mapId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "posx", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "posy", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "interacts", kind: "message", T: () => ExploreInteractNO },
            { no: 5, name: "areaSights", kind: "message", T: () => ExploreAreaSightNO },
            { no: 6, name: "lastInteractType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "lastInteract", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "bonusNum", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "goldCoin", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "purpleCoin", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ExploreMapNO>): ExploreMapNO {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExploreMapNO>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExploreMapNO): ExploreMapNO {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 mapId */ 1:
                    message.mapId = reader.int32();
                    break;
                case /* optional int32 posx */ 2:
                    message.posx = reader.int32();
                    break;
                case /* optional int32 posy */ 3:
                    message.posy = reader.int32();
                    break;
                case /* ExploreInteractNO interacts */ 4:
                    message.interacts = ExploreInteractNO.internalBinaryRead(reader, reader.uint32(), options, message.interacts);
                    break;
                case /* ExploreAreaSightNO areaSights */ 5:
                    message.areaSights = ExploreAreaSightNO.internalBinaryRead(reader, reader.uint32(), options, message.areaSights);
                    break;
                case /* optional int32 lastInteractType */ 6:
                    message.lastInteractType = reader.int32();
                    break;
                case /* optional int32 lastInteract */ 7:
                    message.lastInteract = reader.int32();
                    break;
                case /* optional int32 bonusNum */ 8:
                    message.bonusNum = reader.int32();
                    break;
                case /* optional int32 goldCoin */ 9:
                    message.goldCoin = reader.int32();
                    break;
                case /* optional int32 purpleCoin */ 10:
                    message.purpleCoin = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExploreMapNO, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 mapId = 1; */
        if (message.mapId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.mapId);
        /* optional int32 posx = 2; */
        if (message.posx !== undefined)
            writer.tag(2, WireType.Varint).int32(message.posx);
        /* optional int32 posy = 3; */
        if (message.posy !== undefined)
            writer.tag(3, WireType.Varint).int32(message.posy);
        /* ExploreInteractNO interacts = 4; */
        if (message.interacts)
            ExploreInteractNO.internalBinaryWrite(message.interacts, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* ExploreAreaSightNO areaSights = 5; */
        if (message.areaSights)
            ExploreAreaSightNO.internalBinaryWrite(message.areaSights, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 lastInteractType = 6; */
        if (message.lastInteractType !== undefined)
            writer.tag(6, WireType.Varint).int32(message.lastInteractType);
        /* optional int32 lastInteract = 7; */
        if (message.lastInteract !== undefined)
            writer.tag(7, WireType.Varint).int32(message.lastInteract);
        /* optional int32 bonusNum = 8; */
        if (message.bonusNum !== undefined)
            writer.tag(8, WireType.Varint).int32(message.bonusNum);
        /* optional int32 goldCoin = 9; */
        if (message.goldCoin !== undefined)
            writer.tag(9, WireType.Varint).int32(message.goldCoin);
        /* optional int32 purpleCoin = 10; */
        if (message.purpleCoin !== undefined)
            writer.tag(10, WireType.Varint).int32(message.purpleCoin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExploreMapNO
 */
export const ExploreMapNO = new ExploreMapNO$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetExploreInfoReply$Type extends MessageType<GetExploreInfoReply> {
    constructor() {
        super("GetExploreInfoReply", [
            { no: 1, name: "exploreInfo", kind: "message", T: () => ExploreInfoNO },
            { no: 2, name: "foreverInfos", kind: "message", T: () => ExploreForeverInfoNO }
        ]);
    }
    create(value?: PartialMessage<GetExploreInfoReply>): GetExploreInfoReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetExploreInfoReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetExploreInfoReply): GetExploreInfoReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional ExploreInfoNO exploreInfo */ 1:
                    message.exploreInfo = ExploreInfoNO.internalBinaryRead(reader, reader.uint32(), options, message.exploreInfo);
                    break;
                case /* ExploreForeverInfoNO foreverInfos */ 2:
                    message.foreverInfos = ExploreForeverInfoNO.internalBinaryRead(reader, reader.uint32(), options, message.foreverInfos);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetExploreInfoReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional ExploreInfoNO exploreInfo = 1; */
        if (message.exploreInfo)
            ExploreInfoNO.internalBinaryWrite(message.exploreInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* ExploreForeverInfoNO foreverInfos = 2; */
        if (message.foreverInfos)
            ExploreForeverInfoNO.internalBinaryWrite(message.foreverInfos, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetExploreInfoReply
 */
export const GetExploreInfoReply = new GetExploreInfoReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExploreInteractSetStatusReply$Type extends MessageType<ExploreInteractSetStatusReply> {
    constructor() {
        super("ExploreInteractSetStatusReply", [
            { no: 1, name: "mapId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "status", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ExploreInteractSetStatusReply>): ExploreInteractSetStatusReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExploreInteractSetStatusReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExploreInteractSetStatusReply): ExploreInteractSetStatusReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 mapId */ 1:
                    message.mapId = reader.int32();
                    break;
                case /* optional int32 type */ 2:
                    message.type = reader.int32();
                    break;
                case /* optional int32 id */ 3:
                    message.id = reader.int32();
                    break;
                case /* optional int32 status */ 4:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExploreInteractSetStatusReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 mapId = 1; */
        if (message.mapId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.mapId);
        /* optional int32 type = 2; */
        if (message.type !== undefined)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* optional int32 id = 3; */
        if (message.id !== undefined)
            writer.tag(3, WireType.Varint).int32(message.id);
        /* optional int32 status = 4; */
        if (message.status !== undefined)
            writer.tag(4, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExploreInteractSetStatusReply
 */
export const ExploreInteractSetStatusReply = new ExploreInteractSetStatusReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExploreItemInteractRequest$Type extends MessageType<ExploreItemInteractRequest> {
    constructor() {
        super("ExploreItemInteractRequest", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "params", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExploreItemInteractRequest>): ExploreItemInteractRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExploreItemInteractRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExploreItemInteractRequest): ExploreItemInteractRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* optional string params */ 2:
                    message.params = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExploreItemInteractRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* optional string params = 2; */
        if (message.params !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.params);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExploreItemInteractRequest
 */
export const ExploreItemInteractRequest = new ExploreItemInteractRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExploreInteractNO$Type extends MessageType<ExploreInteractNO> {
    constructor() {
        super("ExploreInteractNO", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "status", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "status2", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "step", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "posx", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "posy", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "dir", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ExploreInteractNO>): ExploreInteractNO {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExploreInteractNO>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExploreInteractNO): ExploreInteractNO {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* optional int32 type */ 2:
                    message.type = reader.int32();
                    break;
                case /* optional int32 status */ 3:
                    message.status = reader.int32();
                    break;
                case /* optional string status2 */ 4:
                    message.status2 = reader.string();
                    break;
                case /* optional int32 step */ 5:
                    message.step = reader.int32();
                    break;
                case /* optional int32 posx */ 6:
                    message.posx = reader.int32();
                    break;
                case /* optional int32 posy */ 7:
                    message.posy = reader.int32();
                    break;
                case /* optional int32 dir */ 8:
                    message.dir = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExploreInteractNO, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* optional int32 type = 2; */
        if (message.type !== undefined)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* optional int32 status = 3; */
        if (message.status !== undefined)
            writer.tag(3, WireType.Varint).int32(message.status);
        /* optional string status2 = 4; */
        if (message.status2 !== undefined)
            writer.tag(4, WireType.LengthDelimited).string(message.status2);
        /* optional int32 step = 5; */
        if (message.step !== undefined)
            writer.tag(5, WireType.Varint).int32(message.step);
        /* optional int32 posx = 6; */
        if (message.posx !== undefined)
            writer.tag(6, WireType.Varint).int32(message.posx);
        /* optional int32 posy = 7; */
        if (message.posy !== undefined)
            writer.tag(7, WireType.Varint).int32(message.posy);
        /* optional int32 dir = 8; */
        if (message.dir !== undefined)
            writer.tag(8, WireType.Varint).int32(message.dir);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExploreInteractNO
 */
export const ExploreInteractNO = new ExploreInteractNO$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeMapRequest$Type extends MessageType<ChangeMapRequest> {
    constructor() {
        super("ChangeMapRequest", [
            { no: 1, name: "mapId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "posx", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "posy", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChangeMapRequest>): ChangeMapRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChangeMapRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeMapRequest): ChangeMapRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 mapId */ 1:
                    message.mapId = reader.int32();
                    break;
                case /* optional int32 posx */ 2:
                    message.posx = reader.int32();
                    break;
                case /* optional int32 posy */ 3:
                    message.posy = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeMapRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 mapId = 1; */
        if (message.mapId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.mapId);
        /* optional int32 posx = 2; */
        if (message.posx !== undefined)
            writer.tag(2, WireType.Varint).int32(message.posx);
        /* optional int32 posy = 3; */
        if (message.posy !== undefined)
            writer.tag(3, WireType.Varint).int32(message.posy);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChangeMapRequest
 */
export const ChangeMapRequest = new ChangeMapRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExploreUseItemReply$Type extends MessageType<ExploreUseItemReply> {
    constructor() {
        super("ExploreUseItemReply", [
            { no: 1, name: "interacts", kind: "message", T: () => ExploreInteractNO },
            { no: 2, name: "deleteInteracts", kind: "message", T: () => ExploreInteractNO },
            { no: 3, name: "useItemUid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ExploreUseItemReply>): ExploreUseItemReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExploreUseItemReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExploreUseItemReply): ExploreUseItemReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ExploreInteractNO interacts */ 1:
                    message.interacts = ExploreInteractNO.internalBinaryRead(reader, reader.uint32(), options, message.interacts);
                    break;
                case /* ExploreInteractNO deleteInteracts */ 2:
                    message.deleteInteracts = ExploreInteractNO.internalBinaryRead(reader, reader.uint32(), options, message.deleteInteracts);
                    break;
                case /* optional int64 useItemUid */ 3:
                    message.useItemUid = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExploreUseItemReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ExploreInteractNO interacts = 1; */
        if (message.interacts)
            ExploreInteractNO.internalBinaryWrite(message.interacts, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* ExploreInteractNO deleteInteracts = 2; */
        if (message.deleteInteracts)
            ExploreInteractNO.internalBinaryWrite(message.deleteInteracts, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional int64 useItemUid = 3; */
        if (message.useItemUid !== undefined)
            writer.tag(3, WireType.Varint).int64(message.useItemUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExploreUseItemReply
 */
export const ExploreUseItemReply = new ExploreUseItemReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExploreItemNO$Type extends MessageType<ExploreItemNO> {
    constructor() {
        super("ExploreItemNO", [
            { no: 1, name: "uid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "itemId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "quantity", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "status", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ExploreItemNO>): ExploreItemNO {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExploreItemNO>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExploreItemNO): ExploreItemNO {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 uid */ 1:
                    message.uid = reader.int64().toBigInt();
                    break;
                case /* optional int32 itemId */ 2:
                    message.itemId = reader.int32();
                    break;
                case /* optional int32 quantity */ 3:
                    message.quantity = reader.int32();
                    break;
                case /* optional int32 status */ 4:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExploreItemNO, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 uid = 1; */
        if (message.uid !== undefined)
            writer.tag(1, WireType.Varint).int64(message.uid);
        /* optional int32 itemId = 2; */
        if (message.itemId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.itemId);
        /* optional int32 quantity = 3; */
        if (message.quantity !== undefined)
            writer.tag(3, WireType.Varint).int32(message.quantity);
        /* optional int32 status = 4; */
        if (message.status !== undefined)
            writer.tag(4, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExploreItemNO
 */
export const ExploreItemNO = new ExploreItemNO$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExploreAreaSightNO$Type extends MessageType<ExploreAreaSightNO> {
    constructor() {
        super("ExploreAreaSightNO", [
            { no: 1, name: "areaId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "sight", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "visible", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ExploreAreaSightNO>): ExploreAreaSightNO {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExploreAreaSightNO>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExploreAreaSightNO): ExploreAreaSightNO {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 areaId */ 1:
                    message.areaId = reader.int32();
                    break;
                case /* optional bytes sight */ 2:
                    message.sight = reader.bytes();
                    break;
                case /* optional bool visible */ 3:
                    message.visible = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExploreAreaSightNO, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 areaId = 1; */
        if (message.areaId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.areaId);
        /* optional bytes sight = 2; */
        if (message.sight !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.sight);
        /* optional bool visible = 3; */
        if (message.visible !== undefined)
            writer.tag(3, WireType.Varint).bool(message.visible);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExploreAreaSightNO
 */
export const ExploreAreaSightNO = new ExploreAreaSightNO$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeMapReply$Type extends MessageType<ChangeMapReply> {
    constructor() {
        super("ChangeMapReply", [
            { no: 1, name: "mapId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "posx", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "posy", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "exploreInfo", kind: "message", T: () => ExploreInfoNO }
        ]);
    }
    create(value?: PartialMessage<ChangeMapReply>): ChangeMapReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChangeMapReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeMapReply): ChangeMapReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 mapId */ 1:
                    message.mapId = reader.int32();
                    break;
                case /* optional int32 posx */ 2:
                    message.posx = reader.int32();
                    break;
                case /* optional int32 posy */ 3:
                    message.posy = reader.int32();
                    break;
                case /* optional ExploreInfoNO exploreInfo */ 4:
                    message.exploreInfo = ExploreInfoNO.internalBinaryRead(reader, reader.uint32(), options, message.exploreInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeMapReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 mapId = 1; */
        if (message.mapId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.mapId);
        /* optional int32 posx = 2; */
        if (message.posx !== undefined)
            writer.tag(2, WireType.Varint).int32(message.posx);
        /* optional int32 posy = 3; */
        if (message.posy !== undefined)
            writer.tag(3, WireType.Varint).int32(message.posy);
        /* optional ExploreInfoNO exploreInfo = 4; */
        if (message.exploreInfo)
            ExploreInfoNO.internalBinaryWrite(message.exploreInfo, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChangeMapReply
 */
export const ChangeMapReply = new ChangeMapReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExploreInteractSetStatus2Request$Type extends MessageType<ExploreInteractSetStatus2Request> {
    constructor() {
        super("ExploreInteractSetStatus2Request", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "status2", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ExploreInteractSetStatus2Request>): ExploreInteractSetStatus2Request {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExploreInteractSetStatus2Request>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExploreInteractSetStatus2Request): ExploreInteractSetStatus2Request {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional int32 id */ 2:
                    message.id = reader.int32();
                    break;
                case /* optional string status2 */ 3:
                    message.status2 = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExploreInteractSetStatus2Request, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional int32 id = 2; */
        if (message.id !== undefined)
            writer.tag(2, WireType.Varint).int32(message.id);
        /* optional string status2 = 3; */
        if (message.status2 !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.status2);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExploreInteractSetStatus2Request
 */
export const ExploreInteractSetStatus2Request = new ExploreInteractSetStatus2Request$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExploreMoveRequest$Type extends MessageType<ExploreMoveRequest> {
    constructor() {
        super("ExploreMoveRequest", [
            { no: 1, name: "posx", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "posy", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "sightChange", kind: "message", T: () => ExploreSeatNO },
            { no: 4, name: "interactId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ExploreMoveRequest>): ExploreMoveRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExploreMoveRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExploreMoveRequest): ExploreMoveRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 posx */ 1:
                    message.posx = reader.int32();
                    break;
                case /* optional int32 posy */ 2:
                    message.posy = reader.int32();
                    break;
                case /* ExploreSeatNO sightChange */ 3:
                    message.sightChange = ExploreSeatNO.internalBinaryRead(reader, reader.uint32(), options, message.sightChange);
                    break;
                case /* optional int32 interactId */ 4:
                    message.interactId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExploreMoveRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 posx = 1; */
        if (message.posx !== undefined)
            writer.tag(1, WireType.Varint).int32(message.posx);
        /* optional int32 posy = 2; */
        if (message.posy !== undefined)
            writer.tag(2, WireType.Varint).int32(message.posy);
        /* ExploreSeatNO sightChange = 3; */
        if (message.sightChange)
            ExploreSeatNO.internalBinaryWrite(message.sightChange, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 interactId = 4; */
        if (message.interactId !== undefined)
            writer.tag(4, WireType.Varint).int32(message.interactId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExploreMoveRequest
 */
export const ExploreMoveRequest = new ExploreMoveRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExploreSetAreaVisibleRequest$Type extends MessageType<ExploreSetAreaVisibleRequest> {
    constructor() {
        super("ExploreSetAreaVisibleRequest", [
            { no: 1, name: "areaId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "visible", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<ExploreSetAreaVisibleRequest>): ExploreSetAreaVisibleRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExploreSetAreaVisibleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExploreSetAreaVisibleRequest): ExploreSetAreaVisibleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 areaId */ 1:
                    message.areaId = reader.int32();
                    break;
                case /* optional bool visible */ 2:
                    message.visible = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExploreSetAreaVisibleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 areaId = 1; */
        if (message.areaId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.areaId);
        /* optional bool visible = 2; */
        if (message.visible !== undefined)
            writer.tag(2, WireType.Varint).bool(message.visible);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExploreSetAreaVisibleRequest
 */
export const ExploreSetAreaVisibleRequest = new ExploreSetAreaVisibleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExploreInfoNO$Type extends MessageType<ExploreInfoNO> {
    constructor() {
        super("ExploreInfoNO", [
            { no: 1, name: "exploreMap", kind: "message", T: () => ExploreMapNO },
            { no: 2, name: "heroGroupSnapshot", kind: "message", T: () => HeroGroupInfo },
            { no: 3, name: "exploreItems", kind: "message", T: () => ExploreItemNO },
            { no: 4, name: "useItemUid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ExploreInfoNO>): ExploreInfoNO {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExploreInfoNO>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExploreInfoNO): ExploreInfoNO {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional ExploreMapNO exploreMap */ 1:
                    message.exploreMap = ExploreMapNO.internalBinaryRead(reader, reader.uint32(), options, message.exploreMap);
                    break;
                case /* optional HeroGroupInfo heroGroupSnapshot */ 2:
                    message.heroGroupSnapshot = HeroGroupInfo.internalBinaryRead(reader, reader.uint32(), options, message.heroGroupSnapshot);
                    break;
                case /* ExploreItemNO exploreItems */ 3:
                    message.exploreItems = ExploreItemNO.internalBinaryRead(reader, reader.uint32(), options, message.exploreItems);
                    break;
                case /* optional int64 useItemUid */ 4:
                    message.useItemUid = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExploreInfoNO, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional ExploreMapNO exploreMap = 1; */
        if (message.exploreMap)
            ExploreMapNO.internalBinaryWrite(message.exploreMap, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional HeroGroupInfo heroGroupSnapshot = 2; */
        if (message.heroGroupSnapshot)
            HeroGroupInfo.internalBinaryWrite(message.heroGroupSnapshot, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* ExploreItemNO exploreItems = 3; */
        if (message.exploreItems)
            ExploreItemNO.internalBinaryWrite(message.exploreItems, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional int64 useItemUid = 4; */
        if (message.useItemUid !== undefined)
            writer.tag(4, WireType.Varint).int64(message.useItemUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExploreInfoNO
 */
export const ExploreInfoNO = new ExploreInfoNO$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EnterChapterReply$Type extends MessageType<EnterChapterReply> {
    constructor() {
        super("EnterChapterReply", [
            { no: 1, name: "chapterId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "exploreInfo", kind: "message", T: () => ExploreInfoNO }
        ]);
    }
    create(value?: PartialMessage<EnterChapterReply>): EnterChapterReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EnterChapterReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EnterChapterReply): EnterChapterReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterId */ 1:
                    message.chapterId = reader.int32();
                    break;
                case /* optional ExploreInfoNO exploreInfo */ 2:
                    message.exploreInfo = ExploreInfoNO.internalBinaryRead(reader, reader.uint32(), options, message.exploreInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EnterChapterReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterId = 1; */
        if (message.chapterId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterId);
        /* optional ExploreInfoNO exploreInfo = 2; */
        if (message.exploreInfo)
            ExploreInfoNO.internalBinaryWrite(message.exploreInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EnterChapterReply
 */
export const EnterChapterReply = new EnterChapterReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExploreInteractSetStepReply$Type extends MessageType<ExploreInteractSetStepReply> {
    constructor() {
        super("ExploreInteractSetStepReply", [
            { no: 1, name: "mapId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "step", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ExploreInteractSetStepReply>): ExploreInteractSetStepReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExploreInteractSetStepReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExploreInteractSetStepReply): ExploreInteractSetStepReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 mapId */ 1:
                    message.mapId = reader.int32();
                    break;
                case /* optional int32 type */ 2:
                    message.type = reader.int32();
                    break;
                case /* optional int32 id */ 3:
                    message.id = reader.int32();
                    break;
                case /* optional int32 step */ 4:
                    message.step = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExploreInteractSetStepReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 mapId = 1; */
        if (message.mapId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.mapId);
        /* optional int32 type = 2; */
        if (message.type !== undefined)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* optional int32 id = 3; */
        if (message.id !== undefined)
            writer.tag(3, WireType.Varint).int32(message.id);
        /* optional int32 step = 4; */
        if (message.step !== undefined)
            writer.tag(4, WireType.Varint).int32(message.step);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExploreInteractSetStepReply
 */
export const ExploreInteractSetStepReply = new ExploreInteractSetStepReply$Type();
