// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "summon_module.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { MaterialData } from "./material_module";
/**
 * @generated from protobuf message GetSummonInfoReply
 */
export interface GetSummonInfoReply {
    /**
     * @generated from protobuf field: optional bool freeEquipSummon = 1;
     */
    freeEquipSummon?: boolean;
    /**
     * @generated from protobuf field: optional bool isShowNewSummon = 2;
     */
    isShowNewSummon?: boolean;
    /**
     * @generated from protobuf field: optional int32 newSummonCount = 3;
     */
    newSummonCount?: number;
    /**
     * @generated from protobuf field: SummonPoolInfo poolInfos = 4;
     */
    poolInfos?: SummonPoolInfo;
    /**
     * @generated from protobuf field: optional int32 totalSummonCount = 5;
     */
    totalSummonCount?: number;
}
/**
 * @generated from protobuf message SummonQueryTokenReply
 */
export interface SummonQueryTokenReply {
    /**
     * @generated from protobuf field: optional string token = 1;
     */
    token?: string;
}
/**
 * @generated from protobuf message SummonPoolInfo
 */
export interface SummonPoolInfo {
    /**
     * @generated from protobuf field: optional int32 poolId = 1;
     */
    poolId?: number;
    /**
     * @generated from protobuf field: optional int32 onlineTime = 2;
     */
    onlineTime?: number;
    /**
     * @generated from protobuf field: optional int32 offlineTime = 3;
     */
    offlineTime?: number;
}
/**
 * @generated from protobuf message SummonResult
 */
export interface SummonResult {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
    /**
     * @generated from protobuf field: optional bool isNew = 2;
     */
    isNew?: boolean;
    /**
     * @generated from protobuf field: optional int32 duplicateCount = 3;
     */
    duplicateCount?: number;
    /**
     * @generated from protobuf field: optional int32 equipId = 4;
     */
    equipId?: number;
    /**
     * @generated from protobuf field: MaterialData returnMaterials = 5;
     */
    returnMaterials?: MaterialData;
}
/**
 * @generated from protobuf message SummonRequest
 */
export interface SummonRequest {
    /**
     * @generated from protobuf field: optional int32 poolId = 1;
     */
    poolId?: number;
    /**
     * @generated from protobuf field: optional int32 guideId = 2;
     */
    guideId?: number;
    /**
     * @generated from protobuf field: optional int32 stepId = 3;
     */
    stepId?: number;
    /**
     * @generated from protobuf field: optional int32 count = 4;
     */
    count?: number;
}
/**
 * @generated from protobuf message SummonQueryTokenRequest
 */
export interface SummonQueryTokenRequest {
}
/**
 * @generated from protobuf message SummonReply
 */
export interface SummonReply {
    /**
     * @generated from protobuf field: SummonResult summonResult = 1;
     */
    summonResult?: SummonResult;
}
/**
 * @generated from protobuf message GetSummonInfoRequest
 */
export interface GetSummonInfoRequest {
}
// @generated message type with reflection information, may provide speed optimized methods
class GetSummonInfoReply$Type extends MessageType<GetSummonInfoReply> {
    constructor() {
        super("GetSummonInfoReply", [
            { no: 1, name: "freeEquipSummon", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "isShowNewSummon", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "newSummonCount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "poolInfos", kind: "message", T: () => SummonPoolInfo },
            { no: 5, name: "totalSummonCount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetSummonInfoReply>): GetSummonInfoReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetSummonInfoReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSummonInfoReply): GetSummonInfoReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool freeEquipSummon */ 1:
                    message.freeEquipSummon = reader.bool();
                    break;
                case /* optional bool isShowNewSummon */ 2:
                    message.isShowNewSummon = reader.bool();
                    break;
                case /* optional int32 newSummonCount */ 3:
                    message.newSummonCount = reader.int32();
                    break;
                case /* SummonPoolInfo poolInfos */ 4:
                    message.poolInfos = SummonPoolInfo.internalBinaryRead(reader, reader.uint32(), options, message.poolInfos);
                    break;
                case /* optional int32 totalSummonCount */ 5:
                    message.totalSummonCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSummonInfoReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool freeEquipSummon = 1; */
        if (message.freeEquipSummon !== undefined)
            writer.tag(1, WireType.Varint).bool(message.freeEquipSummon);
        /* optional bool isShowNewSummon = 2; */
        if (message.isShowNewSummon !== undefined)
            writer.tag(2, WireType.Varint).bool(message.isShowNewSummon);
        /* optional int32 newSummonCount = 3; */
        if (message.newSummonCount !== undefined)
            writer.tag(3, WireType.Varint).int32(message.newSummonCount);
        /* SummonPoolInfo poolInfos = 4; */
        if (message.poolInfos)
            SummonPoolInfo.internalBinaryWrite(message.poolInfos, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 totalSummonCount = 5; */
        if (message.totalSummonCount !== undefined)
            writer.tag(5, WireType.Varint).int32(message.totalSummonCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetSummonInfoReply
 */
export const GetSummonInfoReply = new GetSummonInfoReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SummonQueryTokenReply$Type extends MessageType<SummonQueryTokenReply> {
    constructor() {
        super("SummonQueryTokenReply", [
            { no: 1, name: "token", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SummonQueryTokenReply>): SummonQueryTokenReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SummonQueryTokenReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SummonQueryTokenReply): SummonQueryTokenReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string token */ 1:
                    message.token = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SummonQueryTokenReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string token = 1; */
        if (message.token !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.token);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SummonQueryTokenReply
 */
export const SummonQueryTokenReply = new SummonQueryTokenReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SummonPoolInfo$Type extends MessageType<SummonPoolInfo> {
    constructor() {
        super("SummonPoolInfo", [
            { no: 1, name: "poolId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "onlineTime", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "offlineTime", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SummonPoolInfo>): SummonPoolInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SummonPoolInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SummonPoolInfo): SummonPoolInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 poolId */ 1:
                    message.poolId = reader.int32();
                    break;
                case /* optional int32 onlineTime */ 2:
                    message.onlineTime = reader.int32();
                    break;
                case /* optional int32 offlineTime */ 3:
                    message.offlineTime = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SummonPoolInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 poolId = 1; */
        if (message.poolId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.poolId);
        /* optional int32 onlineTime = 2; */
        if (message.onlineTime !== undefined)
            writer.tag(2, WireType.Varint).int32(message.onlineTime);
        /* optional int32 offlineTime = 3; */
        if (message.offlineTime !== undefined)
            writer.tag(3, WireType.Varint).int32(message.offlineTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SummonPoolInfo
 */
export const SummonPoolInfo = new SummonPoolInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SummonResult$Type extends MessageType<SummonResult> {
    constructor() {
        super("SummonResult", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "isNew", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "duplicateCount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "equipId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "returnMaterials", kind: "message", T: () => MaterialData }
        ]);
    }
    create(value?: PartialMessage<SummonResult>): SummonResult {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SummonResult>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SummonResult): SummonResult {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                case /* optional bool isNew */ 2:
                    message.isNew = reader.bool();
                    break;
                case /* optional int32 duplicateCount */ 3:
                    message.duplicateCount = reader.int32();
                    break;
                case /* optional int32 equipId */ 4:
                    message.equipId = reader.int32();
                    break;
                case /* MaterialData returnMaterials */ 5:
                    message.returnMaterials = MaterialData.internalBinaryRead(reader, reader.uint32(), options, message.returnMaterials);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SummonResult, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        /* optional bool isNew = 2; */
        if (message.isNew !== undefined)
            writer.tag(2, WireType.Varint).bool(message.isNew);
        /* optional int32 duplicateCount = 3; */
        if (message.duplicateCount !== undefined)
            writer.tag(3, WireType.Varint).int32(message.duplicateCount);
        /* optional int32 equipId = 4; */
        if (message.equipId !== undefined)
            writer.tag(4, WireType.Varint).int32(message.equipId);
        /* MaterialData returnMaterials = 5; */
        if (message.returnMaterials)
            MaterialData.internalBinaryWrite(message.returnMaterials, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SummonResult
 */
export const SummonResult = new SummonResult$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SummonRequest$Type extends MessageType<SummonRequest> {
    constructor() {
        super("SummonRequest", [
            { no: 1, name: "poolId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "guideId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "stepId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SummonRequest>): SummonRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SummonRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SummonRequest): SummonRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 poolId */ 1:
                    message.poolId = reader.int32();
                    break;
                case /* optional int32 guideId */ 2:
                    message.guideId = reader.int32();
                    break;
                case /* optional int32 stepId */ 3:
                    message.stepId = reader.int32();
                    break;
                case /* optional int32 count */ 4:
                    message.count = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SummonRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 poolId = 1; */
        if (message.poolId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.poolId);
        /* optional int32 guideId = 2; */
        if (message.guideId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.guideId);
        /* optional int32 stepId = 3; */
        if (message.stepId !== undefined)
            writer.tag(3, WireType.Varint).int32(message.stepId);
        /* optional int32 count = 4; */
        if (message.count !== undefined)
            writer.tag(4, WireType.Varint).int32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SummonRequest
 */
export const SummonRequest = new SummonRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SummonQueryTokenRequest$Type extends MessageType<SummonQueryTokenRequest> {
    constructor() {
        super("SummonQueryTokenRequest", []);
    }
    create(value?: PartialMessage<SummonQueryTokenRequest>): SummonQueryTokenRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SummonQueryTokenRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SummonQueryTokenRequest): SummonQueryTokenRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: SummonQueryTokenRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SummonQueryTokenRequest
 */
export const SummonQueryTokenRequest = new SummonQueryTokenRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SummonReply$Type extends MessageType<SummonReply> {
    constructor() {
        super("SummonReply", [
            { no: 1, name: "summonResult", kind: "message", T: () => SummonResult }
        ]);
    }
    create(value?: PartialMessage<SummonReply>): SummonReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SummonReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SummonReply): SummonReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* SummonResult summonResult */ 1:
                    message.summonResult = SummonResult.internalBinaryRead(reader, reader.uint32(), options, message.summonResult);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SummonReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* SummonResult summonResult = 1; */
        if (message.summonResult)
            SummonResult.internalBinaryWrite(message.summonResult, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SummonReply
 */
export const SummonReply = new SummonReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSummonInfoRequest$Type extends MessageType<GetSummonInfoRequest> {
    constructor() {
        super("GetSummonInfoRequest", []);
    }
    create(value?: PartialMessage<GetSummonInfoRequest>): GetSummonInfoRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetSummonInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSummonInfoRequest): GetSummonInfoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetSummonInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetSummonInfoRequest
 */
export const GetSummonInfoRequest = new GetSummonInfoRequest$Type();
