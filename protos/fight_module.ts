// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "fight_module.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { FightRoundRecord } from "./fight_def";
import { FightGroupRecord } from "./fight_def";
import { CardInfo } from "./fight_def";
import { BeginRoundOper } from "./fight_def";
import { FightReason } from "./fight_def";
import { FightRound } from "./fight_def";
import { Fight } from "./fight_def";
import { FightGroup } from "./fight_def";
import { FightRecord } from "./fight_def";
/**
 * @generated from protobuf message EndFightPush
 */
export interface EndFightPush {
    /**
     * @generated from protobuf field: optional FightRecord record = 1;
     */
    record?: FightRecord;
    /**
     * @generated from protobuf field: optional FightGroup fightGroupA = 2;
     */
    fightGroupA?: FightGroup;
    /**
     * @generated from protobuf field: optional bool isRecord = 3;
     */
    isRecord?: boolean;
}
/**
 * @generated from protobuf message TestFightRequest
 */
export interface TestFightRequest {
    /**
     * @generated from protobuf field: repeated int32 groupIds = 1;
     */
    groupIds: number[];
    /**
     * @generated from protobuf field: optional FightGroup fightGroup = 2;
     */
    fightGroup?: FightGroup;
    /**
     * @generated from protobuf field: optional int32 FightType = 3 [json_name = "FightType"];
     */
    fightType?: number;
}
/**
 * @generated from protobuf message ReconnectFightReply
 */
export interface ReconnectFightReply {
    /**
     * @generated from protobuf field: optional Fight fight = 1;
     */
    fight?: Fight;
    /**
     * @generated from protobuf field: optional FightRound lastRound = 2;
     */
    lastRound?: FightRound;
    /**
     * @generated from protobuf field: optional FightReason fightReason = 3;
     */
    fightReason?: FightReason;
    /**
     * @generated from protobuf field: optional FightGroup fightGroup = 4;
     */
    fightGroup?: FightGroup;
}
/**
 * @generated from protobuf message UseClothSkillReply
 */
export interface UseClothSkillReply {
    /**
     * @generated from protobuf field: optional FightRound round = 1;
     */
    round?: FightRound;
}
/**
 * @generated from protobuf message EndRoundReply
 */
export interface EndRoundReply {
}
/**
 * @generated from protobuf message FightRoundOperRecord
 */
export interface FightRoundOperRecord {
    /**
     * @generated from protobuf field: repeated UseClothSkillOperRecord clothSkillOpers = 1;
     */
    clothSkillOpers: UseClothSkillOperRecord[];
    /**
     * @generated from protobuf field: repeated BeginRoundOper opers = 2;
     */
    opers: BeginRoundOper[];
}
/**
 * @generated from protobuf message ReconnectFightRequest
 */
export interface ReconnectFightRequest {
}
/**
 * @generated from protobuf message AutoRoundReply
 */
export interface AutoRoundReply {
    /**
     * @generated from protobuf field: repeated BeginRoundOper opers = 1;
     */
    opers: BeginRoundOper[];
}
/**
 * @generated from protobuf message EndFightRequest
 */
export interface EndFightRequest {
    /**
     * @generated from protobuf field: optional bool isAbort = 1;
     */
    isAbort?: boolean;
}
/**
 * @generated from protobuf message RedealCardInfoPush
 */
export interface RedealCardInfoPush {
    /**
     * @generated from protobuf field: repeated CardInfo cardGroup = 1;
     */
    cardGroup: CardInfo[];
    /**
     * @generated from protobuf field: repeated CardInfo dealCardGroup = 2;
     */
    dealCardGroup: CardInfo[];
}
/**
 * @generated from protobuf message ChangeSubHeroRequest
 */
export interface ChangeSubHeroRequest {
    /**
     * @generated from protobuf field: int64 subHeroId = 1;
     */
    subHeroId: bigint;
    /**
     * @generated from protobuf field: int64 changeHeroId = 2;
     */
    changeHeroId: bigint;
}
/**
 * @generated from protobuf message EndRoundRequest
 */
export interface EndRoundRequest {
}
/**
 * @generated from protobuf message ResetRoundRequest
 */
export interface ResetRoundRequest {
}
/**
 * @generated from protobuf message GetFightRecordGroupReply
 */
export interface GetFightRecordGroupReply {
    /**
     * @generated from protobuf field: optional FightGroupRecord fightGroup = 1;
     */
    fightGroup?: FightGroupRecord;
}
/**
 * @generated from protobuf message TestFightReply
 */
export interface TestFightReply {
    /**
     * @generated from protobuf field: optional Fight fight = 1;
     */
    fight?: Fight;
    /**
     * @generated from protobuf field: optional FightRound round = 2;
     */
    round?: FightRound;
}
/**
 * @generated from protobuf message TestFightIdReply
 */
export interface TestFightIdReply {
    /**
     * @generated from protobuf field: optional Fight fight = 1;
     */
    fight?: Fight;
    /**
     * @generated from protobuf field: optional FightRound round = 2;
     */
    round?: FightRound;
}
/**
 * @generated from protobuf message BeginRoundRequest
 */
export interface BeginRoundRequest {
    /**
     * @generated from protobuf field: repeated BeginRoundOper opers = 1;
     */
    opers: BeginRoundOper[];
    /**
     * @generated from protobuf field: optional bool autoOper = 2;
     */
    autoOper?: boolean;
}
/**
 * @generated from protobuf message FightWavePush
 */
export interface FightWavePush {
    /**
     * @generated from protobuf field: optional Fight fight = 1;
     */
    fight?: Fight;
}
/**
 * @generated from protobuf message MoveCardReply
 */
export interface MoveCardReply {
}
/**
 * @generated from protobuf message BeginFightRequest
 */
export interface BeginFightRequest {
    /**
     * @generated from protobuf field: optional FightGroup fightGroup = 1;
     */
    fightGroup?: FightGroup;
}
/**
 * @generated from protobuf message MoveCardRequest
 */
export interface MoveCardRequest {
    /**
     * @generated from protobuf field: optional int32 fromPosition = 1;
     */
    fromPosition?: number;
    /**
     * @generated from protobuf field: optional int32 toPosition = 2;
     */
    toPosition?: number;
}
/**
 * @generated from protobuf message GetFightOperRequest
 */
export interface GetFightOperRequest {
}
/**
 * @generated from protobuf message BeginRoundReply
 */
export interface BeginRoundReply {
    /**
     * @generated from protobuf field: optional FightRound round = 1;
     */
    round?: FightRound;
}
/**
 * @generated from protobuf message TeamInfoPush
 */
export interface TeamInfoPush {
    /**
     * @generated from protobuf field: optional Fight fight = 1;
     */
    fight?: Fight;
    /**
     * @generated from protobuf field: optional bool isGm = 2;
     */
    isGm?: boolean;
}
/**
 * @generated from protobuf message FightRoundRecordAll
 */
export interface FightRoundRecordAll {
    /**
     * @generated from protobuf field: optional Fight fight = 1;
     */
    fight?: Fight;
    /**
     * @generated from protobuf field: optional FightRound round = 2;
     */
    round?: FightRound;
    /**
     * @generated from protobuf field: repeated FightRoundRecord records = 3;
     */
    records: FightRoundRecord[];
    /**
     * @generated from protobuf field: optional FightRecord fightRecord = 4;
     */
    fightRecord?: FightRecord;
    /**
     * @generated from protobuf field: optional int32 result = 5;
     */
    result?: number;
    /**
     * @generated from protobuf field: optional int32 resultCause = 6;
     */
    resultCause?: number;
    /**
     * @generated from protobuf field: optional int32 totalRound = 7;
     */
    totalRound?: number;
    /**
     * @generated from protobuf field: optional int32 killTotal = 8;
     */
    killTotal?: number;
    /**
     * @generated from protobuf field: optional CardInfoPush pushInfo = 9;
     */
    pushInfo?: CardInfoPush;
    /**
     * @generated from protobuf field: repeated Fight wavePushFight = 10;
     */
    wavePushFight: Fight[];
    /**
     * @generated from protobuf field: repeated RedealCardInfoPush redealInfos = 12;
     */
    redealInfos: RedealCardInfoPush[];
}
/**
 * @generated from protobuf message GetFightRecordGroupRequest
 */
export interface GetFightRecordGroupRequest {
    /**
     * @generated from protobuf field: optional int32 episodeId = 1;
     */
    episodeId?: number;
}
/**
 * @generated from protobuf message CardInfoPush
 */
export interface CardInfoPush {
    /**
     * @generated from protobuf field: repeated CardInfo cardGroup = 1;
     */
    cardGroup: CardInfo[];
    /**
     * @generated from protobuf field: optional int32 actPoint = 2;
     */
    actPoint?: number;
    /**
     * @generated from protobuf field: optional int32 moveNum = 3;
     */
    moveNum?: number;
    /**
     * @generated from protobuf field: repeated CardInfo beforeCards = 4;
     */
    beforeCards: CardInfo[];
    /**
     * @generated from protobuf field: repeated CardInfo dealCardGroup = 5;
     */
    dealCardGroup: CardInfo[];
    /**
     * @generated from protobuf field: optional int32 extraMoveAct = 6;
     */
    extraMoveAct?: number;
}
/**
 * @generated from protobuf message TestFightIdRequest
 */
export interface TestFightIdRequest {
    /**
     * @generated from protobuf field: optional int32 fightId = 1;
     */
    fightId?: number;
    /**
     * @generated from protobuf field: optional FightGroup fightGroup = 2;
     */
    fightGroup?: FightGroup;
}
/**
 * @generated from protobuf message UseClothSkillRequest
 */
export interface UseClothSkillRequest {
    /**
     * @generated from protobuf field: optional int32 skillId = 1;
     */
    skillId?: number;
    /**
     * @generated from protobuf field: optional int64 fromId = 2;
     */
    fromId?: bigint;
    /**
     * @generated from protobuf field: optional int64 toId = 3;
     */
    toId?: bigint;
}
/**
 * @generated from protobuf message AutoRoundRequest
 */
export interface AutoRoundRequest {
    /**
     * @generated from protobuf field: repeated BeginRoundOper opers = 1;
     */
    opers: BeginRoundOper[];
}
/**
 * @generated from protobuf message GetFightOperReply
 */
export interface GetFightOperReply {
    /**
     * @generated from protobuf field: repeated FightRoundOperRecord operRecords = 1;
     */
    operRecords: FightRoundOperRecord[];
}
/**
 * @generated from protobuf message ResetRoundReply
 */
export interface ResetRoundReply {
    /**
     * @generated from protobuf field: optional Fight fight = 1;
     */
    fight?: Fight;
    /**
     * @generated from protobuf field: optional FightRound round = 2;
     */
    round?: FightRound;
    /**
     * @generated from protobuf field: repeated CardInfo cards = 3;
     */
    cards: CardInfo[];
}
/**
 * @generated from protobuf message BeginFightReply
 */
export interface BeginFightReply {
    /**
     * @generated from protobuf field: optional Fight fight = 1;
     */
    fight?: Fight;
    /**
     * @generated from protobuf field: optional FightRound round = 2;
     */
    round?: FightRound;
}
/**
 * @generated from protobuf message EndFightReply
 */
export interface EndFightReply {
}
/**
 * @generated from protobuf message UseClothSkillOperRecord
 */
export interface UseClothSkillOperRecord {
    /**
     * @generated from protobuf field: optional int32 skillId = 1;
     */
    skillId?: number;
    /**
     * @generated from protobuf field: optional int64 fromId = 2;
     */
    fromId?: bigint;
    /**
     * @generated from protobuf field: optional int64 toId = 3;
     */
    toId?: bigint;
}
/**
 * @generated from protobuf message ChangeSubHeroReply
 */
export interface ChangeSubHeroReply {
}
// @generated message type with reflection information, may provide speed optimized methods
class EndFightPush$Type extends MessageType<EndFightPush> {
    constructor() {
        super("EndFightPush", [
            { no: 1, name: "record", kind: "message", T: () => FightRecord },
            { no: 2, name: "fightGroupA", kind: "message", T: () => FightGroup },
            { no: 3, name: "isRecord", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EndFightPush>): EndFightPush {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EndFightPush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndFightPush): EndFightPush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional FightRecord record */ 1:
                    message.record = FightRecord.internalBinaryRead(reader, reader.uint32(), options, message.record);
                    break;
                case /* optional FightGroup fightGroupA */ 2:
                    message.fightGroupA = FightGroup.internalBinaryRead(reader, reader.uint32(), options, message.fightGroupA);
                    break;
                case /* optional bool isRecord */ 3:
                    message.isRecord = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EndFightPush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional FightRecord record = 1; */
        if (message.record)
            FightRecord.internalBinaryWrite(message.record, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional FightGroup fightGroupA = 2; */
        if (message.fightGroupA)
            FightGroup.internalBinaryWrite(message.fightGroupA, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional bool isRecord = 3; */
        if (message.isRecord !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isRecord);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EndFightPush
 */
export const EndFightPush = new EndFightPush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestFightRequest$Type extends MessageType<TestFightRequest> {
    constructor() {
        super("TestFightRequest", [
            { no: 1, name: "groupIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "fightGroup", kind: "message", T: () => FightGroup },
            { no: 3, name: "FightType", kind: "scalar", jsonName: "FightType", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TestFightRequest>): TestFightRequest {
        const message = { groupIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TestFightRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestFightRequest): TestFightRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 groupIds */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.groupIds.push(reader.int32());
                    else
                        message.groupIds.push(reader.int32());
                    break;
                case /* optional FightGroup fightGroup */ 2:
                    message.fightGroup = FightGroup.internalBinaryRead(reader, reader.uint32(), options, message.fightGroup);
                    break;
                case /* optional int32 FightType = 3 [json_name = "FightType"];*/ 3:
                    message.fightType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestFightRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 groupIds = 1; */
        for (let i = 0; i < message.groupIds.length; i++)
            writer.tag(1, WireType.Varint).int32(message.groupIds[i]);
        /* optional FightGroup fightGroup = 2; */
        if (message.fightGroup)
            FightGroup.internalBinaryWrite(message.fightGroup, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 FightType = 3 [json_name = "FightType"]; */
        if (message.fightType !== undefined)
            writer.tag(3, WireType.Varint).int32(message.fightType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TestFightRequest
 */
export const TestFightRequest = new TestFightRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReconnectFightReply$Type extends MessageType<ReconnectFightReply> {
    constructor() {
        super("ReconnectFightReply", [
            { no: 1, name: "fight", kind: "message", T: () => Fight },
            { no: 2, name: "lastRound", kind: "message", T: () => FightRound },
            { no: 3, name: "fightReason", kind: "message", T: () => FightReason },
            { no: 4, name: "fightGroup", kind: "message", T: () => FightGroup }
        ]);
    }
    create(value?: PartialMessage<ReconnectFightReply>): ReconnectFightReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReconnectFightReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReconnectFightReply): ReconnectFightReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional Fight fight */ 1:
                    message.fight = Fight.internalBinaryRead(reader, reader.uint32(), options, message.fight);
                    break;
                case /* optional FightRound lastRound */ 2:
                    message.lastRound = FightRound.internalBinaryRead(reader, reader.uint32(), options, message.lastRound);
                    break;
                case /* optional FightReason fightReason */ 3:
                    message.fightReason = FightReason.internalBinaryRead(reader, reader.uint32(), options, message.fightReason);
                    break;
                case /* optional FightGroup fightGroup */ 4:
                    message.fightGroup = FightGroup.internalBinaryRead(reader, reader.uint32(), options, message.fightGroup);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReconnectFightReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional Fight fight = 1; */
        if (message.fight)
            Fight.internalBinaryWrite(message.fight, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional FightRound lastRound = 2; */
        if (message.lastRound)
            FightRound.internalBinaryWrite(message.lastRound, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional FightReason fightReason = 3; */
        if (message.fightReason)
            FightReason.internalBinaryWrite(message.fightReason, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional FightGroup fightGroup = 4; */
        if (message.fightGroup)
            FightGroup.internalBinaryWrite(message.fightGroup, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ReconnectFightReply
 */
export const ReconnectFightReply = new ReconnectFightReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UseClothSkillReply$Type extends MessageType<UseClothSkillReply> {
    constructor() {
        super("UseClothSkillReply", [
            { no: 1, name: "round", kind: "message", T: () => FightRound }
        ]);
    }
    create(value?: PartialMessage<UseClothSkillReply>): UseClothSkillReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UseClothSkillReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UseClothSkillReply): UseClothSkillReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional FightRound round */ 1:
                    message.round = FightRound.internalBinaryRead(reader, reader.uint32(), options, message.round);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UseClothSkillReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional FightRound round = 1; */
        if (message.round)
            FightRound.internalBinaryWrite(message.round, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UseClothSkillReply
 */
export const UseClothSkillReply = new UseClothSkillReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndRoundReply$Type extends MessageType<EndRoundReply> {
    constructor() {
        super("EndRoundReply", []);
    }
    create(value?: PartialMessage<EndRoundReply>): EndRoundReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EndRoundReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndRoundReply): EndRoundReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: EndRoundReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EndRoundReply
 */
export const EndRoundReply = new EndRoundReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FightRoundOperRecord$Type extends MessageType<FightRoundOperRecord> {
    constructor() {
        super("FightRoundOperRecord", [
            { no: 1, name: "clothSkillOpers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UseClothSkillOperRecord },
            { no: 2, name: "opers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BeginRoundOper }
        ]);
    }
    create(value?: PartialMessage<FightRoundOperRecord>): FightRoundOperRecord {
        const message = { clothSkillOpers: [], opers: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FightRoundOperRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FightRoundOperRecord): FightRoundOperRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated UseClothSkillOperRecord clothSkillOpers */ 1:
                    message.clothSkillOpers.push(UseClothSkillOperRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated BeginRoundOper opers */ 2:
                    message.opers.push(BeginRoundOper.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FightRoundOperRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated UseClothSkillOperRecord clothSkillOpers = 1; */
        for (let i = 0; i < message.clothSkillOpers.length; i++)
            UseClothSkillOperRecord.internalBinaryWrite(message.clothSkillOpers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated BeginRoundOper opers = 2; */
        for (let i = 0; i < message.opers.length; i++)
            BeginRoundOper.internalBinaryWrite(message.opers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FightRoundOperRecord
 */
export const FightRoundOperRecord = new FightRoundOperRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReconnectFightRequest$Type extends MessageType<ReconnectFightRequest> {
    constructor() {
        super("ReconnectFightRequest", []);
    }
    create(value?: PartialMessage<ReconnectFightRequest>): ReconnectFightRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReconnectFightRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReconnectFightRequest): ReconnectFightRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ReconnectFightRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ReconnectFightRequest
 */
export const ReconnectFightRequest = new ReconnectFightRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AutoRoundReply$Type extends MessageType<AutoRoundReply> {
    constructor() {
        super("AutoRoundReply", [
            { no: 1, name: "opers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BeginRoundOper }
        ]);
    }
    create(value?: PartialMessage<AutoRoundReply>): AutoRoundReply {
        const message = { opers: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AutoRoundReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AutoRoundReply): AutoRoundReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated BeginRoundOper opers */ 1:
                    message.opers.push(BeginRoundOper.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AutoRoundReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated BeginRoundOper opers = 1; */
        for (let i = 0; i < message.opers.length; i++)
            BeginRoundOper.internalBinaryWrite(message.opers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AutoRoundReply
 */
export const AutoRoundReply = new AutoRoundReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndFightRequest$Type extends MessageType<EndFightRequest> {
    constructor() {
        super("EndFightRequest", [
            { no: 1, name: "isAbort", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EndFightRequest>): EndFightRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EndFightRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndFightRequest): EndFightRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool isAbort */ 1:
                    message.isAbort = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EndFightRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool isAbort = 1; */
        if (message.isAbort !== undefined)
            writer.tag(1, WireType.Varint).bool(message.isAbort);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EndFightRequest
 */
export const EndFightRequest = new EndFightRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RedealCardInfoPush$Type extends MessageType<RedealCardInfoPush> {
    constructor() {
        super("RedealCardInfoPush", [
            { no: 1, name: "cardGroup", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CardInfo },
            { no: 2, name: "dealCardGroup", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CardInfo }
        ]);
    }
    create(value?: PartialMessage<RedealCardInfoPush>): RedealCardInfoPush {
        const message = { cardGroup: [], dealCardGroup: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RedealCardInfoPush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RedealCardInfoPush): RedealCardInfoPush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CardInfo cardGroup */ 1:
                    message.cardGroup.push(CardInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CardInfo dealCardGroup */ 2:
                    message.dealCardGroup.push(CardInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RedealCardInfoPush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CardInfo cardGroup = 1; */
        for (let i = 0; i < message.cardGroup.length; i++)
            CardInfo.internalBinaryWrite(message.cardGroup[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated CardInfo dealCardGroup = 2; */
        for (let i = 0; i < message.dealCardGroup.length; i++)
            CardInfo.internalBinaryWrite(message.dealCardGroup[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RedealCardInfoPush
 */
export const RedealCardInfoPush = new RedealCardInfoPush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeSubHeroRequest$Type extends MessageType<ChangeSubHeroRequest> {
    constructor() {
        super("ChangeSubHeroRequest", [
            { no: 1, name: "subHeroId", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "changeHeroId", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ChangeSubHeroRequest>): ChangeSubHeroRequest {
        const message = { subHeroId: 0n, changeHeroId: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChangeSubHeroRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeSubHeroRequest): ChangeSubHeroRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 subHeroId */ 1:
                    message.subHeroId = reader.int64().toBigInt();
                    break;
                case /* int64 changeHeroId */ 2:
                    message.changeHeroId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChangeSubHeroRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 subHeroId = 1; */
        if (message.subHeroId !== 0n)
            writer.tag(1, WireType.Varint).int64(message.subHeroId);
        /* int64 changeHeroId = 2; */
        if (message.changeHeroId !== 0n)
            writer.tag(2, WireType.Varint).int64(message.changeHeroId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChangeSubHeroRequest
 */
export const ChangeSubHeroRequest = new ChangeSubHeroRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndRoundRequest$Type extends MessageType<EndRoundRequest> {
    constructor() {
        super("EndRoundRequest", []);
    }
    create(value?: PartialMessage<EndRoundRequest>): EndRoundRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EndRoundRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndRoundRequest): EndRoundRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: EndRoundRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EndRoundRequest
 */
export const EndRoundRequest = new EndRoundRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResetRoundRequest$Type extends MessageType<ResetRoundRequest> {
    constructor() {
        super("ResetRoundRequest", []);
    }
    create(value?: PartialMessage<ResetRoundRequest>): ResetRoundRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResetRoundRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResetRoundRequest): ResetRoundRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ResetRoundRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ResetRoundRequest
 */
export const ResetRoundRequest = new ResetRoundRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFightRecordGroupReply$Type extends MessageType<GetFightRecordGroupReply> {
    constructor() {
        super("GetFightRecordGroupReply", [
            { no: 1, name: "fightGroup", kind: "message", T: () => FightGroupRecord }
        ]);
    }
    create(value?: PartialMessage<GetFightRecordGroupReply>): GetFightRecordGroupReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetFightRecordGroupReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFightRecordGroupReply): GetFightRecordGroupReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional FightGroupRecord fightGroup */ 1:
                    message.fightGroup = FightGroupRecord.internalBinaryRead(reader, reader.uint32(), options, message.fightGroup);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFightRecordGroupReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional FightGroupRecord fightGroup = 1; */
        if (message.fightGroup)
            FightGroupRecord.internalBinaryWrite(message.fightGroup, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetFightRecordGroupReply
 */
export const GetFightRecordGroupReply = new GetFightRecordGroupReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestFightReply$Type extends MessageType<TestFightReply> {
    constructor() {
        super("TestFightReply", [
            { no: 1, name: "fight", kind: "message", T: () => Fight },
            { no: 2, name: "round", kind: "message", T: () => FightRound }
        ]);
    }
    create(value?: PartialMessage<TestFightReply>): TestFightReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TestFightReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestFightReply): TestFightReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional Fight fight */ 1:
                    message.fight = Fight.internalBinaryRead(reader, reader.uint32(), options, message.fight);
                    break;
                case /* optional FightRound round */ 2:
                    message.round = FightRound.internalBinaryRead(reader, reader.uint32(), options, message.round);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestFightReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional Fight fight = 1; */
        if (message.fight)
            Fight.internalBinaryWrite(message.fight, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional FightRound round = 2; */
        if (message.round)
            FightRound.internalBinaryWrite(message.round, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TestFightReply
 */
export const TestFightReply = new TestFightReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestFightIdReply$Type extends MessageType<TestFightIdReply> {
    constructor() {
        super("TestFightIdReply", [
            { no: 1, name: "fight", kind: "message", T: () => Fight },
            { no: 2, name: "round", kind: "message", T: () => FightRound }
        ]);
    }
    create(value?: PartialMessage<TestFightIdReply>): TestFightIdReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TestFightIdReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestFightIdReply): TestFightIdReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional Fight fight */ 1:
                    message.fight = Fight.internalBinaryRead(reader, reader.uint32(), options, message.fight);
                    break;
                case /* optional FightRound round */ 2:
                    message.round = FightRound.internalBinaryRead(reader, reader.uint32(), options, message.round);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestFightIdReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional Fight fight = 1; */
        if (message.fight)
            Fight.internalBinaryWrite(message.fight, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional FightRound round = 2; */
        if (message.round)
            FightRound.internalBinaryWrite(message.round, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TestFightIdReply
 */
export const TestFightIdReply = new TestFightIdReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BeginRoundRequest$Type extends MessageType<BeginRoundRequest> {
    constructor() {
        super("BeginRoundRequest", [
            { no: 1, name: "opers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BeginRoundOper },
            { no: 2, name: "autoOper", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<BeginRoundRequest>): BeginRoundRequest {
        const message = { opers: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BeginRoundRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BeginRoundRequest): BeginRoundRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated BeginRoundOper opers */ 1:
                    message.opers.push(BeginRoundOper.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool autoOper */ 2:
                    message.autoOper = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BeginRoundRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated BeginRoundOper opers = 1; */
        for (let i = 0; i < message.opers.length; i++)
            BeginRoundOper.internalBinaryWrite(message.opers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional bool autoOper = 2; */
        if (message.autoOper !== undefined)
            writer.tag(2, WireType.Varint).bool(message.autoOper);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BeginRoundRequest
 */
export const BeginRoundRequest = new BeginRoundRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FightWavePush$Type extends MessageType<FightWavePush> {
    constructor() {
        super("FightWavePush", [
            { no: 1, name: "fight", kind: "message", T: () => Fight }
        ]);
    }
    create(value?: PartialMessage<FightWavePush>): FightWavePush {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FightWavePush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FightWavePush): FightWavePush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional Fight fight */ 1:
                    message.fight = Fight.internalBinaryRead(reader, reader.uint32(), options, message.fight);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FightWavePush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional Fight fight = 1; */
        if (message.fight)
            Fight.internalBinaryWrite(message.fight, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FightWavePush
 */
export const FightWavePush = new FightWavePush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoveCardReply$Type extends MessageType<MoveCardReply> {
    constructor() {
        super("MoveCardReply", []);
    }
    create(value?: PartialMessage<MoveCardReply>): MoveCardReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MoveCardReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MoveCardReply): MoveCardReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: MoveCardReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MoveCardReply
 */
export const MoveCardReply = new MoveCardReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BeginFightRequest$Type extends MessageType<BeginFightRequest> {
    constructor() {
        super("BeginFightRequest", [
            { no: 1, name: "fightGroup", kind: "message", T: () => FightGroup }
        ]);
    }
    create(value?: PartialMessage<BeginFightRequest>): BeginFightRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BeginFightRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BeginFightRequest): BeginFightRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional FightGroup fightGroup */ 1:
                    message.fightGroup = FightGroup.internalBinaryRead(reader, reader.uint32(), options, message.fightGroup);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BeginFightRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional FightGroup fightGroup = 1; */
        if (message.fightGroup)
            FightGroup.internalBinaryWrite(message.fightGroup, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BeginFightRequest
 */
export const BeginFightRequest = new BeginFightRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MoveCardRequest$Type extends MessageType<MoveCardRequest> {
    constructor() {
        super("MoveCardRequest", [
            { no: 1, name: "fromPosition", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "toPosition", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MoveCardRequest>): MoveCardRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MoveCardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MoveCardRequest): MoveCardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 fromPosition */ 1:
                    message.fromPosition = reader.int32();
                    break;
                case /* optional int32 toPosition */ 2:
                    message.toPosition = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MoveCardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 fromPosition = 1; */
        if (message.fromPosition !== undefined)
            writer.tag(1, WireType.Varint).int32(message.fromPosition);
        /* optional int32 toPosition = 2; */
        if (message.toPosition !== undefined)
            writer.tag(2, WireType.Varint).int32(message.toPosition);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MoveCardRequest
 */
export const MoveCardRequest = new MoveCardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFightOperRequest$Type extends MessageType<GetFightOperRequest> {
    constructor() {
        super("GetFightOperRequest", []);
    }
    create(value?: PartialMessage<GetFightOperRequest>): GetFightOperRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetFightOperRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFightOperRequest): GetFightOperRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetFightOperRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetFightOperRequest
 */
export const GetFightOperRequest = new GetFightOperRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BeginRoundReply$Type extends MessageType<BeginRoundReply> {
    constructor() {
        super("BeginRoundReply", [
            { no: 1, name: "round", kind: "message", T: () => FightRound }
        ]);
    }
    create(value?: PartialMessage<BeginRoundReply>): BeginRoundReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BeginRoundReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BeginRoundReply): BeginRoundReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional FightRound round */ 1:
                    message.round = FightRound.internalBinaryRead(reader, reader.uint32(), options, message.round);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BeginRoundReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional FightRound round = 1; */
        if (message.round)
            FightRound.internalBinaryWrite(message.round, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BeginRoundReply
 */
export const BeginRoundReply = new BeginRoundReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TeamInfoPush$Type extends MessageType<TeamInfoPush> {
    constructor() {
        super("TeamInfoPush", [
            { no: 1, name: "fight", kind: "message", T: () => Fight },
            { no: 2, name: "isGm", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<TeamInfoPush>): TeamInfoPush {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TeamInfoPush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeamInfoPush): TeamInfoPush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional Fight fight */ 1:
                    message.fight = Fight.internalBinaryRead(reader, reader.uint32(), options, message.fight);
                    break;
                case /* optional bool isGm */ 2:
                    message.isGm = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeamInfoPush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional Fight fight = 1; */
        if (message.fight)
            Fight.internalBinaryWrite(message.fight, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional bool isGm = 2; */
        if (message.isGm !== undefined)
            writer.tag(2, WireType.Varint).bool(message.isGm);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TeamInfoPush
 */
export const TeamInfoPush = new TeamInfoPush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FightRoundRecordAll$Type extends MessageType<FightRoundRecordAll> {
    constructor() {
        super("FightRoundRecordAll", [
            { no: 1, name: "fight", kind: "message", T: () => Fight },
            { no: 2, name: "round", kind: "message", T: () => FightRound },
            { no: 3, name: "records", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FightRoundRecord },
            { no: 4, name: "fightRecord", kind: "message", T: () => FightRecord },
            { no: 5, name: "result", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "resultCause", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "totalRound", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "killTotal", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "pushInfo", kind: "message", T: () => CardInfoPush },
            { no: 10, name: "wavePushFight", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Fight },
            { no: 12, name: "redealInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RedealCardInfoPush }
        ]);
    }
    create(value?: PartialMessage<FightRoundRecordAll>): FightRoundRecordAll {
        const message = { records: [], wavePushFight: [], redealInfos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FightRoundRecordAll>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FightRoundRecordAll): FightRoundRecordAll {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional Fight fight */ 1:
                    message.fight = Fight.internalBinaryRead(reader, reader.uint32(), options, message.fight);
                    break;
                case /* optional FightRound round */ 2:
                    message.round = FightRound.internalBinaryRead(reader, reader.uint32(), options, message.round);
                    break;
                case /* repeated FightRoundRecord records */ 3:
                    message.records.push(FightRoundRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional FightRecord fightRecord */ 4:
                    message.fightRecord = FightRecord.internalBinaryRead(reader, reader.uint32(), options, message.fightRecord);
                    break;
                case /* optional int32 result */ 5:
                    message.result = reader.int32();
                    break;
                case /* optional int32 resultCause */ 6:
                    message.resultCause = reader.int32();
                    break;
                case /* optional int32 totalRound */ 7:
                    message.totalRound = reader.int32();
                    break;
                case /* optional int32 killTotal */ 8:
                    message.killTotal = reader.int32();
                    break;
                case /* optional CardInfoPush pushInfo */ 9:
                    message.pushInfo = CardInfoPush.internalBinaryRead(reader, reader.uint32(), options, message.pushInfo);
                    break;
                case /* repeated Fight wavePushFight */ 10:
                    message.wavePushFight.push(Fight.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated RedealCardInfoPush redealInfos */ 12:
                    message.redealInfos.push(RedealCardInfoPush.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FightRoundRecordAll, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional Fight fight = 1; */
        if (message.fight)
            Fight.internalBinaryWrite(message.fight, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional FightRound round = 2; */
        if (message.round)
            FightRound.internalBinaryWrite(message.round, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated FightRoundRecord records = 3; */
        for (let i = 0; i < message.records.length; i++)
            FightRoundRecord.internalBinaryWrite(message.records[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional FightRecord fightRecord = 4; */
        if (message.fightRecord)
            FightRecord.internalBinaryWrite(message.fightRecord, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 result = 5; */
        if (message.result !== undefined)
            writer.tag(5, WireType.Varint).int32(message.result);
        /* optional int32 resultCause = 6; */
        if (message.resultCause !== undefined)
            writer.tag(6, WireType.Varint).int32(message.resultCause);
        /* optional int32 totalRound = 7; */
        if (message.totalRound !== undefined)
            writer.tag(7, WireType.Varint).int32(message.totalRound);
        /* optional int32 killTotal = 8; */
        if (message.killTotal !== undefined)
            writer.tag(8, WireType.Varint).int32(message.killTotal);
        /* optional CardInfoPush pushInfo = 9; */
        if (message.pushInfo)
            CardInfoPush.internalBinaryWrite(message.pushInfo, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated Fight wavePushFight = 10; */
        for (let i = 0; i < message.wavePushFight.length; i++)
            Fight.internalBinaryWrite(message.wavePushFight[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated RedealCardInfoPush redealInfos = 12; */
        for (let i = 0; i < message.redealInfos.length; i++)
            RedealCardInfoPush.internalBinaryWrite(message.redealInfos[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FightRoundRecordAll
 */
export const FightRoundRecordAll = new FightRoundRecordAll$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFightRecordGroupRequest$Type extends MessageType<GetFightRecordGroupRequest> {
    constructor() {
        super("GetFightRecordGroupRequest", [
            { no: 1, name: "episodeId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetFightRecordGroupRequest>): GetFightRecordGroupRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetFightRecordGroupRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFightRecordGroupRequest): GetFightRecordGroupRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 episodeId */ 1:
                    message.episodeId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFightRecordGroupRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 episodeId = 1; */
        if (message.episodeId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.episodeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetFightRecordGroupRequest
 */
export const GetFightRecordGroupRequest = new GetFightRecordGroupRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CardInfoPush$Type extends MessageType<CardInfoPush> {
    constructor() {
        super("CardInfoPush", [
            { no: 1, name: "cardGroup", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CardInfo },
            { no: 2, name: "actPoint", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "moveNum", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "beforeCards", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CardInfo },
            { no: 5, name: "dealCardGroup", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CardInfo },
            { no: 6, name: "extraMoveAct", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CardInfoPush>): CardInfoPush {
        const message = { cardGroup: [], beforeCards: [], dealCardGroup: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CardInfoPush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CardInfoPush): CardInfoPush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CardInfo cardGroup */ 1:
                    message.cardGroup.push(CardInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 actPoint */ 2:
                    message.actPoint = reader.int32();
                    break;
                case /* optional int32 moveNum */ 3:
                    message.moveNum = reader.int32();
                    break;
                case /* repeated CardInfo beforeCards */ 4:
                    message.beforeCards.push(CardInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CardInfo dealCardGroup */ 5:
                    message.dealCardGroup.push(CardInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 extraMoveAct */ 6:
                    message.extraMoveAct = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CardInfoPush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CardInfo cardGroup = 1; */
        for (let i = 0; i < message.cardGroup.length; i++)
            CardInfo.internalBinaryWrite(message.cardGroup[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 actPoint = 2; */
        if (message.actPoint !== undefined)
            writer.tag(2, WireType.Varint).int32(message.actPoint);
        /* optional int32 moveNum = 3; */
        if (message.moveNum !== undefined)
            writer.tag(3, WireType.Varint).int32(message.moveNum);
        /* repeated CardInfo beforeCards = 4; */
        for (let i = 0; i < message.beforeCards.length; i++)
            CardInfo.internalBinaryWrite(message.beforeCards[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated CardInfo dealCardGroup = 5; */
        for (let i = 0; i < message.dealCardGroup.length; i++)
            CardInfo.internalBinaryWrite(message.dealCardGroup[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 extraMoveAct = 6; */
        if (message.extraMoveAct !== undefined)
            writer.tag(6, WireType.Varint).int32(message.extraMoveAct);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CardInfoPush
 */
export const CardInfoPush = new CardInfoPush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TestFightIdRequest$Type extends MessageType<TestFightIdRequest> {
    constructor() {
        super("TestFightIdRequest", [
            { no: 1, name: "fightId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "fightGroup", kind: "message", T: () => FightGroup }
        ]);
    }
    create(value?: PartialMessage<TestFightIdRequest>): TestFightIdRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TestFightIdRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TestFightIdRequest): TestFightIdRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 fightId */ 1:
                    message.fightId = reader.int32();
                    break;
                case /* optional FightGroup fightGroup */ 2:
                    message.fightGroup = FightGroup.internalBinaryRead(reader, reader.uint32(), options, message.fightGroup);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TestFightIdRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 fightId = 1; */
        if (message.fightId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.fightId);
        /* optional FightGroup fightGroup = 2; */
        if (message.fightGroup)
            FightGroup.internalBinaryWrite(message.fightGroup, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TestFightIdRequest
 */
export const TestFightIdRequest = new TestFightIdRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UseClothSkillRequest$Type extends MessageType<UseClothSkillRequest> {
    constructor() {
        super("UseClothSkillRequest", [
            { no: 1, name: "skillId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "fromId", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "toId", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<UseClothSkillRequest>): UseClothSkillRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UseClothSkillRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UseClothSkillRequest): UseClothSkillRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 skillId */ 1:
                    message.skillId = reader.int32();
                    break;
                case /* optional int64 fromId */ 2:
                    message.fromId = reader.int64().toBigInt();
                    break;
                case /* optional int64 toId */ 3:
                    message.toId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UseClothSkillRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 skillId = 1; */
        if (message.skillId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.skillId);
        /* optional int64 fromId = 2; */
        if (message.fromId !== undefined)
            writer.tag(2, WireType.Varint).int64(message.fromId);
        /* optional int64 toId = 3; */
        if (message.toId !== undefined)
            writer.tag(3, WireType.Varint).int64(message.toId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UseClothSkillRequest
 */
export const UseClothSkillRequest = new UseClothSkillRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AutoRoundRequest$Type extends MessageType<AutoRoundRequest> {
    constructor() {
        super("AutoRoundRequest", [
            { no: 1, name: "opers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BeginRoundOper }
        ]);
    }
    create(value?: PartialMessage<AutoRoundRequest>): AutoRoundRequest {
        const message = { opers: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AutoRoundRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AutoRoundRequest): AutoRoundRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated BeginRoundOper opers */ 1:
                    message.opers.push(BeginRoundOper.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AutoRoundRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated BeginRoundOper opers = 1; */
        for (let i = 0; i < message.opers.length; i++)
            BeginRoundOper.internalBinaryWrite(message.opers[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AutoRoundRequest
 */
export const AutoRoundRequest = new AutoRoundRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFightOperReply$Type extends MessageType<GetFightOperReply> {
    constructor() {
        super("GetFightOperReply", [
            { no: 1, name: "operRecords", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FightRoundOperRecord }
        ]);
    }
    create(value?: PartialMessage<GetFightOperReply>): GetFightOperReply {
        const message = { operRecords: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetFightOperReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFightOperReply): GetFightOperReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated FightRoundOperRecord operRecords */ 1:
                    message.operRecords.push(FightRoundOperRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFightOperReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated FightRoundOperRecord operRecords = 1; */
        for (let i = 0; i < message.operRecords.length; i++)
            FightRoundOperRecord.internalBinaryWrite(message.operRecords[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetFightOperReply
 */
export const GetFightOperReply = new GetFightOperReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResetRoundReply$Type extends MessageType<ResetRoundReply> {
    constructor() {
        super("ResetRoundReply", [
            { no: 1, name: "fight", kind: "message", T: () => Fight },
            { no: 2, name: "round", kind: "message", T: () => FightRound },
            { no: 3, name: "cards", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CardInfo }
        ]);
    }
    create(value?: PartialMessage<ResetRoundReply>): ResetRoundReply {
        const message = { cards: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResetRoundReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResetRoundReply): ResetRoundReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional Fight fight */ 1:
                    message.fight = Fight.internalBinaryRead(reader, reader.uint32(), options, message.fight);
                    break;
                case /* optional FightRound round */ 2:
                    message.round = FightRound.internalBinaryRead(reader, reader.uint32(), options, message.round);
                    break;
                case /* repeated CardInfo cards */ 3:
                    message.cards.push(CardInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResetRoundReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional Fight fight = 1; */
        if (message.fight)
            Fight.internalBinaryWrite(message.fight, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional FightRound round = 2; */
        if (message.round)
            FightRound.internalBinaryWrite(message.round, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated CardInfo cards = 3; */
        for (let i = 0; i < message.cards.length; i++)
            CardInfo.internalBinaryWrite(message.cards[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ResetRoundReply
 */
export const ResetRoundReply = new ResetRoundReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BeginFightReply$Type extends MessageType<BeginFightReply> {
    constructor() {
        super("BeginFightReply", [
            { no: 1, name: "fight", kind: "message", T: () => Fight },
            { no: 2, name: "round", kind: "message", T: () => FightRound }
        ]);
    }
    create(value?: PartialMessage<BeginFightReply>): BeginFightReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BeginFightReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BeginFightReply): BeginFightReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional Fight fight */ 1:
                    message.fight = Fight.internalBinaryRead(reader, reader.uint32(), options, message.fight);
                    break;
                case /* optional FightRound round */ 2:
                    message.round = FightRound.internalBinaryRead(reader, reader.uint32(), options, message.round);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BeginFightReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional Fight fight = 1; */
        if (message.fight)
            Fight.internalBinaryWrite(message.fight, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional FightRound round = 2; */
        if (message.round)
            FightRound.internalBinaryWrite(message.round, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BeginFightReply
 */
export const BeginFightReply = new BeginFightReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndFightReply$Type extends MessageType<EndFightReply> {
    constructor() {
        super("EndFightReply", []);
    }
    create(value?: PartialMessage<EndFightReply>): EndFightReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EndFightReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndFightReply): EndFightReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: EndFightReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EndFightReply
 */
export const EndFightReply = new EndFightReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UseClothSkillOperRecord$Type extends MessageType<UseClothSkillOperRecord> {
    constructor() {
        super("UseClothSkillOperRecord", [
            { no: 1, name: "skillId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "fromId", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "toId", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<UseClothSkillOperRecord>): UseClothSkillOperRecord {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UseClothSkillOperRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UseClothSkillOperRecord): UseClothSkillOperRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 skillId */ 1:
                    message.skillId = reader.int32();
                    break;
                case /* optional int64 fromId */ 2:
                    message.fromId = reader.int64().toBigInt();
                    break;
                case /* optional int64 toId */ 3:
                    message.toId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UseClothSkillOperRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 skillId = 1; */
        if (message.skillId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.skillId);
        /* optional int64 fromId = 2; */
        if (message.fromId !== undefined)
            writer.tag(2, WireType.Varint).int64(message.fromId);
        /* optional int64 toId = 3; */
        if (message.toId !== undefined)
            writer.tag(3, WireType.Varint).int64(message.toId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UseClothSkillOperRecord
 */
export const UseClothSkillOperRecord = new UseClothSkillOperRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChangeSubHeroReply$Type extends MessageType<ChangeSubHeroReply> {
    constructor() {
        super("ChangeSubHeroReply", []);
    }
    create(value?: PartialMessage<ChangeSubHeroReply>): ChangeSubHeroReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChangeSubHeroReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChangeSubHeroReply): ChangeSubHeroReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ChangeSubHeroReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChangeSubHeroReply
 */
export const ChangeSubHeroReply = new ChangeSubHeroReply$Type();
