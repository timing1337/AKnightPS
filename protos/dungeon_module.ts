// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "dungeon_module.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { FightGroup } from "./fight_def";
import { FightRound } from "./fight_def";
import { Fight } from "./fight_def";
import { UserChapterTypeNum } from "./dungeon_def";
import { UserDungeon } from "./dungeon_def";
import { HeroGroupInfo } from "./hero_def";
import { MaterialData } from "./material_module";
/**
 * @generated from protobuf message EndDungeonPush
 */
export interface EndDungeonPush {
    /**
     * @generated from protobuf field: optional int32 chapterId = 1;
     */
    chapterId?: number;
    /**
     * @generated from protobuf field: optional int32 episodeId = 2;
     */
    episodeId?: number;
    /**
     * @generated from protobuf field: optional int32 playerExp = 3;
     */
    playerExp?: number;
    /**
     * @generated from protobuf field: repeated MaterialData firstBonus = 4;
     */
    firstBonus: MaterialData[];
    /**
     * @generated from protobuf field: repeated MaterialData normalBonus = 5;
     */
    normalBonus: MaterialData[];
    /**
     * @generated from protobuf field: optional int32 star = 6;
     */
    star?: number;
    /**
     * @generated from protobuf field: repeated MaterialData advencedBonus = 7;
     */
    advencedBonus: MaterialData[];
    /**
     * @generated from protobuf field: optional bool updateDungeonRecord = 8;
     */
    updateDungeonRecord?: boolean;
    /**
     * @generated from protobuf field: optional bool canUpdateDungeonRecord = 9;
     */
    canUpdateDungeonRecord?: boolean;
    /**
     * @generated from protobuf field: optional int32 oldRecordRound = 10;
     */
    oldRecordRound?: number;
    /**
     * @generated from protobuf field: optional int32 newRecordRound = 11;
     */
    newRecordRound?: number;
    /**
     * @generated from protobuf field: optional bool firstPass = 12;
     */
    firstPass?: boolean;
}
/**
 * @generated from protobuf message InstructionDungeonOpenReply
 */
export interface InstructionDungeonOpenReply {
}
/**
 * @generated from protobuf message InstructionDungeonRewardRequest
 */
export interface InstructionDungeonRewardRequest {
    /**
     * @generated from protobuf field: optional int32 topicId = 1;
     */
    topicId?: number;
}
/**
 * @generated from protobuf message DungeonLastHeroGroup
 */
export interface DungeonLastHeroGroup {
    /**
     * @generated from protobuf field: optional int32 chapterId = 1;
     */
    chapterId?: number;
    /**
     * @generated from protobuf field: optional HeroGroupInfo heroGroupSnapshot = 2;
     */
    heroGroupSnapshot?: HeroGroupInfo;
}
/**
 * @generated from protobuf message DungeonUpdatePush
 */
export interface DungeonUpdatePush {
    /**
     * @generated from protobuf field: optional UserDungeon dungeonInfo = 1;
     */
    dungeonInfo?: UserDungeon;
    /**
     * @generated from protobuf field: repeated UserChapterTypeNum chapterTypeNums = 2;
     */
    chapterTypeNums: UserChapterTypeNum[];
}
/**
 * @generated from protobuf message InstructionDungeonFinalRewardReply
 */
export interface InstructionDungeonFinalRewardReply {
}
/**
 * @generated from protobuf message InstructionDungeonOpenRequest
 */
export interface InstructionDungeonOpenRequest {
    /**
     * @generated from protobuf field: repeated int32 openId = 1;
     */
    openId: number[];
}
/**
 * @generated from protobuf message EquipSpDungeonUpdatePush
 */
export interface EquipSpDungeonUpdatePush {
    /**
     * @generated from protobuf field: optional bool isDelete = 1;
     */
    isDelete?: boolean;
    /**
     * @generated from protobuf field: optional int32 chapterId = 2;
     */
    chapterId?: number;
}
/**
 * @generated from protobuf message GetEpisodeHeroRecommendRequest
 */
export interface GetEpisodeHeroRecommendRequest {
    /**
     * @generated from protobuf field: optional int32 episodeId = 1;
     */
    episodeId?: number;
}
/**
 * @generated from protobuf message MapElementReply
 */
export interface MapElementReply {
    /**
     * @generated from protobuf field: optional int32 elementId = 1;
     */
    elementId?: number;
    /**
     * @generated from protobuf field: repeated int32 dialogIds = 2;
     */
    dialogIds: number[];
}
/**
 * @generated from protobuf message EndDungeonReply
 */
export interface EndDungeonReply {
}
/**
 * @generated from protobuf message CoverDungeonRecordReply
 */
export interface CoverDungeonRecordReply {
    /**
     * @generated from protobuf field: optional bool isCover = 1;
     */
    isCover?: boolean;
}
/**
 * @generated from protobuf message ChapterMapUpdatePush
 */
export interface ChapterMapUpdatePush {
    /**
     * @generated from protobuf field: repeated int32 mapIds = 1;
     */
    mapIds: number[];
}
/**
 * @generated from protobuf message InstructionDungeonFinalRewardRequest
 */
export interface InstructionDungeonFinalRewardRequest {
}
/**
 * @generated from protobuf message InstructionDungeonInfoPush
 */
export interface InstructionDungeonInfoPush {
    /**
     * @generated from protobuf field: repeated int32 unlockIds = 1;
     */
    unlockIds: number[];
    /**
     * @generated from protobuf field: repeated int32 getRewardIds = 2;
     */
    getRewardIds: number[];
    /**
     * @generated from protobuf field: optional bool getFinalReward = 3;
     */
    getFinalReward?: boolean;
    /**
     * @generated from protobuf field: repeated int32 openIds = 4;
     */
    openIds: number[];
}
/**
 * @generated from protobuf message MapElementRequest
 */
export interface MapElementRequest {
    /**
     * @generated from protobuf field: optional int32 elementId = 1;
     */
    elementId?: number;
    /**
     * @generated from protobuf field: repeated int32 dialogIds = 2;
     */
    dialogIds: number[];
}
/**
 * @generated from protobuf message GetPointRewardReply
 */
export interface GetPointRewardReply {
    /**
     * @generated from protobuf field: repeated int32 id = 1;
     */
    id: number[];
}
/**
 * @generated from protobuf message CoverDungeonRecordRequest
 */
export interface CoverDungeonRecordRequest {
    /**
     * @generated from protobuf field: optional bool isCover = 1;
     */
    isCover?: boolean;
}
/**
 * @generated from protobuf message GetDungeonRequest
 */
export interface GetDungeonRequest {
}
/**
 * @generated from protobuf message StartDungeonReply
 */
export interface StartDungeonReply {
    /**
     * @generated from protobuf field: optional Fight fight = 1;
     */
    fight?: Fight;
    /**
     * @generated from protobuf field: optional FightRound round = 2;
     */
    round?: FightRound;
}
/**
 * @generated from protobuf message EpisodeHeroRecommendInfo
 */
export interface EpisodeHeroRecommendInfo {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
    /**
     * @generated from protobuf field: repeated HeroRecommendInfo infos = 2;
     */
    infos: HeroRecommendInfo[];
    /**
     * @generated from protobuf field: optional float rate = 3;
     */
    rate?: number;
}
/**
 * @generated from protobuf message RewardPointUpdatePush
 */
export interface RewardPointUpdatePush {
    /**
     * @generated from protobuf field: optional int32 chapterId = 1;
     */
    chapterId?: number;
    /**
     * @generated from protobuf field: optional int32 value = 2;
     */
    value?: number;
}
/**
 * @generated from protobuf message HeroRecommendInfo
 */
export interface HeroRecommendInfo {
    /**
     * @generated from protobuf field: repeated int32 heroIds = 1;
     */
    heroIds: number[];
    /**
     * @generated from protobuf field: repeated int32 subHeroIds = 2;
     */
    subHeroIds: number[];
    /**
     * @generated from protobuf field: optional int32 cloth = 3;
     */
    cloth?: number;
    /**
     * @generated from protobuf field: optional float rate = 4;
     */
    rate?: number;
    /**
     * @generated from protobuf field: repeated int32 levels = 5;
     */
    levels: number[];
}
/**
 * @generated from protobuf message EndDungeonRequest
 */
export interface EndDungeonRequest {
    /**
     * @generated from protobuf field: optional bool isAbort = 1;
     */
    isAbort?: boolean;
}
/**
 * @generated from protobuf message PuzzleFinishRequest
 */
export interface PuzzleFinishRequest {
    /**
     * @generated from protobuf field: optional int32 elementId = 1;
     */
    elementId?: number;
}
/**
 * @generated from protobuf message RewardPointInfo
 */
export interface RewardPointInfo {
    /**
     * @generated from protobuf field: optional int32 chapterId = 1;
     */
    chapterId?: number;
    /**
     * @generated from protobuf field: optional int32 rewardPoint = 2;
     */
    rewardPoint?: number;
    /**
     * @generated from protobuf field: repeated int32 hasGetPointRewardIds = 3;
     */
    hasGetPointRewardIds: number[];
}
/**
 * @generated from protobuf message InstructionDungeonInfoRequest
 */
export interface InstructionDungeonInfoRequest {
}
/**
 * @generated from protobuf message PuzzleFinishReply
 */
export interface PuzzleFinishReply {
    /**
     * @generated from protobuf field: optional int32 elementId = 1;
     */
    elementId?: number;
}
/**
 * @generated from protobuf message ChapterMapElementUpdatePush
 */
export interface ChapterMapElementUpdatePush {
    /**
     * @generated from protobuf field: repeated int32 elements = 1;
     */
    elements: number[];
}
/**
 * @generated from protobuf message GetPointRewardRequest
 */
export interface GetPointRewardRequest {
    /**
     * @generated from protobuf field: repeated int32 id = 1;
     */
    id: number[];
}
/**
 * @generated from protobuf message InstructionDungeonRewardReply
 */
export interface InstructionDungeonRewardReply {
}
/**
 * @generated from protobuf message GetEpisodeHeroRecommendReply
 */
export interface GetEpisodeHeroRecommendReply {
    /**
     * @generated from protobuf field: repeated EpisodeHeroRecommendInfo racommends = 1;
     */
    racommends: EpisodeHeroRecommendInfo[];
}
/**
 * @generated from protobuf message StartDungeonRequest
 */
export interface StartDungeonRequest {
    /**
     * @generated from protobuf field: optional int32 chapterId = 1;
     */
    chapterId?: number;
    /**
     * @generated from protobuf field: optional int32 episodeId = 2;
     */
    episodeId?: number;
    /**
     * @generated from protobuf field: optional FightGroup fightGroup = 3;
     */
    fightGroup?: FightGroup;
    /**
     * @generated from protobuf field: optional int32 multiplication = 4;
     */
    multiplication?: number;
    /**
     * @generated from protobuf field: optional bool useRecord = 5;
     */
    useRecord?: boolean;
    /**
     * @generated from protobuf field: optional bool isRestart = 6;
     */
    isRestart?: boolean;
}
/**
 * @generated from protobuf message InstructionDungeonInfoReply
 */
export interface InstructionDungeonInfoReply {
    /**
     * @generated from protobuf field: repeated int32 unlockIds = 1;
     */
    unlockIds: number[];
    /**
     * @generated from protobuf field: repeated int32 getRewardIds = 2;
     */
    getRewardIds: number[];
    /**
     * @generated from protobuf field: optional bool getFinalReward = 3;
     */
    getFinalReward?: boolean;
    /**
     * @generated from protobuf field: repeated int32 openIds = 4;
     */
    openIds: number[];
}
/**
 * @generated from protobuf message GetDungeonReply
 */
export interface GetDungeonReply {
    /**
     * @generated from protobuf field: repeated UserDungeon dungeonInfoList = 1;
     */
    dungeonInfoList: UserDungeon[];
    /**
     * @generated from protobuf field: repeated DungeonLastHeroGroup lastHeroGroup = 2;
     */
    lastHeroGroup: DungeonLastHeroGroup[];
    /**
     * @generated from protobuf field: repeated int32 mapIds = 3;
     */
    mapIds: number[];
    /**
     * @generated from protobuf field: repeated int32 elements = 4;
     */
    elements: number[];
    /**
     * @generated from protobuf field: repeated RewardPointInfo rewardPointInfo = 5;
     */
    rewardPointInfo: RewardPointInfo[];
    /**
     * @generated from protobuf field: repeated int32 equipSpChapters = 6;
     */
    equipSpChapters: number[];
    /**
     * @generated from protobuf field: repeated UserChapterTypeNum chapterTypeNums = 7;
     */
    chapterTypeNums: UserChapterTypeNum[];
    /**
     * @generated from protobuf field: repeated int32 finishElements = 8;
     */
    finishElements: number[];
    /**
     * @generated from protobuf field: repeated int32 finishPuzzles = 9;
     */
    finishPuzzles: number[];
}
// @generated message type with reflection information, may provide speed optimized methods
class EndDungeonPush$Type extends MessageType<EndDungeonPush> {
    constructor() {
        super("EndDungeonPush", [
            { no: 1, name: "chapterId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "episodeId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "playerExp", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "firstBonus", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MaterialData },
            { no: 5, name: "normalBonus", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MaterialData },
            { no: 6, name: "star", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "advencedBonus", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MaterialData },
            { no: 8, name: "updateDungeonRecord", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 9, name: "canUpdateDungeonRecord", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 10, name: "oldRecordRound", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "newRecordRound", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "firstPass", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EndDungeonPush>): EndDungeonPush {
        const message = { firstBonus: [], normalBonus: [], advencedBonus: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EndDungeonPush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndDungeonPush): EndDungeonPush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterId */ 1:
                    message.chapterId = reader.int32();
                    break;
                case /* optional int32 episodeId */ 2:
                    message.episodeId = reader.int32();
                    break;
                case /* optional int32 playerExp */ 3:
                    message.playerExp = reader.int32();
                    break;
                case /* repeated MaterialData firstBonus */ 4:
                    message.firstBonus.push(MaterialData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated MaterialData normalBonus */ 5:
                    message.normalBonus.push(MaterialData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 star */ 6:
                    message.star = reader.int32();
                    break;
                case /* repeated MaterialData advencedBonus */ 7:
                    message.advencedBonus.push(MaterialData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool updateDungeonRecord */ 8:
                    message.updateDungeonRecord = reader.bool();
                    break;
                case /* optional bool canUpdateDungeonRecord */ 9:
                    message.canUpdateDungeonRecord = reader.bool();
                    break;
                case /* optional int32 oldRecordRound */ 10:
                    message.oldRecordRound = reader.int32();
                    break;
                case /* optional int32 newRecordRound */ 11:
                    message.newRecordRound = reader.int32();
                    break;
                case /* optional bool firstPass */ 12:
                    message.firstPass = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EndDungeonPush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterId = 1; */
        if (message.chapterId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterId);
        /* optional int32 episodeId = 2; */
        if (message.episodeId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.episodeId);
        /* optional int32 playerExp = 3; */
        if (message.playerExp !== undefined)
            writer.tag(3, WireType.Varint).int32(message.playerExp);
        /* repeated MaterialData firstBonus = 4; */
        for (let i = 0; i < message.firstBonus.length; i++)
            MaterialData.internalBinaryWrite(message.firstBonus[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated MaterialData normalBonus = 5; */
        for (let i = 0; i < message.normalBonus.length; i++)
            MaterialData.internalBinaryWrite(message.normalBonus[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 star = 6; */
        if (message.star !== undefined)
            writer.tag(6, WireType.Varint).int32(message.star);
        /* repeated MaterialData advencedBonus = 7; */
        for (let i = 0; i < message.advencedBonus.length; i++)
            MaterialData.internalBinaryWrite(message.advencedBonus[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* optional bool updateDungeonRecord = 8; */
        if (message.updateDungeonRecord !== undefined)
            writer.tag(8, WireType.Varint).bool(message.updateDungeonRecord);
        /* optional bool canUpdateDungeonRecord = 9; */
        if (message.canUpdateDungeonRecord !== undefined)
            writer.tag(9, WireType.Varint).bool(message.canUpdateDungeonRecord);
        /* optional int32 oldRecordRound = 10; */
        if (message.oldRecordRound !== undefined)
            writer.tag(10, WireType.Varint).int32(message.oldRecordRound);
        /* optional int32 newRecordRound = 11; */
        if (message.newRecordRound !== undefined)
            writer.tag(11, WireType.Varint).int32(message.newRecordRound);
        /* optional bool firstPass = 12; */
        if (message.firstPass !== undefined)
            writer.tag(12, WireType.Varint).bool(message.firstPass);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EndDungeonPush
 */
export const EndDungeonPush = new EndDungeonPush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstructionDungeonOpenReply$Type extends MessageType<InstructionDungeonOpenReply> {
    constructor() {
        super("InstructionDungeonOpenReply", []);
    }
    create(value?: PartialMessage<InstructionDungeonOpenReply>): InstructionDungeonOpenReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InstructionDungeonOpenReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstructionDungeonOpenReply): InstructionDungeonOpenReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: InstructionDungeonOpenReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message InstructionDungeonOpenReply
 */
export const InstructionDungeonOpenReply = new InstructionDungeonOpenReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstructionDungeonRewardRequest$Type extends MessageType<InstructionDungeonRewardRequest> {
    constructor() {
        super("InstructionDungeonRewardRequest", [
            { no: 1, name: "topicId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<InstructionDungeonRewardRequest>): InstructionDungeonRewardRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InstructionDungeonRewardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstructionDungeonRewardRequest): InstructionDungeonRewardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 topicId */ 1:
                    message.topicId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InstructionDungeonRewardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 topicId = 1; */
        if (message.topicId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.topicId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message InstructionDungeonRewardRequest
 */
export const InstructionDungeonRewardRequest = new InstructionDungeonRewardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DungeonLastHeroGroup$Type extends MessageType<DungeonLastHeroGroup> {
    constructor() {
        super("DungeonLastHeroGroup", [
            { no: 1, name: "chapterId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "heroGroupSnapshot", kind: "message", T: () => HeroGroupInfo }
        ]);
    }
    create(value?: PartialMessage<DungeonLastHeroGroup>): DungeonLastHeroGroup {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DungeonLastHeroGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DungeonLastHeroGroup): DungeonLastHeroGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterId */ 1:
                    message.chapterId = reader.int32();
                    break;
                case /* optional HeroGroupInfo heroGroupSnapshot */ 2:
                    message.heroGroupSnapshot = HeroGroupInfo.internalBinaryRead(reader, reader.uint32(), options, message.heroGroupSnapshot);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DungeonLastHeroGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterId = 1; */
        if (message.chapterId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterId);
        /* optional HeroGroupInfo heroGroupSnapshot = 2; */
        if (message.heroGroupSnapshot)
            HeroGroupInfo.internalBinaryWrite(message.heroGroupSnapshot, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DungeonLastHeroGroup
 */
export const DungeonLastHeroGroup = new DungeonLastHeroGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DungeonUpdatePush$Type extends MessageType<DungeonUpdatePush> {
    constructor() {
        super("DungeonUpdatePush", [
            { no: 1, name: "dungeonInfo", kind: "message", T: () => UserDungeon },
            { no: 2, name: "chapterTypeNums", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UserChapterTypeNum }
        ]);
    }
    create(value?: PartialMessage<DungeonUpdatePush>): DungeonUpdatePush {
        const message = { chapterTypeNums: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<DungeonUpdatePush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DungeonUpdatePush): DungeonUpdatePush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional UserDungeon dungeonInfo */ 1:
                    message.dungeonInfo = UserDungeon.internalBinaryRead(reader, reader.uint32(), options, message.dungeonInfo);
                    break;
                case /* repeated UserChapterTypeNum chapterTypeNums */ 2:
                    message.chapterTypeNums.push(UserChapterTypeNum.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DungeonUpdatePush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional UserDungeon dungeonInfo = 1; */
        if (message.dungeonInfo)
            UserDungeon.internalBinaryWrite(message.dungeonInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated UserChapterTypeNum chapterTypeNums = 2; */
        for (let i = 0; i < message.chapterTypeNums.length; i++)
            UserChapterTypeNum.internalBinaryWrite(message.chapterTypeNums[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message DungeonUpdatePush
 */
export const DungeonUpdatePush = new DungeonUpdatePush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstructionDungeonFinalRewardReply$Type extends MessageType<InstructionDungeonFinalRewardReply> {
    constructor() {
        super("InstructionDungeonFinalRewardReply", []);
    }
    create(value?: PartialMessage<InstructionDungeonFinalRewardReply>): InstructionDungeonFinalRewardReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InstructionDungeonFinalRewardReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstructionDungeonFinalRewardReply): InstructionDungeonFinalRewardReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: InstructionDungeonFinalRewardReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message InstructionDungeonFinalRewardReply
 */
export const InstructionDungeonFinalRewardReply = new InstructionDungeonFinalRewardReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstructionDungeonOpenRequest$Type extends MessageType<InstructionDungeonOpenRequest> {
    constructor() {
        super("InstructionDungeonOpenRequest", [
            { no: 1, name: "openId", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<InstructionDungeonOpenRequest>): InstructionDungeonOpenRequest {
        const message = { openId: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InstructionDungeonOpenRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstructionDungeonOpenRequest): InstructionDungeonOpenRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 openId */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.openId.push(reader.int32());
                    else
                        message.openId.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InstructionDungeonOpenRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 openId = 1; */
        for (let i = 0; i < message.openId.length; i++)
            writer.tag(1, WireType.Varint).int32(message.openId[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message InstructionDungeonOpenRequest
 */
export const InstructionDungeonOpenRequest = new InstructionDungeonOpenRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EquipSpDungeonUpdatePush$Type extends MessageType<EquipSpDungeonUpdatePush> {
    constructor() {
        super("EquipSpDungeonUpdatePush", [
            { no: 1, name: "isDelete", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "chapterId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<EquipSpDungeonUpdatePush>): EquipSpDungeonUpdatePush {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EquipSpDungeonUpdatePush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EquipSpDungeonUpdatePush): EquipSpDungeonUpdatePush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool isDelete */ 1:
                    message.isDelete = reader.bool();
                    break;
                case /* optional int32 chapterId */ 2:
                    message.chapterId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EquipSpDungeonUpdatePush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool isDelete = 1; */
        if (message.isDelete !== undefined)
            writer.tag(1, WireType.Varint).bool(message.isDelete);
        /* optional int32 chapterId = 2; */
        if (message.chapterId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.chapterId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EquipSpDungeonUpdatePush
 */
export const EquipSpDungeonUpdatePush = new EquipSpDungeonUpdatePush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEpisodeHeroRecommendRequest$Type extends MessageType<GetEpisodeHeroRecommendRequest> {
    constructor() {
        super("GetEpisodeHeroRecommendRequest", [
            { no: 1, name: "episodeId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetEpisodeHeroRecommendRequest>): GetEpisodeHeroRecommendRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetEpisodeHeroRecommendRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEpisodeHeroRecommendRequest): GetEpisodeHeroRecommendRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 episodeId */ 1:
                    message.episodeId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEpisodeHeroRecommendRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 episodeId = 1; */
        if (message.episodeId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.episodeId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetEpisodeHeroRecommendRequest
 */
export const GetEpisodeHeroRecommendRequest = new GetEpisodeHeroRecommendRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapElementReply$Type extends MessageType<MapElementReply> {
    constructor() {
        super("MapElementReply", [
            { no: 1, name: "elementId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "dialogIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MapElementReply>): MapElementReply {
        const message = { dialogIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MapElementReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MapElementReply): MapElementReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 elementId */ 1:
                    message.elementId = reader.int32();
                    break;
                case /* repeated int32 dialogIds */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.dialogIds.push(reader.int32());
                    else
                        message.dialogIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MapElementReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 elementId = 1; */
        if (message.elementId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.elementId);
        /* repeated int32 dialogIds = 2; */
        for (let i = 0; i < message.dialogIds.length; i++)
            writer.tag(2, WireType.Varint).int32(message.dialogIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MapElementReply
 */
export const MapElementReply = new MapElementReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndDungeonReply$Type extends MessageType<EndDungeonReply> {
    constructor() {
        super("EndDungeonReply", []);
    }
    create(value?: PartialMessage<EndDungeonReply>): EndDungeonReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EndDungeonReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndDungeonReply): EndDungeonReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: EndDungeonReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EndDungeonReply
 */
export const EndDungeonReply = new EndDungeonReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CoverDungeonRecordReply$Type extends MessageType<CoverDungeonRecordReply> {
    constructor() {
        super("CoverDungeonRecordReply", [
            { no: 1, name: "isCover", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CoverDungeonRecordReply>): CoverDungeonRecordReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CoverDungeonRecordReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CoverDungeonRecordReply): CoverDungeonRecordReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool isCover */ 1:
                    message.isCover = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CoverDungeonRecordReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool isCover = 1; */
        if (message.isCover !== undefined)
            writer.tag(1, WireType.Varint).bool(message.isCover);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CoverDungeonRecordReply
 */
export const CoverDungeonRecordReply = new CoverDungeonRecordReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChapterMapUpdatePush$Type extends MessageType<ChapterMapUpdatePush> {
    constructor() {
        super("ChapterMapUpdatePush", [
            { no: 1, name: "mapIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChapterMapUpdatePush>): ChapterMapUpdatePush {
        const message = { mapIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChapterMapUpdatePush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChapterMapUpdatePush): ChapterMapUpdatePush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 mapIds */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.mapIds.push(reader.int32());
                    else
                        message.mapIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChapterMapUpdatePush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 mapIds = 1; */
        for (let i = 0; i < message.mapIds.length; i++)
            writer.tag(1, WireType.Varint).int32(message.mapIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChapterMapUpdatePush
 */
export const ChapterMapUpdatePush = new ChapterMapUpdatePush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstructionDungeonFinalRewardRequest$Type extends MessageType<InstructionDungeonFinalRewardRequest> {
    constructor() {
        super("InstructionDungeonFinalRewardRequest", []);
    }
    create(value?: PartialMessage<InstructionDungeonFinalRewardRequest>): InstructionDungeonFinalRewardRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InstructionDungeonFinalRewardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstructionDungeonFinalRewardRequest): InstructionDungeonFinalRewardRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: InstructionDungeonFinalRewardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message InstructionDungeonFinalRewardRequest
 */
export const InstructionDungeonFinalRewardRequest = new InstructionDungeonFinalRewardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstructionDungeonInfoPush$Type extends MessageType<InstructionDungeonInfoPush> {
    constructor() {
        super("InstructionDungeonInfoPush", [
            { no: 1, name: "unlockIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "getRewardIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "getFinalReward", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "openIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<InstructionDungeonInfoPush>): InstructionDungeonInfoPush {
        const message = { unlockIds: [], getRewardIds: [], openIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InstructionDungeonInfoPush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstructionDungeonInfoPush): InstructionDungeonInfoPush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 unlockIds */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unlockIds.push(reader.int32());
                    else
                        message.unlockIds.push(reader.int32());
                    break;
                case /* repeated int32 getRewardIds */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.getRewardIds.push(reader.int32());
                    else
                        message.getRewardIds.push(reader.int32());
                    break;
                case /* optional bool getFinalReward */ 3:
                    message.getFinalReward = reader.bool();
                    break;
                case /* repeated int32 openIds */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.openIds.push(reader.int32());
                    else
                        message.openIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InstructionDungeonInfoPush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 unlockIds = 1; */
        for (let i = 0; i < message.unlockIds.length; i++)
            writer.tag(1, WireType.Varint).int32(message.unlockIds[i]);
        /* repeated int32 getRewardIds = 2; */
        for (let i = 0; i < message.getRewardIds.length; i++)
            writer.tag(2, WireType.Varint).int32(message.getRewardIds[i]);
        /* optional bool getFinalReward = 3; */
        if (message.getFinalReward !== undefined)
            writer.tag(3, WireType.Varint).bool(message.getFinalReward);
        /* repeated int32 openIds = 4; */
        for (let i = 0; i < message.openIds.length; i++)
            writer.tag(4, WireType.Varint).int32(message.openIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message InstructionDungeonInfoPush
 */
export const InstructionDungeonInfoPush = new InstructionDungeonInfoPush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MapElementRequest$Type extends MessageType<MapElementRequest> {
    constructor() {
        super("MapElementRequest", [
            { no: 1, name: "elementId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "dialogIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MapElementRequest>): MapElementRequest {
        const message = { dialogIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MapElementRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MapElementRequest): MapElementRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 elementId */ 1:
                    message.elementId = reader.int32();
                    break;
                case /* repeated int32 dialogIds */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.dialogIds.push(reader.int32());
                    else
                        message.dialogIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MapElementRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 elementId = 1; */
        if (message.elementId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.elementId);
        /* repeated int32 dialogIds = 2; */
        for (let i = 0; i < message.dialogIds.length; i++)
            writer.tag(2, WireType.Varint).int32(message.dialogIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MapElementRequest
 */
export const MapElementRequest = new MapElementRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPointRewardReply$Type extends MessageType<GetPointRewardReply> {
    constructor() {
        super("GetPointRewardReply", [
            { no: 1, name: "id", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetPointRewardReply>): GetPointRewardReply {
        const message = { id: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetPointRewardReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPointRewardReply): GetPointRewardReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 id */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.id.push(reader.int32());
                    else
                        message.id.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPointRewardReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 id = 1; */
        for (let i = 0; i < message.id.length; i++)
            writer.tag(1, WireType.Varint).int32(message.id[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetPointRewardReply
 */
export const GetPointRewardReply = new GetPointRewardReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CoverDungeonRecordRequest$Type extends MessageType<CoverDungeonRecordRequest> {
    constructor() {
        super("CoverDungeonRecordRequest", [
            { no: 1, name: "isCover", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<CoverDungeonRecordRequest>): CoverDungeonRecordRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CoverDungeonRecordRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CoverDungeonRecordRequest): CoverDungeonRecordRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool isCover */ 1:
                    message.isCover = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CoverDungeonRecordRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool isCover = 1; */
        if (message.isCover !== undefined)
            writer.tag(1, WireType.Varint).bool(message.isCover);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CoverDungeonRecordRequest
 */
export const CoverDungeonRecordRequest = new CoverDungeonRecordRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDungeonRequest$Type extends MessageType<GetDungeonRequest> {
    constructor() {
        super("GetDungeonRequest", []);
    }
    create(value?: PartialMessage<GetDungeonRequest>): GetDungeonRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetDungeonRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDungeonRequest): GetDungeonRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetDungeonRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetDungeonRequest
 */
export const GetDungeonRequest = new GetDungeonRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartDungeonReply$Type extends MessageType<StartDungeonReply> {
    constructor() {
        super("StartDungeonReply", [
            { no: 1, name: "fight", kind: "message", T: () => Fight },
            { no: 2, name: "round", kind: "message", T: () => FightRound }
        ]);
    }
    create(value?: PartialMessage<StartDungeonReply>): StartDungeonReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StartDungeonReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartDungeonReply): StartDungeonReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional Fight fight */ 1:
                    message.fight = Fight.internalBinaryRead(reader, reader.uint32(), options, message.fight);
                    break;
                case /* optional FightRound round */ 2:
                    message.round = FightRound.internalBinaryRead(reader, reader.uint32(), options, message.round);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartDungeonReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional Fight fight = 1; */
        if (message.fight)
            Fight.internalBinaryWrite(message.fight, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional FightRound round = 2; */
        if (message.round)
            FightRound.internalBinaryWrite(message.round, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StartDungeonReply
 */
export const StartDungeonReply = new StartDungeonReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EpisodeHeroRecommendInfo$Type extends MessageType<EpisodeHeroRecommendInfo> {
    constructor() {
        super("EpisodeHeroRecommendInfo", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => HeroRecommendInfo },
            { no: 3, name: "rate", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<EpisodeHeroRecommendInfo>): EpisodeHeroRecommendInfo {
        const message = { infos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EpisodeHeroRecommendInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EpisodeHeroRecommendInfo): EpisodeHeroRecommendInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                case /* repeated HeroRecommendInfo infos */ 2:
                    message.infos.push(HeroRecommendInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional float rate */ 3:
                    message.rate = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EpisodeHeroRecommendInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        /* repeated HeroRecommendInfo infos = 2; */
        for (let i = 0; i < message.infos.length; i++)
            HeroRecommendInfo.internalBinaryWrite(message.infos[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional float rate = 3; */
        if (message.rate !== undefined)
            writer.tag(3, WireType.Bit32).float(message.rate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EpisodeHeroRecommendInfo
 */
export const EpisodeHeroRecommendInfo = new EpisodeHeroRecommendInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RewardPointUpdatePush$Type extends MessageType<RewardPointUpdatePush> {
    constructor() {
        super("RewardPointUpdatePush", [
            { no: 1, name: "chapterId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "value", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RewardPointUpdatePush>): RewardPointUpdatePush {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RewardPointUpdatePush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RewardPointUpdatePush): RewardPointUpdatePush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterId */ 1:
                    message.chapterId = reader.int32();
                    break;
                case /* optional int32 value */ 2:
                    message.value = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RewardPointUpdatePush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterId = 1; */
        if (message.chapterId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterId);
        /* optional int32 value = 2; */
        if (message.value !== undefined)
            writer.tag(2, WireType.Varint).int32(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RewardPointUpdatePush
 */
export const RewardPointUpdatePush = new RewardPointUpdatePush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroRecommendInfo$Type extends MessageType<HeroRecommendInfo> {
    constructor() {
        super("HeroRecommendInfo", [
            { no: 1, name: "heroIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "subHeroIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "cloth", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "rate", kind: "scalar", opt: true, T: 2 /*ScalarType.FLOAT*/ },
            { no: 5, name: "levels", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HeroRecommendInfo>): HeroRecommendInfo {
        const message = { heroIds: [], subHeroIds: [], levels: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroRecommendInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroRecommendInfo): HeroRecommendInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 heroIds */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.heroIds.push(reader.int32());
                    else
                        message.heroIds.push(reader.int32());
                    break;
                case /* repeated int32 subHeroIds */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.subHeroIds.push(reader.int32());
                    else
                        message.subHeroIds.push(reader.int32());
                    break;
                case /* optional int32 cloth */ 3:
                    message.cloth = reader.int32();
                    break;
                case /* optional float rate */ 4:
                    message.rate = reader.float();
                    break;
                case /* repeated int32 levels */ 5:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.levels.push(reader.int32());
                    else
                        message.levels.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroRecommendInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 heroIds = 1; */
        for (let i = 0; i < message.heroIds.length; i++)
            writer.tag(1, WireType.Varint).int32(message.heroIds[i]);
        /* repeated int32 subHeroIds = 2; */
        for (let i = 0; i < message.subHeroIds.length; i++)
            writer.tag(2, WireType.Varint).int32(message.subHeroIds[i]);
        /* optional int32 cloth = 3; */
        if (message.cloth !== undefined)
            writer.tag(3, WireType.Varint).int32(message.cloth);
        /* optional float rate = 4; */
        if (message.rate !== undefined)
            writer.tag(4, WireType.Bit32).float(message.rate);
        /* repeated int32 levels = 5; */
        for (let i = 0; i < message.levels.length; i++)
            writer.tag(5, WireType.Varint).int32(message.levels[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroRecommendInfo
 */
export const HeroRecommendInfo = new HeroRecommendInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EndDungeonRequest$Type extends MessageType<EndDungeonRequest> {
    constructor() {
        super("EndDungeonRequest", [
            { no: 1, name: "isAbort", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<EndDungeonRequest>): EndDungeonRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EndDungeonRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EndDungeonRequest): EndDungeonRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool isAbort */ 1:
                    message.isAbort = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EndDungeonRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool isAbort = 1; */
        if (message.isAbort !== undefined)
            writer.tag(1, WireType.Varint).bool(message.isAbort);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EndDungeonRequest
 */
export const EndDungeonRequest = new EndDungeonRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PuzzleFinishRequest$Type extends MessageType<PuzzleFinishRequest> {
    constructor() {
        super("PuzzleFinishRequest", [
            { no: 1, name: "elementId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PuzzleFinishRequest>): PuzzleFinishRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PuzzleFinishRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PuzzleFinishRequest): PuzzleFinishRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 elementId */ 1:
                    message.elementId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PuzzleFinishRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 elementId = 1; */
        if (message.elementId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.elementId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PuzzleFinishRequest
 */
export const PuzzleFinishRequest = new PuzzleFinishRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RewardPointInfo$Type extends MessageType<RewardPointInfo> {
    constructor() {
        super("RewardPointInfo", [
            { no: 1, name: "chapterId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "rewardPoint", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "hasGetPointRewardIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RewardPointInfo>): RewardPointInfo {
        const message = { hasGetPointRewardIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RewardPointInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RewardPointInfo): RewardPointInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterId */ 1:
                    message.chapterId = reader.int32();
                    break;
                case /* optional int32 rewardPoint */ 2:
                    message.rewardPoint = reader.int32();
                    break;
                case /* repeated int32 hasGetPointRewardIds */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.hasGetPointRewardIds.push(reader.int32());
                    else
                        message.hasGetPointRewardIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RewardPointInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterId = 1; */
        if (message.chapterId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterId);
        /* optional int32 rewardPoint = 2; */
        if (message.rewardPoint !== undefined)
            writer.tag(2, WireType.Varint).int32(message.rewardPoint);
        /* repeated int32 hasGetPointRewardIds = 3; */
        for (let i = 0; i < message.hasGetPointRewardIds.length; i++)
            writer.tag(3, WireType.Varint).int32(message.hasGetPointRewardIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RewardPointInfo
 */
export const RewardPointInfo = new RewardPointInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstructionDungeonInfoRequest$Type extends MessageType<InstructionDungeonInfoRequest> {
    constructor() {
        super("InstructionDungeonInfoRequest", []);
    }
    create(value?: PartialMessage<InstructionDungeonInfoRequest>): InstructionDungeonInfoRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InstructionDungeonInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstructionDungeonInfoRequest): InstructionDungeonInfoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: InstructionDungeonInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message InstructionDungeonInfoRequest
 */
export const InstructionDungeonInfoRequest = new InstructionDungeonInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PuzzleFinishReply$Type extends MessageType<PuzzleFinishReply> {
    constructor() {
        super("PuzzleFinishReply", [
            { no: 1, name: "elementId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PuzzleFinishReply>): PuzzleFinishReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PuzzleFinishReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PuzzleFinishReply): PuzzleFinishReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 elementId */ 1:
                    message.elementId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PuzzleFinishReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 elementId = 1; */
        if (message.elementId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.elementId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PuzzleFinishReply
 */
export const PuzzleFinishReply = new PuzzleFinishReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChapterMapElementUpdatePush$Type extends MessageType<ChapterMapElementUpdatePush> {
    constructor() {
        super("ChapterMapElementUpdatePush", [
            { no: 1, name: "elements", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChapterMapElementUpdatePush>): ChapterMapElementUpdatePush {
        const message = { elements: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChapterMapElementUpdatePush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChapterMapElementUpdatePush): ChapterMapElementUpdatePush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 elements */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.elements.push(reader.int32());
                    else
                        message.elements.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChapterMapElementUpdatePush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 elements = 1; */
        for (let i = 0; i < message.elements.length; i++)
            writer.tag(1, WireType.Varint).int32(message.elements[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChapterMapElementUpdatePush
 */
export const ChapterMapElementUpdatePush = new ChapterMapElementUpdatePush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetPointRewardRequest$Type extends MessageType<GetPointRewardRequest> {
    constructor() {
        super("GetPointRewardRequest", [
            { no: 1, name: "id", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetPointRewardRequest>): GetPointRewardRequest {
        const message = { id: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetPointRewardRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetPointRewardRequest): GetPointRewardRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 id */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.id.push(reader.int32());
                    else
                        message.id.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetPointRewardRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 id = 1; */
        for (let i = 0; i < message.id.length; i++)
            writer.tag(1, WireType.Varint).int32(message.id[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetPointRewardRequest
 */
export const GetPointRewardRequest = new GetPointRewardRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstructionDungeonRewardReply$Type extends MessageType<InstructionDungeonRewardReply> {
    constructor() {
        super("InstructionDungeonRewardReply", []);
    }
    create(value?: PartialMessage<InstructionDungeonRewardReply>): InstructionDungeonRewardReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InstructionDungeonRewardReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstructionDungeonRewardReply): InstructionDungeonRewardReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: InstructionDungeonRewardReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message InstructionDungeonRewardReply
 */
export const InstructionDungeonRewardReply = new InstructionDungeonRewardReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetEpisodeHeroRecommendReply$Type extends MessageType<GetEpisodeHeroRecommendReply> {
    constructor() {
        super("GetEpisodeHeroRecommendReply", [
            { no: 1, name: "racommends", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => EpisodeHeroRecommendInfo }
        ]);
    }
    create(value?: PartialMessage<GetEpisodeHeroRecommendReply>): GetEpisodeHeroRecommendReply {
        const message = { racommends: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetEpisodeHeroRecommendReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetEpisodeHeroRecommendReply): GetEpisodeHeroRecommendReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated EpisodeHeroRecommendInfo racommends */ 1:
                    message.racommends.push(EpisodeHeroRecommendInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetEpisodeHeroRecommendReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated EpisodeHeroRecommendInfo racommends = 1; */
        for (let i = 0; i < message.racommends.length; i++)
            EpisodeHeroRecommendInfo.internalBinaryWrite(message.racommends[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetEpisodeHeroRecommendReply
 */
export const GetEpisodeHeroRecommendReply = new GetEpisodeHeroRecommendReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartDungeonRequest$Type extends MessageType<StartDungeonRequest> {
    constructor() {
        super("StartDungeonRequest", [
            { no: 1, name: "chapterId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "episodeId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "fightGroup", kind: "message", T: () => FightGroup },
            { no: 4, name: "multiplication", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "useRecord", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "isRestart", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<StartDungeonRequest>): StartDungeonRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StartDungeonRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartDungeonRequest): StartDungeonRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterId */ 1:
                    message.chapterId = reader.int32();
                    break;
                case /* optional int32 episodeId */ 2:
                    message.episodeId = reader.int32();
                    break;
                case /* optional FightGroup fightGroup */ 3:
                    message.fightGroup = FightGroup.internalBinaryRead(reader, reader.uint32(), options, message.fightGroup);
                    break;
                case /* optional int32 multiplication */ 4:
                    message.multiplication = reader.int32();
                    break;
                case /* optional bool useRecord */ 5:
                    message.useRecord = reader.bool();
                    break;
                case /* optional bool isRestart */ 6:
                    message.isRestart = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartDungeonRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterId = 1; */
        if (message.chapterId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterId);
        /* optional int32 episodeId = 2; */
        if (message.episodeId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.episodeId);
        /* optional FightGroup fightGroup = 3; */
        if (message.fightGroup)
            FightGroup.internalBinaryWrite(message.fightGroup, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 multiplication = 4; */
        if (message.multiplication !== undefined)
            writer.tag(4, WireType.Varint).int32(message.multiplication);
        /* optional bool useRecord = 5; */
        if (message.useRecord !== undefined)
            writer.tag(5, WireType.Varint).bool(message.useRecord);
        /* optional bool isRestart = 6; */
        if (message.isRestart !== undefined)
            writer.tag(6, WireType.Varint).bool(message.isRestart);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StartDungeonRequest
 */
export const StartDungeonRequest = new StartDungeonRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstructionDungeonInfoReply$Type extends MessageType<InstructionDungeonInfoReply> {
    constructor() {
        super("InstructionDungeonInfoReply", [
            { no: 1, name: "unlockIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "getRewardIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "getFinalReward", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "openIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<InstructionDungeonInfoReply>): InstructionDungeonInfoReply {
        const message = { unlockIds: [], getRewardIds: [], openIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<InstructionDungeonInfoReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstructionDungeonInfoReply): InstructionDungeonInfoReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 unlockIds */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unlockIds.push(reader.int32());
                    else
                        message.unlockIds.push(reader.int32());
                    break;
                case /* repeated int32 getRewardIds */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.getRewardIds.push(reader.int32());
                    else
                        message.getRewardIds.push(reader.int32());
                    break;
                case /* optional bool getFinalReward */ 3:
                    message.getFinalReward = reader.bool();
                    break;
                case /* repeated int32 openIds */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.openIds.push(reader.int32());
                    else
                        message.openIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InstructionDungeonInfoReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 unlockIds = 1; */
        for (let i = 0; i < message.unlockIds.length; i++)
            writer.tag(1, WireType.Varint).int32(message.unlockIds[i]);
        /* repeated int32 getRewardIds = 2; */
        for (let i = 0; i < message.getRewardIds.length; i++)
            writer.tag(2, WireType.Varint).int32(message.getRewardIds[i]);
        /* optional bool getFinalReward = 3; */
        if (message.getFinalReward !== undefined)
            writer.tag(3, WireType.Varint).bool(message.getFinalReward);
        /* repeated int32 openIds = 4; */
        for (let i = 0; i < message.openIds.length; i++)
            writer.tag(4, WireType.Varint).int32(message.openIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message InstructionDungeonInfoReply
 */
export const InstructionDungeonInfoReply = new InstructionDungeonInfoReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDungeonReply$Type extends MessageType<GetDungeonReply> {
    constructor() {
        super("GetDungeonReply", [
            { no: 1, name: "dungeonInfoList", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UserDungeon },
            { no: 2, name: "lastHeroGroup", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => DungeonLastHeroGroup },
            { no: 3, name: "mapIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "elements", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "rewardPointInfo", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RewardPointInfo },
            { no: 6, name: "equipSpChapters", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "chapterTypeNums", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UserChapterTypeNum },
            { no: 8, name: "finishElements", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "finishPuzzles", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetDungeonReply>): GetDungeonReply {
        const message = { dungeonInfoList: [], lastHeroGroup: [], mapIds: [], elements: [], rewardPointInfo: [], equipSpChapters: [], chapterTypeNums: [], finishElements: [], finishPuzzles: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetDungeonReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDungeonReply): GetDungeonReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated UserDungeon dungeonInfoList */ 1:
                    message.dungeonInfoList.push(UserDungeon.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated DungeonLastHeroGroup lastHeroGroup */ 2:
                    message.lastHeroGroup.push(DungeonLastHeroGroup.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated int32 mapIds */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.mapIds.push(reader.int32());
                    else
                        message.mapIds.push(reader.int32());
                    break;
                case /* repeated int32 elements */ 4:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.elements.push(reader.int32());
                    else
                        message.elements.push(reader.int32());
                    break;
                case /* repeated RewardPointInfo rewardPointInfo */ 5:
                    message.rewardPointInfo.push(RewardPointInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated int32 equipSpChapters */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.equipSpChapters.push(reader.int32());
                    else
                        message.equipSpChapters.push(reader.int32());
                    break;
                case /* repeated UserChapterTypeNum chapterTypeNums */ 7:
                    message.chapterTypeNums.push(UserChapterTypeNum.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated int32 finishElements */ 8:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.finishElements.push(reader.int32());
                    else
                        message.finishElements.push(reader.int32());
                    break;
                case /* repeated int32 finishPuzzles */ 9:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.finishPuzzles.push(reader.int32());
                    else
                        message.finishPuzzles.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDungeonReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated UserDungeon dungeonInfoList = 1; */
        for (let i = 0; i < message.dungeonInfoList.length; i++)
            UserDungeon.internalBinaryWrite(message.dungeonInfoList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated DungeonLastHeroGroup lastHeroGroup = 2; */
        for (let i = 0; i < message.lastHeroGroup.length; i++)
            DungeonLastHeroGroup.internalBinaryWrite(message.lastHeroGroup[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 mapIds = 3; */
        for (let i = 0; i < message.mapIds.length; i++)
            writer.tag(3, WireType.Varint).int32(message.mapIds[i]);
        /* repeated int32 elements = 4; */
        for (let i = 0; i < message.elements.length; i++)
            writer.tag(4, WireType.Varint).int32(message.elements[i]);
        /* repeated RewardPointInfo rewardPointInfo = 5; */
        for (let i = 0; i < message.rewardPointInfo.length; i++)
            RewardPointInfo.internalBinaryWrite(message.rewardPointInfo[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 equipSpChapters = 6; */
        for (let i = 0; i < message.equipSpChapters.length; i++)
            writer.tag(6, WireType.Varint).int32(message.equipSpChapters[i]);
        /* repeated UserChapterTypeNum chapterTypeNums = 7; */
        for (let i = 0; i < message.chapterTypeNums.length; i++)
            UserChapterTypeNum.internalBinaryWrite(message.chapterTypeNums[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 finishElements = 8; */
        for (let i = 0; i < message.finishElements.length; i++)
            writer.tag(8, WireType.Varint).int32(message.finishElements[i]);
        /* repeated int32 finishPuzzles = 9; */
        for (let i = 0; i < message.finishPuzzles.length; i++)
            writer.tag(9, WireType.Varint).int32(message.finishPuzzles[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetDungeonReply
 */
export const GetDungeonReply = new GetDungeonReply$Type();
