// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "adventure_module.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { FightGroup } from "./fight_def";
import { FightRound } from "./fight_def";
import { Fight } from "./fight_def";
import { HeroGroupInfo } from "./hero_def";
import { MaterialData } from "./material_module";
/**
 * @generated from protobuf message AdventureTaskSubmitReply
 */
export interface AdventureTaskSubmitReply {
    /**
     * @generated from protobuf field: optional int32 taskId = 1;
     */
    taskId?: number;
}
/**
 * @generated from protobuf message AdventureGeneralRequest
 */
export interface AdventureGeneralRequest {
    /**
     * @generated from protobuf field: optional int32 chapterType = 1;
     */
    chapterType?: number;
    /**
     * @generated from protobuf field: optional int32 id = 2;
     */
    id?: number;
}
/**
 * @generated from protobuf message AdventureForeverInfo
 */
export interface AdventureForeverInfo {
    /**
     * @generated from protobuf field: optional int32 mapId = 1;
     */
    mapId?: number;
    /**
     * @generated from protobuf field: optional int32 interactType = 2;
     */
    interactType?: number;
    /**
     * @generated from protobuf field: optional int32 finishCount = 3;
     */
    finishCount?: number;
}
/**
 * @generated from protobuf message AdventureGateRequest
 */
export interface AdventureGateRequest {
    /**
     * @generated from protobuf field: optional int32 chapterType = 1;
     */
    chapterType?: number;
    /**
     * @generated from protobuf field: optional int32 id = 2;
     */
    id?: number;
}
/**
 * @generated from protobuf message AdventureGateReply
 */
export interface AdventureGateReply {
    /**
     * @generated from protobuf field: optional int32 chapterType = 1;
     */
    chapterType?: number;
    /**
     * @generated from protobuf field: optional int32 id = 2;
     */
    id?: number;
}
/**
 * @generated from protobuf message AdventureBonusReply
 */
export interface AdventureBonusReply {
    /**
     * @generated from protobuf field: optional int32 chapterType = 1;
     */
    chapterType?: number;
    /**
     * @generated from protobuf field: optional int32 id = 2;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional AdventureInfo adventureInfo = 3;
     */
    adventureInfo?: AdventureInfo;
}
/**
 * @generated from protobuf message AdventureInteractSetStatusRequest
 */
export interface AdventureInteractSetStatusRequest {
    /**
     * @generated from protobuf field: optional int32 chapterType = 1;
     */
    chapterType?: number;
    /**
     * @generated from protobuf field: optional int32 type = 2;
     */
    type?: number;
    /**
     * @generated from protobuf field: optional int32 id = 3;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional int32 status = 4;
     */
    status?: number;
}
/**
 * @generated from protobuf message AdventureMoveReply
 */
export interface AdventureMoveReply {
}
/**
 * @generated from protobuf message AdventureInteractSetStatusReply
 */
export interface AdventureInteractSetStatusReply {
    /**
     * @generated from protobuf field: optional int32 chapterType = 1;
     */
    chapterType?: number;
    /**
     * @generated from protobuf field: optional int32 type = 2;
     */
    type?: number;
    /**
     * @generated from protobuf field: optional int32 id = 3;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional int32 status = 4;
     */
    status?: number;
}
/**
 * @generated from protobuf message AdventureMagicReply
 */
export interface AdventureMagicReply {
    /**
     * @generated from protobuf field: optional int32 chapterType = 1;
     */
    chapterType?: number;
    /**
     * @generated from protobuf field: optional int32 id = 2;
     */
    id?: number;
}
/**
 * @generated from protobuf message AdventureInfo
 */
export interface AdventureInfo {
    /**
     * @generated from protobuf field: optional int32 chapterType = 1;
     */
    chapterType?: number;
    /**
     * @generated from protobuf field: optional int32 episodeId = 2;
     */
    episodeId?: number;
    /**
     * @generated from protobuf field: optional int32 posx = 3;
     */
    posx?: number;
    /**
     * @generated from protobuf field: optional int32 posy = 4;
     */
    posy?: number;
    /**
     * @generated from protobuf field: repeated AdventureInteract interact = 5;
     */
    interact: AdventureInteract[];
    /**
     * @generated from protobuf field: repeated MaterialData mapBackpack = 6;
     */
    mapBackpack: MaterialData[];
    /**
     * @generated from protobuf field: repeated AdventureTask taskInfos = 7;
     */
    taskInfos: AdventureTask[];
    /**
     * @generated from protobuf field: repeated AdventureAreaSight areaSights = 8;
     */
    areaSights: AdventureAreaSight[];
    /**
     * @generated from protobuf field: optional int32 lastInteractType = 9;
     */
    lastInteractType?: number;
    /**
     * @generated from protobuf field: optional int32 lastInteract = 10;
     */
    lastInteract?: number;
    /**
     * @generated from protobuf field: repeated AdventureBattleInfo battleInfos = 11;
     */
    battleInfos: AdventureBattleInfo[];
    /**
     * @generated from protobuf field: repeated AdventureHeroHp heroHps = 12;
     */
    heroHps: AdventureHeroHp[];
    /**
     * @generated from protobuf field: repeated int32 buffIds = 13;
     */
    buffIds: number[];
    /**
     * @generated from protobuf field: optional HeroGroupInfo heroGroupSnapshot = 14;
     */
    heroGroupSnapshot?: HeroGroupInfo;
    /**
     * @generated from protobuf field: optional int32 magicRandomSeed = 15;
     */
    magicRandomSeed?: number;
    /**
     * @generated from protobuf field: repeated int32 unSelectBuffIds = 16;
     */
    unSelectBuffIds: number[];
}
/**
 * @generated from protobuf message AdventureHeroHp
 */
export interface AdventureHeroHp {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
    /**
     * @generated from protobuf field: optional int32 hp = 2;
     */
    hp?: number;
    /**
     * @generated from protobuf field: optional int32 buff = 3;
     */
    buff?: number;
}
/**
 * @generated from protobuf message AdventureInteractClientFinishRequest
 */
export interface AdventureInteractClientFinishRequest {
    /**
     * @generated from protobuf field: optional int32 chapterType = 1;
     */
    chapterType?: number;
}
/**
 * @generated from protobuf message AdventureBattleReply
 */
export interface AdventureBattleReply {
    /**
     * @generated from protobuf field: optional int32 chapterType = 1;
     */
    chapterType?: number;
    /**
     * @generated from protobuf field: optional int32 id = 2;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional Fight fight = 3;
     */
    fight?: Fight;
    /**
     * @generated from protobuf field: optional FightRound round = 4;
     */
    round?: FightRound;
}
/**
 * @generated from protobuf message AdventureStoryRequest
 */
export interface AdventureStoryRequest {
    /**
     * @generated from protobuf field: optional int32 chapterType = 1;
     */
    chapterType?: number;
    /**
     * @generated from protobuf field: optional int32 id = 2;
     */
    id?: number;
}
/**
 * @generated from protobuf message AdventureBuffRandomPush
 */
export interface AdventureBuffRandomPush {
    /**
     * @generated from protobuf field: optional int32 chapterType = 1;
     */
    chapterType?: number;
    /**
     * @generated from protobuf field: repeated int32 buffIds = 2;
     */
    buffIds: number[];
}
/**
 * @generated from protobuf message AdventureInteract
 */
export interface AdventureInteract {
    /**
     * @generated from protobuf field: optional int32 type = 1;
     */
    type?: number;
    /**
     * @generated from protobuf field: optional int32 id = 2;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional int32 status = 3;
     */
    status?: number;
    /**
     * @generated from protobuf field: optional bool interact = 4;
     */
    interact?: boolean;
}
/**
 * @generated from protobuf message AdventureBattleMonsterHp
 */
export interface AdventureBattleMonsterHp {
    /**
     * @generated from protobuf field: repeated int32 hp = 1;
     */
    hp: number[];
}
/**
 * @generated from protobuf message StartAdventurePush
 */
export interface StartAdventurePush {
    /**
     * @generated from protobuf field: optional AdventureInfo adventureInfo = 1;
     */
    adventureInfo?: AdventureInfo;
}
/**
 * @generated from protobuf message AdventureBattleInfo
 */
export interface AdventureBattleInfo {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
    /**
     * @generated from protobuf field: repeated AdventureBattleMonsterHp monsterHps = 2;
     */
    monsterHps: AdventureBattleMonsterHp[];
}
/**
 * @generated from protobuf message AdventureTaskUpdatePush
 */
export interface AdventureTaskUpdatePush {
    /**
     * @generated from protobuf field: repeated AdventureTask taskInfos = 1;
     */
    taskInfos: AdventureTask[];
}
/**
 * @generated from protobuf message AdventureTask
 */
export interface AdventureTask {
    /**
     * @generated from protobuf field: optional int32 taskId = 1;
     */
    taskId?: number;
    /**
     * @generated from protobuf field: optional int32 progress = 2;
     */
    progress?: number;
    /**
     * @generated from protobuf field: optional bool hasGetBonus = 3;
     */
    hasGetBonus?: boolean;
    /**
     * @generated from protobuf field: optional bool isFinish = 4;
     */
    isFinish?: boolean;
}
/**
 * @generated from protobuf message AdventureSeat
 */
export interface AdventureSeat {
    /**
     * @generated from protobuf field: optional int32 areaId = 1;
     */
    areaId?: number;
    /**
     * @generated from protobuf field: optional int32 x = 2;
     */
    x?: number;
    /**
     * @generated from protobuf field: optional int32 y = 3;
     */
    y?: number;
}
/**
 * @generated from protobuf message AdventureAreaSight
 */
export interface AdventureAreaSight {
    /**
     * @generated from protobuf field: optional int32 areaId = 1;
     */
    areaId?: number;
    /**
     * @generated from protobuf field: optional bytes sight = 2;
     */
    sight?: Uint8Array;
    /**
     * @generated from protobuf field: optional bool visible = 3;
     */
    visible?: boolean;
}
/**
 * @generated from protobuf message AdventureTaskSubmitRequest
 */
export interface AdventureTaskSubmitRequest {
    /**
     * @generated from protobuf field: optional int32 taskId = 1;
     */
    taskId?: number;
    /**
     * @generated from protobuf field: repeated MaterialData materialData = 2;
     */
    materialData: MaterialData[];
}
/**
 * @generated from protobuf message AdventureBuffReply
 */
export interface AdventureBuffReply {
    /**
     * @generated from protobuf field: optional int32 chapterType = 1;
     */
    chapterType?: number;
    /**
     * @generated from protobuf field: optional int32 selectBuff = 3;
     */
    selectBuff?: number;
    /**
     * @generated from protobuf field: optional int32 heroId = 4;
     */
    heroId?: number;
}
/**
 * @generated from protobuf message AdventureBattleRequest
 */
export interface AdventureBattleRequest {
    /**
     * @generated from protobuf field: optional int32 chapterType = 1;
     */
    chapterType?: number;
    /**
     * @generated from protobuf field: optional int32 id = 2;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional FightGroup fightGroup = 3;
     */
    fightGroup?: FightGroup;
}
/**
 * @generated from protobuf message AdventureSetAreaVisibleReply
 */
export interface AdventureSetAreaVisibleReply {
    /**
     * @generated from protobuf field: optional int32 chapterType = 1;
     */
    chapterType?: number;
    /**
     * @generated from protobuf field: optional int32 areaId = 2;
     */
    areaId?: number;
    /**
     * @generated from protobuf field: optional bool visible = 3;
     */
    visible?: boolean;
}
/**
 * @generated from protobuf message AdventureInteractClientFinishReply
 */
export interface AdventureInteractClientFinishReply {
}
/**
 * @generated from protobuf message GetAdventureInfoRequest
 */
export interface GetAdventureInfoRequest {
}
/**
 * @generated from protobuf message AdventureBonusRequest
 */
export interface AdventureBonusRequest {
    /**
     * @generated from protobuf field: optional int32 chapterType = 1;
     */
    chapterType?: number;
    /**
     * @generated from protobuf field: optional int32 id = 2;
     */
    id?: number;
}
/**
 * @generated from protobuf message AdventureSetAreaVisibleRequest
 */
export interface AdventureSetAreaVisibleRequest {
    /**
     * @generated from protobuf field: optional int32 chapterType = 1;
     */
    chapterType?: number;
    /**
     * @generated from protobuf field: optional int32 areaId = 2;
     */
    areaId?: number;
    /**
     * @generated from protobuf field: optional bool visible = 3;
     */
    visible?: boolean;
}
/**
 * @generated from protobuf message AdventureBuffRequest
 */
export interface AdventureBuffRequest {
    /**
     * @generated from protobuf field: optional int32 chapterType = 1;
     */
    chapterType?: number;
    /**
     * @generated from protobuf field: optional int32 selectBuff = 3;
     */
    selectBuff?: number;
    /**
     * @generated from protobuf field: optional int32 heroId = 4;
     */
    heroId?: number;
}
/**
 * @generated from protobuf message AdventureGeneralReply
 */
export interface AdventureGeneralReply {
    /**
     * @generated from protobuf field: optional int32 chapterType = 1;
     */
    chapterType?: number;
    /**
     * @generated from protobuf field: optional int32 id = 2;
     */
    id?: number;
}
/**
 * @generated from protobuf message GetAdventureInfoReply
 */
export interface GetAdventureInfoReply {
    /**
     * @generated from protobuf field: repeated AdventureInfo adventureInfo = 1;
     */
    adventureInfo: AdventureInfo[];
    /**
     * @generated from protobuf field: repeated AdventureForeverInfo foreverInfos = 12;
     */
    foreverInfos: AdventureForeverInfo[];
}
/**
 * @generated from protobuf message AdventureRespawnReply
 */
export interface AdventureRespawnReply {
    /**
     * @generated from protobuf field: optional int32 chapterType = 1;
     */
    chapterType?: number;
    /**
     * @generated from protobuf field: optional int32 id = 2;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional int32 heroId = 3;
     */
    heroId?: number;
}
/**
 * @generated from protobuf message AdventureMoveRequest
 */
export interface AdventureMoveRequest {
    /**
     * @generated from protobuf field: optional int32 chapterType = 1;
     */
    chapterType?: number;
    /**
     * @generated from protobuf field: optional int32 posx = 2;
     */
    posx?: number;
    /**
     * @generated from protobuf field: optional int32 posy = 3;
     */
    posy?: number;
    /**
     * @generated from protobuf field: repeated AdventureSeat sightChange = 4;
     */
    sightChange: AdventureSeat[];
}
/**
 * @generated from protobuf message AdventureStoryReply
 */
export interface AdventureStoryReply {
    /**
     * @generated from protobuf field: optional int32 chapterType = 1;
     */
    chapterType?: number;
    /**
     * @generated from protobuf field: optional int32 id = 2;
     */
    id?: number;
}
/**
 * @generated from protobuf message AdventureMagicRequest
 */
export interface AdventureMagicRequest {
    /**
     * @generated from protobuf field: optional int32 chapterType = 1;
     */
    chapterType?: number;
    /**
     * @generated from protobuf field: optional int32 id = 2;
     */
    id?: number;
}
/**
 * @generated from protobuf message AdventureRespawnRequest
 */
export interface AdventureRespawnRequest {
    /**
     * @generated from protobuf field: optional int32 chapterType = 1;
     */
    chapterType?: number;
    /**
     * @generated from protobuf field: optional int32 id = 2;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional int32 heroId = 3;
     */
    heroId?: number;
}
// @generated message type with reflection information, may provide speed optimized methods
class AdventureTaskSubmitReply$Type extends MessageType<AdventureTaskSubmitReply> {
    constructor() {
        super("AdventureTaskSubmitReply", [
            { no: 1, name: "taskId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureTaskSubmitReply>): AdventureTaskSubmitReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureTaskSubmitReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureTaskSubmitReply): AdventureTaskSubmitReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 taskId */ 1:
                    message.taskId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureTaskSubmitReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 taskId = 1; */
        if (message.taskId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.taskId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureTaskSubmitReply
 */
export const AdventureTaskSubmitReply = new AdventureTaskSubmitReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureGeneralRequest$Type extends MessageType<AdventureGeneralRequest> {
    constructor() {
        super("AdventureGeneralRequest", [
            { no: 1, name: "chapterType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureGeneralRequest>): AdventureGeneralRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureGeneralRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureGeneralRequest): AdventureGeneralRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterType */ 1:
                    message.chapterType = reader.int32();
                    break;
                case /* optional int32 id */ 2:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureGeneralRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterType = 1; */
        if (message.chapterType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterType);
        /* optional int32 id = 2; */
        if (message.id !== undefined)
            writer.tag(2, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureGeneralRequest
 */
export const AdventureGeneralRequest = new AdventureGeneralRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureForeverInfo$Type extends MessageType<AdventureForeverInfo> {
    constructor() {
        super("AdventureForeverInfo", [
            { no: 1, name: "mapId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "interactType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "finishCount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureForeverInfo>): AdventureForeverInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureForeverInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureForeverInfo): AdventureForeverInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 mapId */ 1:
                    message.mapId = reader.int32();
                    break;
                case /* optional int32 interactType */ 2:
                    message.interactType = reader.int32();
                    break;
                case /* optional int32 finishCount */ 3:
                    message.finishCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureForeverInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 mapId = 1; */
        if (message.mapId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.mapId);
        /* optional int32 interactType = 2; */
        if (message.interactType !== undefined)
            writer.tag(2, WireType.Varint).int32(message.interactType);
        /* optional int32 finishCount = 3; */
        if (message.finishCount !== undefined)
            writer.tag(3, WireType.Varint).int32(message.finishCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureForeverInfo
 */
export const AdventureForeverInfo = new AdventureForeverInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureGateRequest$Type extends MessageType<AdventureGateRequest> {
    constructor() {
        super("AdventureGateRequest", [
            { no: 1, name: "chapterType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureGateRequest>): AdventureGateRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureGateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureGateRequest): AdventureGateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterType */ 1:
                    message.chapterType = reader.int32();
                    break;
                case /* optional int32 id */ 2:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureGateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterType = 1; */
        if (message.chapterType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterType);
        /* optional int32 id = 2; */
        if (message.id !== undefined)
            writer.tag(2, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureGateRequest
 */
export const AdventureGateRequest = new AdventureGateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureGateReply$Type extends MessageType<AdventureGateReply> {
    constructor() {
        super("AdventureGateReply", [
            { no: 1, name: "chapterType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureGateReply>): AdventureGateReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureGateReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureGateReply): AdventureGateReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterType */ 1:
                    message.chapterType = reader.int32();
                    break;
                case /* optional int32 id */ 2:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureGateReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterType = 1; */
        if (message.chapterType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterType);
        /* optional int32 id = 2; */
        if (message.id !== undefined)
            writer.tag(2, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureGateReply
 */
export const AdventureGateReply = new AdventureGateReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureBonusReply$Type extends MessageType<AdventureBonusReply> {
    constructor() {
        super("AdventureBonusReply", [
            { no: 1, name: "chapterType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "adventureInfo", kind: "message", T: () => AdventureInfo }
        ]);
    }
    create(value?: PartialMessage<AdventureBonusReply>): AdventureBonusReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureBonusReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureBonusReply): AdventureBonusReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterType */ 1:
                    message.chapterType = reader.int32();
                    break;
                case /* optional int32 id */ 2:
                    message.id = reader.int32();
                    break;
                case /* optional AdventureInfo adventureInfo */ 3:
                    message.adventureInfo = AdventureInfo.internalBinaryRead(reader, reader.uint32(), options, message.adventureInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureBonusReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterType = 1; */
        if (message.chapterType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterType);
        /* optional int32 id = 2; */
        if (message.id !== undefined)
            writer.tag(2, WireType.Varint).int32(message.id);
        /* optional AdventureInfo adventureInfo = 3; */
        if (message.adventureInfo)
            AdventureInfo.internalBinaryWrite(message.adventureInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureBonusReply
 */
export const AdventureBonusReply = new AdventureBonusReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureInteractSetStatusRequest$Type extends MessageType<AdventureInteractSetStatusRequest> {
    constructor() {
        super("AdventureInteractSetStatusRequest", [
            { no: 1, name: "chapterType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "status", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureInteractSetStatusRequest>): AdventureInteractSetStatusRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureInteractSetStatusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureInteractSetStatusRequest): AdventureInteractSetStatusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterType */ 1:
                    message.chapterType = reader.int32();
                    break;
                case /* optional int32 type */ 2:
                    message.type = reader.int32();
                    break;
                case /* optional int32 id */ 3:
                    message.id = reader.int32();
                    break;
                case /* optional int32 status */ 4:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureInteractSetStatusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterType = 1; */
        if (message.chapterType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterType);
        /* optional int32 type = 2; */
        if (message.type !== undefined)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* optional int32 id = 3; */
        if (message.id !== undefined)
            writer.tag(3, WireType.Varint).int32(message.id);
        /* optional int32 status = 4; */
        if (message.status !== undefined)
            writer.tag(4, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureInteractSetStatusRequest
 */
export const AdventureInteractSetStatusRequest = new AdventureInteractSetStatusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureMoveReply$Type extends MessageType<AdventureMoveReply> {
    constructor() {
        super("AdventureMoveReply", []);
    }
    create(value?: PartialMessage<AdventureMoveReply>): AdventureMoveReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureMoveReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureMoveReply): AdventureMoveReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: AdventureMoveReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureMoveReply
 */
export const AdventureMoveReply = new AdventureMoveReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureInteractSetStatusReply$Type extends MessageType<AdventureInteractSetStatusReply> {
    constructor() {
        super("AdventureInteractSetStatusReply", [
            { no: 1, name: "chapterType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "status", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureInteractSetStatusReply>): AdventureInteractSetStatusReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureInteractSetStatusReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureInteractSetStatusReply): AdventureInteractSetStatusReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterType */ 1:
                    message.chapterType = reader.int32();
                    break;
                case /* optional int32 type */ 2:
                    message.type = reader.int32();
                    break;
                case /* optional int32 id */ 3:
                    message.id = reader.int32();
                    break;
                case /* optional int32 status */ 4:
                    message.status = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureInteractSetStatusReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterType = 1; */
        if (message.chapterType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterType);
        /* optional int32 type = 2; */
        if (message.type !== undefined)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* optional int32 id = 3; */
        if (message.id !== undefined)
            writer.tag(3, WireType.Varint).int32(message.id);
        /* optional int32 status = 4; */
        if (message.status !== undefined)
            writer.tag(4, WireType.Varint).int32(message.status);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureInteractSetStatusReply
 */
export const AdventureInteractSetStatusReply = new AdventureInteractSetStatusReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureMagicReply$Type extends MessageType<AdventureMagicReply> {
    constructor() {
        super("AdventureMagicReply", [
            { no: 1, name: "chapterType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureMagicReply>): AdventureMagicReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureMagicReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureMagicReply): AdventureMagicReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterType */ 1:
                    message.chapterType = reader.int32();
                    break;
                case /* optional int32 id */ 2:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureMagicReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterType = 1; */
        if (message.chapterType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterType);
        /* optional int32 id = 2; */
        if (message.id !== undefined)
            writer.tag(2, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureMagicReply
 */
export const AdventureMagicReply = new AdventureMagicReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureInfo$Type extends MessageType<AdventureInfo> {
    constructor() {
        super("AdventureInfo", [
            { no: 1, name: "chapterType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "episodeId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "posx", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "posy", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "interact", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AdventureInteract },
            { no: 6, name: "mapBackpack", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MaterialData },
            { no: 7, name: "taskInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AdventureTask },
            { no: 8, name: "areaSights", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AdventureAreaSight },
            { no: 9, name: "lastInteractType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "lastInteract", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "battleInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AdventureBattleInfo },
            { no: 12, name: "heroHps", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AdventureHeroHp },
            { no: 13, name: "buffIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "heroGroupSnapshot", kind: "message", T: () => HeroGroupInfo },
            { no: 15, name: "magicRandomSeed", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 16, name: "unSelectBuffIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureInfo>): AdventureInfo {
        const message = { interact: [], mapBackpack: [], taskInfos: [], areaSights: [], battleInfos: [], heroHps: [], buffIds: [], unSelectBuffIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureInfo): AdventureInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterType */ 1:
                    message.chapterType = reader.int32();
                    break;
                case /* optional int32 episodeId */ 2:
                    message.episodeId = reader.int32();
                    break;
                case /* optional int32 posx */ 3:
                    message.posx = reader.int32();
                    break;
                case /* optional int32 posy */ 4:
                    message.posy = reader.int32();
                    break;
                case /* repeated AdventureInteract interact */ 5:
                    message.interact.push(AdventureInteract.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated MaterialData mapBackpack */ 6:
                    message.mapBackpack.push(MaterialData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated AdventureTask taskInfos */ 7:
                    message.taskInfos.push(AdventureTask.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated AdventureAreaSight areaSights */ 8:
                    message.areaSights.push(AdventureAreaSight.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 lastInteractType */ 9:
                    message.lastInteractType = reader.int32();
                    break;
                case /* optional int32 lastInteract */ 10:
                    message.lastInteract = reader.int32();
                    break;
                case /* repeated AdventureBattleInfo battleInfos */ 11:
                    message.battleInfos.push(AdventureBattleInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated AdventureHeroHp heroHps */ 12:
                    message.heroHps.push(AdventureHeroHp.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated int32 buffIds */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.buffIds.push(reader.int32());
                    else
                        message.buffIds.push(reader.int32());
                    break;
                case /* optional HeroGroupInfo heroGroupSnapshot */ 14:
                    message.heroGroupSnapshot = HeroGroupInfo.internalBinaryRead(reader, reader.uint32(), options, message.heroGroupSnapshot);
                    break;
                case /* optional int32 magicRandomSeed */ 15:
                    message.magicRandomSeed = reader.int32();
                    break;
                case /* repeated int32 unSelectBuffIds */ 16:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unSelectBuffIds.push(reader.int32());
                    else
                        message.unSelectBuffIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterType = 1; */
        if (message.chapterType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterType);
        /* optional int32 episodeId = 2; */
        if (message.episodeId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.episodeId);
        /* optional int32 posx = 3; */
        if (message.posx !== undefined)
            writer.tag(3, WireType.Varint).int32(message.posx);
        /* optional int32 posy = 4; */
        if (message.posy !== undefined)
            writer.tag(4, WireType.Varint).int32(message.posy);
        /* repeated AdventureInteract interact = 5; */
        for (let i = 0; i < message.interact.length; i++)
            AdventureInteract.internalBinaryWrite(message.interact[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated MaterialData mapBackpack = 6; */
        for (let i = 0; i < message.mapBackpack.length; i++)
            MaterialData.internalBinaryWrite(message.mapBackpack[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated AdventureTask taskInfos = 7; */
        for (let i = 0; i < message.taskInfos.length; i++)
            AdventureTask.internalBinaryWrite(message.taskInfos[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* repeated AdventureAreaSight areaSights = 8; */
        for (let i = 0; i < message.areaSights.length; i++)
            AdventureAreaSight.internalBinaryWrite(message.areaSights[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 lastInteractType = 9; */
        if (message.lastInteractType !== undefined)
            writer.tag(9, WireType.Varint).int32(message.lastInteractType);
        /* optional int32 lastInteract = 10; */
        if (message.lastInteract !== undefined)
            writer.tag(10, WireType.Varint).int32(message.lastInteract);
        /* repeated AdventureBattleInfo battleInfos = 11; */
        for (let i = 0; i < message.battleInfos.length; i++)
            AdventureBattleInfo.internalBinaryWrite(message.battleInfos[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated AdventureHeroHp heroHps = 12; */
        for (let i = 0; i < message.heroHps.length; i++)
            AdventureHeroHp.internalBinaryWrite(message.heroHps[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 buffIds = 13; */
        for (let i = 0; i < message.buffIds.length; i++)
            writer.tag(13, WireType.Varint).int32(message.buffIds[i]);
        /* optional HeroGroupInfo heroGroupSnapshot = 14; */
        if (message.heroGroupSnapshot)
            HeroGroupInfo.internalBinaryWrite(message.heroGroupSnapshot, writer.tag(14, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 magicRandomSeed = 15; */
        if (message.magicRandomSeed !== undefined)
            writer.tag(15, WireType.Varint).int32(message.magicRandomSeed);
        /* repeated int32 unSelectBuffIds = 16; */
        for (let i = 0; i < message.unSelectBuffIds.length; i++)
            writer.tag(16, WireType.Varint).int32(message.unSelectBuffIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureInfo
 */
export const AdventureInfo = new AdventureInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureHeroHp$Type extends MessageType<AdventureHeroHp> {
    constructor() {
        super("AdventureHeroHp", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "hp", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "buff", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureHeroHp>): AdventureHeroHp {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureHeroHp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureHeroHp): AdventureHeroHp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                case /* optional int32 hp */ 2:
                    message.hp = reader.int32();
                    break;
                case /* optional int32 buff */ 3:
                    message.buff = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureHeroHp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        /* optional int32 hp = 2; */
        if (message.hp !== undefined)
            writer.tag(2, WireType.Varint).int32(message.hp);
        /* optional int32 buff = 3; */
        if (message.buff !== undefined)
            writer.tag(3, WireType.Varint).int32(message.buff);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureHeroHp
 */
export const AdventureHeroHp = new AdventureHeroHp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureInteractClientFinishRequest$Type extends MessageType<AdventureInteractClientFinishRequest> {
    constructor() {
        super("AdventureInteractClientFinishRequest", [
            { no: 1, name: "chapterType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureInteractClientFinishRequest>): AdventureInteractClientFinishRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureInteractClientFinishRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureInteractClientFinishRequest): AdventureInteractClientFinishRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterType */ 1:
                    message.chapterType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureInteractClientFinishRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterType = 1; */
        if (message.chapterType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureInteractClientFinishRequest
 */
export const AdventureInteractClientFinishRequest = new AdventureInteractClientFinishRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureBattleReply$Type extends MessageType<AdventureBattleReply> {
    constructor() {
        super("AdventureBattleReply", [
            { no: 1, name: "chapterType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "fight", kind: "message", T: () => Fight },
            { no: 4, name: "round", kind: "message", T: () => FightRound }
        ]);
    }
    create(value?: PartialMessage<AdventureBattleReply>): AdventureBattleReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureBattleReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureBattleReply): AdventureBattleReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterType */ 1:
                    message.chapterType = reader.int32();
                    break;
                case /* optional int32 id */ 2:
                    message.id = reader.int32();
                    break;
                case /* optional Fight fight */ 3:
                    message.fight = Fight.internalBinaryRead(reader, reader.uint32(), options, message.fight);
                    break;
                case /* optional FightRound round */ 4:
                    message.round = FightRound.internalBinaryRead(reader, reader.uint32(), options, message.round);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureBattleReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterType = 1; */
        if (message.chapterType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterType);
        /* optional int32 id = 2; */
        if (message.id !== undefined)
            writer.tag(2, WireType.Varint).int32(message.id);
        /* optional Fight fight = 3; */
        if (message.fight)
            Fight.internalBinaryWrite(message.fight, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional FightRound round = 4; */
        if (message.round)
            FightRound.internalBinaryWrite(message.round, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureBattleReply
 */
export const AdventureBattleReply = new AdventureBattleReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureStoryRequest$Type extends MessageType<AdventureStoryRequest> {
    constructor() {
        super("AdventureStoryRequest", [
            { no: 1, name: "chapterType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureStoryRequest>): AdventureStoryRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureStoryRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureStoryRequest): AdventureStoryRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterType */ 1:
                    message.chapterType = reader.int32();
                    break;
                case /* optional int32 id */ 2:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureStoryRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterType = 1; */
        if (message.chapterType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterType);
        /* optional int32 id = 2; */
        if (message.id !== undefined)
            writer.tag(2, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureStoryRequest
 */
export const AdventureStoryRequest = new AdventureStoryRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureBuffRandomPush$Type extends MessageType<AdventureBuffRandomPush> {
    constructor() {
        super("AdventureBuffRandomPush", [
            { no: 1, name: "chapterType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "buffIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureBuffRandomPush>): AdventureBuffRandomPush {
        const message = { buffIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureBuffRandomPush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureBuffRandomPush): AdventureBuffRandomPush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterType */ 1:
                    message.chapterType = reader.int32();
                    break;
                case /* repeated int32 buffIds */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.buffIds.push(reader.int32());
                    else
                        message.buffIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureBuffRandomPush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterType = 1; */
        if (message.chapterType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterType);
        /* repeated int32 buffIds = 2; */
        for (let i = 0; i < message.buffIds.length; i++)
            writer.tag(2, WireType.Varint).int32(message.buffIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureBuffRandomPush
 */
export const AdventureBuffRandomPush = new AdventureBuffRandomPush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureInteract$Type extends MessageType<AdventureInteract> {
    constructor() {
        super("AdventureInteract", [
            { no: 1, name: "type", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "status", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "interact", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureInteract>): AdventureInteract {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureInteract>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureInteract): AdventureInteract {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional int32 id */ 2:
                    message.id = reader.int32();
                    break;
                case /* optional int32 status */ 3:
                    message.status = reader.int32();
                    break;
                case /* optional bool interact */ 4:
                    message.interact = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureInteract, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional int32 id = 2; */
        if (message.id !== undefined)
            writer.tag(2, WireType.Varint).int32(message.id);
        /* optional int32 status = 3; */
        if (message.status !== undefined)
            writer.tag(3, WireType.Varint).int32(message.status);
        /* optional bool interact = 4; */
        if (message.interact !== undefined)
            writer.tag(4, WireType.Varint).bool(message.interact);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureInteract
 */
export const AdventureInteract = new AdventureInteract$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureBattleMonsterHp$Type extends MessageType<AdventureBattleMonsterHp> {
    constructor() {
        super("AdventureBattleMonsterHp", [
            { no: 1, name: "hp", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureBattleMonsterHp>): AdventureBattleMonsterHp {
        const message = { hp: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureBattleMonsterHp>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureBattleMonsterHp): AdventureBattleMonsterHp {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 hp */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.hp.push(reader.int32());
                    else
                        message.hp.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureBattleMonsterHp, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 hp = 1; */
        for (let i = 0; i < message.hp.length; i++)
            writer.tag(1, WireType.Varint).int32(message.hp[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureBattleMonsterHp
 */
export const AdventureBattleMonsterHp = new AdventureBattleMonsterHp$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartAdventurePush$Type extends MessageType<StartAdventurePush> {
    constructor() {
        super("StartAdventurePush", [
            { no: 1, name: "adventureInfo", kind: "message", T: () => AdventureInfo }
        ]);
    }
    create(value?: PartialMessage<StartAdventurePush>): StartAdventurePush {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StartAdventurePush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartAdventurePush): StartAdventurePush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional AdventureInfo adventureInfo */ 1:
                    message.adventureInfo = AdventureInfo.internalBinaryRead(reader, reader.uint32(), options, message.adventureInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartAdventurePush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional AdventureInfo adventureInfo = 1; */
        if (message.adventureInfo)
            AdventureInfo.internalBinaryWrite(message.adventureInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StartAdventurePush
 */
export const StartAdventurePush = new StartAdventurePush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureBattleInfo$Type extends MessageType<AdventureBattleInfo> {
    constructor() {
        super("AdventureBattleInfo", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "monsterHps", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AdventureBattleMonsterHp }
        ]);
    }
    create(value?: PartialMessage<AdventureBattleInfo>): AdventureBattleInfo {
        const message = { monsterHps: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureBattleInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureBattleInfo): AdventureBattleInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* repeated AdventureBattleMonsterHp monsterHps */ 2:
                    message.monsterHps.push(AdventureBattleMonsterHp.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureBattleInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* repeated AdventureBattleMonsterHp monsterHps = 2; */
        for (let i = 0; i < message.monsterHps.length; i++)
            AdventureBattleMonsterHp.internalBinaryWrite(message.monsterHps[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureBattleInfo
 */
export const AdventureBattleInfo = new AdventureBattleInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureTaskUpdatePush$Type extends MessageType<AdventureTaskUpdatePush> {
    constructor() {
        super("AdventureTaskUpdatePush", [
            { no: 1, name: "taskInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AdventureTask }
        ]);
    }
    create(value?: PartialMessage<AdventureTaskUpdatePush>): AdventureTaskUpdatePush {
        const message = { taskInfos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureTaskUpdatePush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureTaskUpdatePush): AdventureTaskUpdatePush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated AdventureTask taskInfos */ 1:
                    message.taskInfos.push(AdventureTask.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureTaskUpdatePush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated AdventureTask taskInfos = 1; */
        for (let i = 0; i < message.taskInfos.length; i++)
            AdventureTask.internalBinaryWrite(message.taskInfos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureTaskUpdatePush
 */
export const AdventureTaskUpdatePush = new AdventureTaskUpdatePush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureTask$Type extends MessageType<AdventureTask> {
    constructor() {
        super("AdventureTask", [
            { no: 1, name: "taskId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "progress", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "hasGetBonus", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "isFinish", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureTask>): AdventureTask {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureTask>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureTask): AdventureTask {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 taskId */ 1:
                    message.taskId = reader.int32();
                    break;
                case /* optional int32 progress */ 2:
                    message.progress = reader.int32();
                    break;
                case /* optional bool hasGetBonus */ 3:
                    message.hasGetBonus = reader.bool();
                    break;
                case /* optional bool isFinish */ 4:
                    message.isFinish = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureTask, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 taskId = 1; */
        if (message.taskId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.taskId);
        /* optional int32 progress = 2; */
        if (message.progress !== undefined)
            writer.tag(2, WireType.Varint).int32(message.progress);
        /* optional bool hasGetBonus = 3; */
        if (message.hasGetBonus !== undefined)
            writer.tag(3, WireType.Varint).bool(message.hasGetBonus);
        /* optional bool isFinish = 4; */
        if (message.isFinish !== undefined)
            writer.tag(4, WireType.Varint).bool(message.isFinish);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureTask
 */
export const AdventureTask = new AdventureTask$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureSeat$Type extends MessageType<AdventureSeat> {
    constructor() {
        super("AdventureSeat", [
            { no: 1, name: "areaId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "x", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "y", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureSeat>): AdventureSeat {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureSeat>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureSeat): AdventureSeat {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 areaId */ 1:
                    message.areaId = reader.int32();
                    break;
                case /* optional int32 x */ 2:
                    message.x = reader.int32();
                    break;
                case /* optional int32 y */ 3:
                    message.y = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureSeat, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 areaId = 1; */
        if (message.areaId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.areaId);
        /* optional int32 x = 2; */
        if (message.x !== undefined)
            writer.tag(2, WireType.Varint).int32(message.x);
        /* optional int32 y = 3; */
        if (message.y !== undefined)
            writer.tag(3, WireType.Varint).int32(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureSeat
 */
export const AdventureSeat = new AdventureSeat$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureAreaSight$Type extends MessageType<AdventureAreaSight> {
    constructor() {
        super("AdventureAreaSight", [
            { no: 1, name: "areaId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "sight", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ },
            { no: 3, name: "visible", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureAreaSight>): AdventureAreaSight {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureAreaSight>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureAreaSight): AdventureAreaSight {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 areaId */ 1:
                    message.areaId = reader.int32();
                    break;
                case /* optional bytes sight */ 2:
                    message.sight = reader.bytes();
                    break;
                case /* optional bool visible */ 3:
                    message.visible = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureAreaSight, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 areaId = 1; */
        if (message.areaId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.areaId);
        /* optional bytes sight = 2; */
        if (message.sight !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.sight);
        /* optional bool visible = 3; */
        if (message.visible !== undefined)
            writer.tag(3, WireType.Varint).bool(message.visible);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureAreaSight
 */
export const AdventureAreaSight = new AdventureAreaSight$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureTaskSubmitRequest$Type extends MessageType<AdventureTaskSubmitRequest> {
    constructor() {
        super("AdventureTaskSubmitRequest", [
            { no: 1, name: "taskId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "materialData", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MaterialData }
        ]);
    }
    create(value?: PartialMessage<AdventureTaskSubmitRequest>): AdventureTaskSubmitRequest {
        const message = { materialData: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureTaskSubmitRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureTaskSubmitRequest): AdventureTaskSubmitRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 taskId */ 1:
                    message.taskId = reader.int32();
                    break;
                case /* repeated MaterialData materialData */ 2:
                    message.materialData.push(MaterialData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureTaskSubmitRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 taskId = 1; */
        if (message.taskId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.taskId);
        /* repeated MaterialData materialData = 2; */
        for (let i = 0; i < message.materialData.length; i++)
            MaterialData.internalBinaryWrite(message.materialData[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureTaskSubmitRequest
 */
export const AdventureTaskSubmitRequest = new AdventureTaskSubmitRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureBuffReply$Type extends MessageType<AdventureBuffReply> {
    constructor() {
        super("AdventureBuffReply", [
            { no: 1, name: "chapterType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "selectBuff", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureBuffReply>): AdventureBuffReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureBuffReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureBuffReply): AdventureBuffReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterType */ 1:
                    message.chapterType = reader.int32();
                    break;
                case /* optional int32 selectBuff */ 3:
                    message.selectBuff = reader.int32();
                    break;
                case /* optional int32 heroId */ 4:
                    message.heroId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureBuffReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterType = 1; */
        if (message.chapterType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterType);
        /* optional int32 selectBuff = 3; */
        if (message.selectBuff !== undefined)
            writer.tag(3, WireType.Varint).int32(message.selectBuff);
        /* optional int32 heroId = 4; */
        if (message.heroId !== undefined)
            writer.tag(4, WireType.Varint).int32(message.heroId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureBuffReply
 */
export const AdventureBuffReply = new AdventureBuffReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureBattleRequest$Type extends MessageType<AdventureBattleRequest> {
    constructor() {
        super("AdventureBattleRequest", [
            { no: 1, name: "chapterType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "fightGroup", kind: "message", T: () => FightGroup }
        ]);
    }
    create(value?: PartialMessage<AdventureBattleRequest>): AdventureBattleRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureBattleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureBattleRequest): AdventureBattleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterType */ 1:
                    message.chapterType = reader.int32();
                    break;
                case /* optional int32 id */ 2:
                    message.id = reader.int32();
                    break;
                case /* optional FightGroup fightGroup */ 3:
                    message.fightGroup = FightGroup.internalBinaryRead(reader, reader.uint32(), options, message.fightGroup);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureBattleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterType = 1; */
        if (message.chapterType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterType);
        /* optional int32 id = 2; */
        if (message.id !== undefined)
            writer.tag(2, WireType.Varint).int32(message.id);
        /* optional FightGroup fightGroup = 3; */
        if (message.fightGroup)
            FightGroup.internalBinaryWrite(message.fightGroup, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureBattleRequest
 */
export const AdventureBattleRequest = new AdventureBattleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureSetAreaVisibleReply$Type extends MessageType<AdventureSetAreaVisibleReply> {
    constructor() {
        super("AdventureSetAreaVisibleReply", [
            { no: 1, name: "chapterType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "areaId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "visible", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureSetAreaVisibleReply>): AdventureSetAreaVisibleReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureSetAreaVisibleReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureSetAreaVisibleReply): AdventureSetAreaVisibleReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterType */ 1:
                    message.chapterType = reader.int32();
                    break;
                case /* optional int32 areaId */ 2:
                    message.areaId = reader.int32();
                    break;
                case /* optional bool visible */ 3:
                    message.visible = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureSetAreaVisibleReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterType = 1; */
        if (message.chapterType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterType);
        /* optional int32 areaId = 2; */
        if (message.areaId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.areaId);
        /* optional bool visible = 3; */
        if (message.visible !== undefined)
            writer.tag(3, WireType.Varint).bool(message.visible);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureSetAreaVisibleReply
 */
export const AdventureSetAreaVisibleReply = new AdventureSetAreaVisibleReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureInteractClientFinishReply$Type extends MessageType<AdventureInteractClientFinishReply> {
    constructor() {
        super("AdventureInteractClientFinishReply", []);
    }
    create(value?: PartialMessage<AdventureInteractClientFinishReply>): AdventureInteractClientFinishReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureInteractClientFinishReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureInteractClientFinishReply): AdventureInteractClientFinishReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: AdventureInteractClientFinishReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureInteractClientFinishReply
 */
export const AdventureInteractClientFinishReply = new AdventureInteractClientFinishReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAdventureInfoRequest$Type extends MessageType<GetAdventureInfoRequest> {
    constructor() {
        super("GetAdventureInfoRequest", []);
    }
    create(value?: PartialMessage<GetAdventureInfoRequest>): GetAdventureInfoRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAdventureInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAdventureInfoRequest): GetAdventureInfoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetAdventureInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetAdventureInfoRequest
 */
export const GetAdventureInfoRequest = new GetAdventureInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureBonusRequest$Type extends MessageType<AdventureBonusRequest> {
    constructor() {
        super("AdventureBonusRequest", [
            { no: 1, name: "chapterType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureBonusRequest>): AdventureBonusRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureBonusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureBonusRequest): AdventureBonusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterType */ 1:
                    message.chapterType = reader.int32();
                    break;
                case /* optional int32 id */ 2:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureBonusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterType = 1; */
        if (message.chapterType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterType);
        /* optional int32 id = 2; */
        if (message.id !== undefined)
            writer.tag(2, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureBonusRequest
 */
export const AdventureBonusRequest = new AdventureBonusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureSetAreaVisibleRequest$Type extends MessageType<AdventureSetAreaVisibleRequest> {
    constructor() {
        super("AdventureSetAreaVisibleRequest", [
            { no: 1, name: "chapterType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "areaId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "visible", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureSetAreaVisibleRequest>): AdventureSetAreaVisibleRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureSetAreaVisibleRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureSetAreaVisibleRequest): AdventureSetAreaVisibleRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterType */ 1:
                    message.chapterType = reader.int32();
                    break;
                case /* optional int32 areaId */ 2:
                    message.areaId = reader.int32();
                    break;
                case /* optional bool visible */ 3:
                    message.visible = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureSetAreaVisibleRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterType = 1; */
        if (message.chapterType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterType);
        /* optional int32 areaId = 2; */
        if (message.areaId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.areaId);
        /* optional bool visible = 3; */
        if (message.visible !== undefined)
            writer.tag(3, WireType.Varint).bool(message.visible);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureSetAreaVisibleRequest
 */
export const AdventureSetAreaVisibleRequest = new AdventureSetAreaVisibleRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureBuffRequest$Type extends MessageType<AdventureBuffRequest> {
    constructor() {
        super("AdventureBuffRequest", [
            { no: 1, name: "chapterType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "selectBuff", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureBuffRequest>): AdventureBuffRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureBuffRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureBuffRequest): AdventureBuffRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterType */ 1:
                    message.chapterType = reader.int32();
                    break;
                case /* optional int32 selectBuff */ 3:
                    message.selectBuff = reader.int32();
                    break;
                case /* optional int32 heroId */ 4:
                    message.heroId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureBuffRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterType = 1; */
        if (message.chapterType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterType);
        /* optional int32 selectBuff = 3; */
        if (message.selectBuff !== undefined)
            writer.tag(3, WireType.Varint).int32(message.selectBuff);
        /* optional int32 heroId = 4; */
        if (message.heroId !== undefined)
            writer.tag(4, WireType.Varint).int32(message.heroId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureBuffRequest
 */
export const AdventureBuffRequest = new AdventureBuffRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureGeneralReply$Type extends MessageType<AdventureGeneralReply> {
    constructor() {
        super("AdventureGeneralReply", [
            { no: 1, name: "chapterType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureGeneralReply>): AdventureGeneralReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureGeneralReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureGeneralReply): AdventureGeneralReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterType */ 1:
                    message.chapterType = reader.int32();
                    break;
                case /* optional int32 id */ 2:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureGeneralReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterType = 1; */
        if (message.chapterType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterType);
        /* optional int32 id = 2; */
        if (message.id !== undefined)
            writer.tag(2, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureGeneralReply
 */
export const AdventureGeneralReply = new AdventureGeneralReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAdventureInfoReply$Type extends MessageType<GetAdventureInfoReply> {
    constructor() {
        super("GetAdventureInfoReply", [
            { no: 1, name: "adventureInfo", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AdventureInfo },
            { no: 12, name: "foreverInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AdventureForeverInfo }
        ]);
    }
    create(value?: PartialMessage<GetAdventureInfoReply>): GetAdventureInfoReply {
        const message = { adventureInfo: [], foreverInfos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetAdventureInfoReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAdventureInfoReply): GetAdventureInfoReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated AdventureInfo adventureInfo */ 1:
                    message.adventureInfo.push(AdventureInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated AdventureForeverInfo foreverInfos */ 12:
                    message.foreverInfos.push(AdventureForeverInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetAdventureInfoReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated AdventureInfo adventureInfo = 1; */
        for (let i = 0; i < message.adventureInfo.length; i++)
            AdventureInfo.internalBinaryWrite(message.adventureInfo[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated AdventureForeverInfo foreverInfos = 12; */
        for (let i = 0; i < message.foreverInfos.length; i++)
            AdventureForeverInfo.internalBinaryWrite(message.foreverInfos[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetAdventureInfoReply
 */
export const GetAdventureInfoReply = new GetAdventureInfoReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureRespawnReply$Type extends MessageType<AdventureRespawnReply> {
    constructor() {
        super("AdventureRespawnReply", [
            { no: 1, name: "chapterType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureRespawnReply>): AdventureRespawnReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureRespawnReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureRespawnReply): AdventureRespawnReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterType */ 1:
                    message.chapterType = reader.int32();
                    break;
                case /* optional int32 id */ 2:
                    message.id = reader.int32();
                    break;
                case /* optional int32 heroId */ 3:
                    message.heroId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureRespawnReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterType = 1; */
        if (message.chapterType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterType);
        /* optional int32 id = 2; */
        if (message.id !== undefined)
            writer.tag(2, WireType.Varint).int32(message.id);
        /* optional int32 heroId = 3; */
        if (message.heroId !== undefined)
            writer.tag(3, WireType.Varint).int32(message.heroId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureRespawnReply
 */
export const AdventureRespawnReply = new AdventureRespawnReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureMoveRequest$Type extends MessageType<AdventureMoveRequest> {
    constructor() {
        super("AdventureMoveRequest", [
            { no: 1, name: "chapterType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "posx", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "posy", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "sightChange", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => AdventureSeat }
        ]);
    }
    create(value?: PartialMessage<AdventureMoveRequest>): AdventureMoveRequest {
        const message = { sightChange: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureMoveRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureMoveRequest): AdventureMoveRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterType */ 1:
                    message.chapterType = reader.int32();
                    break;
                case /* optional int32 posx */ 2:
                    message.posx = reader.int32();
                    break;
                case /* optional int32 posy */ 3:
                    message.posy = reader.int32();
                    break;
                case /* repeated AdventureSeat sightChange */ 4:
                    message.sightChange.push(AdventureSeat.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureMoveRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterType = 1; */
        if (message.chapterType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterType);
        /* optional int32 posx = 2; */
        if (message.posx !== undefined)
            writer.tag(2, WireType.Varint).int32(message.posx);
        /* optional int32 posy = 3; */
        if (message.posy !== undefined)
            writer.tag(3, WireType.Varint).int32(message.posy);
        /* repeated AdventureSeat sightChange = 4; */
        for (let i = 0; i < message.sightChange.length; i++)
            AdventureSeat.internalBinaryWrite(message.sightChange[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureMoveRequest
 */
export const AdventureMoveRequest = new AdventureMoveRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureStoryReply$Type extends MessageType<AdventureStoryReply> {
    constructor() {
        super("AdventureStoryReply", [
            { no: 1, name: "chapterType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureStoryReply>): AdventureStoryReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureStoryReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureStoryReply): AdventureStoryReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterType */ 1:
                    message.chapterType = reader.int32();
                    break;
                case /* optional int32 id */ 2:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureStoryReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterType = 1; */
        if (message.chapterType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterType);
        /* optional int32 id = 2; */
        if (message.id !== undefined)
            writer.tag(2, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureStoryReply
 */
export const AdventureStoryReply = new AdventureStoryReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureMagicRequest$Type extends MessageType<AdventureMagicRequest> {
    constructor() {
        super("AdventureMagicRequest", [
            { no: 1, name: "chapterType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureMagicRequest>): AdventureMagicRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureMagicRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureMagicRequest): AdventureMagicRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterType */ 1:
                    message.chapterType = reader.int32();
                    break;
                case /* optional int32 id */ 2:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureMagicRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterType = 1; */
        if (message.chapterType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterType);
        /* optional int32 id = 2; */
        if (message.id !== undefined)
            writer.tag(2, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureMagicRequest
 */
export const AdventureMagicRequest = new AdventureMagicRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AdventureRespawnRequest$Type extends MessageType<AdventureRespawnRequest> {
    constructor() {
        super("AdventureRespawnRequest", [
            { no: 1, name: "chapterType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AdventureRespawnRequest>): AdventureRespawnRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AdventureRespawnRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AdventureRespawnRequest): AdventureRespawnRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 chapterType */ 1:
                    message.chapterType = reader.int32();
                    break;
                case /* optional int32 id */ 2:
                    message.id = reader.int32();
                    break;
                case /* optional int32 heroId */ 3:
                    message.heroId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AdventureRespawnRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 chapterType = 1; */
        if (message.chapterType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.chapterType);
        /* optional int32 id = 2; */
        if (message.id !== undefined)
            writer.tag(2, WireType.Varint).int32(message.id);
        /* optional int32 heroId = 3; */
        if (message.heroId !== undefined)
            writer.tag(3, WireType.Varint).int32(message.heroId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AdventureRespawnRequest
 */
export const AdventureRespawnRequest = new AdventureRespawnRequest$Type();
