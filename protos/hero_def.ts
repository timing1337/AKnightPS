// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "hero_def.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message HeroGroupEquip
 */
export interface HeroGroupEquip {
    /**
     * @generated from protobuf field: optional int32 index = 1;
     */
    index?: number;
    /**
     * @generated from protobuf field: repeated int64 equipUid = 2;
     */
    equipUid: bigint[];
}
/**
 * @generated from protobuf message SkillInfo
 */
export interface SkillInfo {
    /**
     * @generated from protobuf field: optional int32 skillId = 1;
     */
    skillId?: number;
    /**
     * @generated from protobuf field: optional int32 level = 2;
     */
    level?: number;
    /**
     * @generated from protobuf field: optional int32 maxLevel = 3;
     */
    maxLevel?: number;
}
/**
 * @generated from protobuf message HeroAllAttribute
 */
export interface HeroAllAttribute {
    /**
     * @generated from protobuf field: optional HeroAttribute baseAttr = 1;
     */
    baseAttr?: HeroAttribute;
    /**
     * @generated from protobuf field: optional HeroExAttribute exAttr = 2;
     */
    exAttr?: HeroExAttribute;
    /**
     * @generated from protobuf field: optional HeroSpAttribute spAttr = 3;
     */
    spAttr?: HeroSpAttribute;
}
/**
 * @generated from protobuf message HeroSimpleInfo
 */
export interface HeroSimpleInfo {
    /**
     * @generated from protobuf field: int32 heroId = 1;
     */
    heroId: number;
    /**
     * @generated from protobuf field: optional int32 level = 2;
     */
    level?: number;
    /**
     * @generated from protobuf field: optional int32 rank = 3;
     */
    rank?: number;
    /**
     * @generated from protobuf field: optional int32 exSkillLevel = 4;
     */
    exSkillLevel?: number;
    /**
     * @generated from protobuf field: optional int32 skin = 5;
     */
    skin?: number;
}
/**
 * @generated from protobuf message HeroExAttribute
 */
export interface HeroExAttribute {
    /**
     * @generated from protobuf field: optional int32 cri = 1;
     */
    cri?: number;
    /**
     * @generated from protobuf field: optional int32 recri = 2;
     */
    recri?: number;
    /**
     * @generated from protobuf field: optional int32 criDmg = 3;
     */
    criDmg?: number;
    /**
     * @generated from protobuf field: optional int32 criDef = 4;
     */
    criDef?: number;
    /**
     * @generated from protobuf field: optional int32 addDmg = 5;
     */
    addDmg?: number;
    /**
     * @generated from protobuf field: optional int32 dropDmg = 6;
     */
    dropDmg?: number;
}
/**
 * @generated from protobuf message SkinInfo
 */
export interface SkinInfo {
    /**
     * @generated from protobuf field: optional int32 skin = 1;
     */
    skin?: number;
    /**
     * @generated from protobuf field: optional int32 expireSec = 2;
     */
    expireSec?: number;
}
/**
 * @generated from protobuf message HeroSpAttribute
 */
export interface HeroSpAttribute {
    /**
     * @generated from protobuf field: optional int32 revive = 1;
     */
    revive?: number;
    /**
     * @generated from protobuf field: optional int32 heal = 2;
     */
    heal?: number;
    /**
     * @generated from protobuf field: optional int32 absorb = 3;
     */
    absorb?: number;
    /**
     * @generated from protobuf field: optional int32 defenseIgnore = 4;
     */
    defenseIgnore?: number;
    /**
     * @generated from protobuf field: optional int32 clutch = 5;
     */
    clutch?: number;
    /**
     * @generated from protobuf field: optional int32 finalAddDmg = 6;
     */
    finalAddDmg?: number;
    /**
     * @generated from protobuf field: optional int32 finalDropDmg = 7;
     */
    finalDropDmg?: number;
}
/**
 * @generated from protobuf message TalentCubeInfo
 */
export interface TalentCubeInfo {
    /**
     * @generated from protobuf field: optional int32 cubeId = 1;
     */
    cubeId?: number;
    /**
     * @generated from protobuf field: optional int32 direction = 2;
     */
    direction?: number;
    /**
     * @generated from protobuf field: optional int32 posX = 3;
     */
    posX?: number;
    /**
     * @generated from protobuf field: optional int32 posY = 4;
     */
    posY?: number;
}
/**
 * @generated from protobuf message HeroInfo
 */
export interface HeroInfo {
    /**
     * @generated from protobuf field: int64 uid = 1;
     */
    uid: bigint;
    /**
     * @generated from protobuf field: int64 userId = 2;
     */
    userId: bigint;
    /**
     * @generated from protobuf field: int32 heroId = 3;
     */
    heroId: number;
    /**
     * @generated from protobuf field: optional int64 createTime = 4;
     */
    createTime?: bigint;
    /**
     * @generated from protobuf field: optional int32 level = 5;
     */
    level?: number;
    /**
     * @generated from protobuf field: optional int32 exp = 6;
     */
    exp?: number;
    /**
     * @generated from protobuf field: optional int32 rank = 7;
     */
    rank?: number;
    /**
     * @generated from protobuf field: optional int32 breakthrough = 8;
     */
    breakthrough?: number;
    /**
     * @generated from protobuf field: optional int32 skin = 9;
     */
    skin?: number;
    /**
     * @generated from protobuf field: optional int32 faith = 10;
     */
    faith?: number;
    /**
     * @generated from protobuf field: optional int32 activeSkillLevel = 11;
     */
    activeSkillLevel?: number;
    /**
     * @generated from protobuf field: repeated int32 passiveSkillLevel = 12;
     */
    passiveSkillLevel: number[];
    /**
     * @generated from protobuf field: optional int32 exSkillLevel = 13;
     */
    exSkillLevel?: number;
    /**
     * @generated from protobuf field: repeated int32 voice = 14;
     */
    voice: number[];
    /**
     * @generated from protobuf field: repeated int32 voiceHeard = 15;
     */
    voiceHeard: number[];
    /**
     * @generated from protobuf field: repeated SkinInfo skinInfoList = 16;
     */
    skinInfoList: SkinInfo[];
    /**
     * @generated from protobuf field: optional HeroAttribute baseAttr = 17;
     */
    baseAttr?: HeroAttribute;
    /**
     * @generated from protobuf field: optional HeroExAttribute exAttr = 18;
     */
    exAttr?: HeroExAttribute;
    /**
     * @generated from protobuf field: optional HeroSpAttribute spAttr = 19;
     */
    spAttr?: HeroSpAttribute;
    /**
     * @generated from protobuf field: repeated HeroEquipAttribute equipAttrList = 20;
     */
    equipAttrList: HeroEquipAttribute[];
    /**
     * @generated from protobuf field: optional bool isNew = 21;
     */
    isNew?: boolean;
    /**
     * @generated from protobuf field: repeated int32 itemUnlock = 22;
     */
    itemUnlock: number[];
    /**
     * @generated from protobuf field: optional int32 talent = 23;
     */
    talent?: number;
    /**
     * @generated from protobuf field: repeated TalentCubeInfo talentCubeInfos = 24;
     */
    talentCubeInfos: TalentCubeInfo[];
    /**
     * @generated from protobuf field: optional int64 defaultEquipUid = 25;
     */
    defaultEquipUid?: bigint;
}
/**
 * @generated from protobuf message HeroAttribute
 */
export interface HeroAttribute {
    /**
     * @generated from protobuf field: int32 hp = 1;
     */
    hp: number;
    /**
     * @generated from protobuf field: int32 attack = 2;
     */
    attack: number;
    /**
     * @generated from protobuf field: int32 defense = 3;
     */
    defense: number;
    /**
     * @generated from protobuf field: int32 mdefense = 4;
     */
    mdefense: number;
    /**
     * @generated from protobuf field: int32 technic = 5;
     */
    technic: number;
}
/**
 * @generated from protobuf message HeroGroupInfo
 */
export interface HeroGroupInfo {
    /**
     * @generated from protobuf field: int32 groupId = 1;
     */
    groupId: number;
    /**
     * @generated from protobuf field: repeated int64 heroList = 2;
     */
    heroList: bigint[];
    /**
     * @generated from protobuf field: optional string name = 3;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional int32 clothId = 4;
     */
    clothId?: number;
    /**
     * @generated from protobuf field: repeated HeroGroupEquip equips = 5;
     */
    equips: HeroGroupEquip[];
    /**
     * @generated from protobuf field: repeated HeroGroupEquip activity104Equips = 6;
     */
    activity104Equips: HeroGroupEquip[];
}
/**
 * @generated from protobuf message HeroEquipAttribute
 */
export interface HeroEquipAttribute {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional HeroAttribute equipAttr = 2;
     */
    equipAttr?: HeroAttribute;
}
// @generated message type with reflection information, may provide speed optimized methods
class HeroGroupEquip$Type extends MessageType<HeroGroupEquip> {
    constructor() {
        super("HeroGroupEquip", [
            { no: 1, name: "index", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "equipUid", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<HeroGroupEquip>): HeroGroupEquip {
        const message = { equipUid: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroGroupEquip>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroGroupEquip): HeroGroupEquip {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 index */ 1:
                    message.index = reader.int32();
                    break;
                case /* repeated int64 equipUid */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.equipUid.push(reader.int64().toBigInt());
                    else
                        message.equipUid.push(reader.int64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroGroupEquip, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 index = 1; */
        if (message.index !== undefined)
            writer.tag(1, WireType.Varint).int32(message.index);
        /* repeated int64 equipUid = 2; */
        for (let i = 0; i < message.equipUid.length; i++)
            writer.tag(2, WireType.Varint).int64(message.equipUid[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroGroupEquip
 */
export const HeroGroupEquip = new HeroGroupEquip$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SkillInfo$Type extends MessageType<SkillInfo> {
    constructor() {
        super("SkillInfo", [
            { no: 1, name: "skillId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "level", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "maxLevel", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SkillInfo>): SkillInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SkillInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SkillInfo): SkillInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 skillId */ 1:
                    message.skillId = reader.int32();
                    break;
                case /* optional int32 level */ 2:
                    message.level = reader.int32();
                    break;
                case /* optional int32 maxLevel */ 3:
                    message.maxLevel = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SkillInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 skillId = 1; */
        if (message.skillId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.skillId);
        /* optional int32 level = 2; */
        if (message.level !== undefined)
            writer.tag(2, WireType.Varint).int32(message.level);
        /* optional int32 maxLevel = 3; */
        if (message.maxLevel !== undefined)
            writer.tag(3, WireType.Varint).int32(message.maxLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SkillInfo
 */
export const SkillInfo = new SkillInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroAllAttribute$Type extends MessageType<HeroAllAttribute> {
    constructor() {
        super("HeroAllAttribute", [
            { no: 1, name: "baseAttr", kind: "message", T: () => HeroAttribute },
            { no: 2, name: "exAttr", kind: "message", T: () => HeroExAttribute },
            { no: 3, name: "spAttr", kind: "message", T: () => HeroSpAttribute }
        ]);
    }
    create(value?: PartialMessage<HeroAllAttribute>): HeroAllAttribute {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroAllAttribute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroAllAttribute): HeroAllAttribute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional HeroAttribute baseAttr */ 1:
                    message.baseAttr = HeroAttribute.internalBinaryRead(reader, reader.uint32(), options, message.baseAttr);
                    break;
                case /* optional HeroExAttribute exAttr */ 2:
                    message.exAttr = HeroExAttribute.internalBinaryRead(reader, reader.uint32(), options, message.exAttr);
                    break;
                case /* optional HeroSpAttribute spAttr */ 3:
                    message.spAttr = HeroSpAttribute.internalBinaryRead(reader, reader.uint32(), options, message.spAttr);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroAllAttribute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional HeroAttribute baseAttr = 1; */
        if (message.baseAttr)
            HeroAttribute.internalBinaryWrite(message.baseAttr, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional HeroExAttribute exAttr = 2; */
        if (message.exAttr)
            HeroExAttribute.internalBinaryWrite(message.exAttr, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional HeroSpAttribute spAttr = 3; */
        if (message.spAttr)
            HeroSpAttribute.internalBinaryWrite(message.spAttr, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroAllAttribute
 */
export const HeroAllAttribute = new HeroAllAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroSimpleInfo$Type extends MessageType<HeroSimpleInfo> {
    constructor() {
        super("HeroSimpleInfo", [
            { no: 1, name: "heroId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "level", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "rank", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "exSkillLevel", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "skin", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HeroSimpleInfo>): HeroSimpleInfo {
        const message = { heroId: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroSimpleInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroSimpleInfo): HeroSimpleInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                case /* optional int32 level */ 2:
                    message.level = reader.int32();
                    break;
                case /* optional int32 rank */ 3:
                    message.rank = reader.int32();
                    break;
                case /* optional int32 exSkillLevel */ 4:
                    message.exSkillLevel = reader.int32();
                    break;
                case /* optional int32 skin */ 5:
                    message.skin = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroSimpleInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 heroId = 1; */
        if (message.heroId !== 0)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        /* optional int32 level = 2; */
        if (message.level !== undefined)
            writer.tag(2, WireType.Varint).int32(message.level);
        /* optional int32 rank = 3; */
        if (message.rank !== undefined)
            writer.tag(3, WireType.Varint).int32(message.rank);
        /* optional int32 exSkillLevel = 4; */
        if (message.exSkillLevel !== undefined)
            writer.tag(4, WireType.Varint).int32(message.exSkillLevel);
        /* optional int32 skin = 5; */
        if (message.skin !== undefined)
            writer.tag(5, WireType.Varint).int32(message.skin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroSimpleInfo
 */
export const HeroSimpleInfo = new HeroSimpleInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroExAttribute$Type extends MessageType<HeroExAttribute> {
    constructor() {
        super("HeroExAttribute", [
            { no: 1, name: "cri", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "recri", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "criDmg", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "criDef", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "addDmg", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "dropDmg", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HeroExAttribute>): HeroExAttribute {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroExAttribute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroExAttribute): HeroExAttribute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 cri */ 1:
                    message.cri = reader.int32();
                    break;
                case /* optional int32 recri */ 2:
                    message.recri = reader.int32();
                    break;
                case /* optional int32 criDmg */ 3:
                    message.criDmg = reader.int32();
                    break;
                case /* optional int32 criDef */ 4:
                    message.criDef = reader.int32();
                    break;
                case /* optional int32 addDmg */ 5:
                    message.addDmg = reader.int32();
                    break;
                case /* optional int32 dropDmg */ 6:
                    message.dropDmg = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroExAttribute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 cri = 1; */
        if (message.cri !== undefined)
            writer.tag(1, WireType.Varint).int32(message.cri);
        /* optional int32 recri = 2; */
        if (message.recri !== undefined)
            writer.tag(2, WireType.Varint).int32(message.recri);
        /* optional int32 criDmg = 3; */
        if (message.criDmg !== undefined)
            writer.tag(3, WireType.Varint).int32(message.criDmg);
        /* optional int32 criDef = 4; */
        if (message.criDef !== undefined)
            writer.tag(4, WireType.Varint).int32(message.criDef);
        /* optional int32 addDmg = 5; */
        if (message.addDmg !== undefined)
            writer.tag(5, WireType.Varint).int32(message.addDmg);
        /* optional int32 dropDmg = 6; */
        if (message.dropDmg !== undefined)
            writer.tag(6, WireType.Varint).int32(message.dropDmg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroExAttribute
 */
export const HeroExAttribute = new HeroExAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SkinInfo$Type extends MessageType<SkinInfo> {
    constructor() {
        super("SkinInfo", [
            { no: 1, name: "skin", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "expireSec", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SkinInfo>): SkinInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SkinInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SkinInfo): SkinInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 skin */ 1:
                    message.skin = reader.int32();
                    break;
                case /* optional int32 expireSec */ 2:
                    message.expireSec = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SkinInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 skin = 1; */
        if (message.skin !== undefined)
            writer.tag(1, WireType.Varint).int32(message.skin);
        /* optional int32 expireSec = 2; */
        if (message.expireSec !== undefined)
            writer.tag(2, WireType.Varint).int32(message.expireSec);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SkinInfo
 */
export const SkinInfo = new SkinInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroSpAttribute$Type extends MessageType<HeroSpAttribute> {
    constructor() {
        super("HeroSpAttribute", [
            { no: 1, name: "revive", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "heal", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "absorb", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "defenseIgnore", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "clutch", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "finalAddDmg", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "finalDropDmg", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HeroSpAttribute>): HeroSpAttribute {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroSpAttribute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroSpAttribute): HeroSpAttribute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 revive */ 1:
                    message.revive = reader.int32();
                    break;
                case /* optional int32 heal */ 2:
                    message.heal = reader.int32();
                    break;
                case /* optional int32 absorb */ 3:
                    message.absorb = reader.int32();
                    break;
                case /* optional int32 defenseIgnore */ 4:
                    message.defenseIgnore = reader.int32();
                    break;
                case /* optional int32 clutch */ 5:
                    message.clutch = reader.int32();
                    break;
                case /* optional int32 finalAddDmg */ 6:
                    message.finalAddDmg = reader.int32();
                    break;
                case /* optional int32 finalDropDmg */ 7:
                    message.finalDropDmg = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroSpAttribute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 revive = 1; */
        if (message.revive !== undefined)
            writer.tag(1, WireType.Varint).int32(message.revive);
        /* optional int32 heal = 2; */
        if (message.heal !== undefined)
            writer.tag(2, WireType.Varint).int32(message.heal);
        /* optional int32 absorb = 3; */
        if (message.absorb !== undefined)
            writer.tag(3, WireType.Varint).int32(message.absorb);
        /* optional int32 defenseIgnore = 4; */
        if (message.defenseIgnore !== undefined)
            writer.tag(4, WireType.Varint).int32(message.defenseIgnore);
        /* optional int32 clutch = 5; */
        if (message.clutch !== undefined)
            writer.tag(5, WireType.Varint).int32(message.clutch);
        /* optional int32 finalAddDmg = 6; */
        if (message.finalAddDmg !== undefined)
            writer.tag(6, WireType.Varint).int32(message.finalAddDmg);
        /* optional int32 finalDropDmg = 7; */
        if (message.finalDropDmg !== undefined)
            writer.tag(7, WireType.Varint).int32(message.finalDropDmg);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroSpAttribute
 */
export const HeroSpAttribute = new HeroSpAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TalentCubeInfo$Type extends MessageType<TalentCubeInfo> {
    constructor() {
        super("TalentCubeInfo", [
            { no: 1, name: "cubeId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "direction", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "posX", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "posY", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TalentCubeInfo>): TalentCubeInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TalentCubeInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TalentCubeInfo): TalentCubeInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 cubeId */ 1:
                    message.cubeId = reader.int32();
                    break;
                case /* optional int32 direction */ 2:
                    message.direction = reader.int32();
                    break;
                case /* optional int32 posX */ 3:
                    message.posX = reader.int32();
                    break;
                case /* optional int32 posY */ 4:
                    message.posY = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TalentCubeInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 cubeId = 1; */
        if (message.cubeId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.cubeId);
        /* optional int32 direction = 2; */
        if (message.direction !== undefined)
            writer.tag(2, WireType.Varint).int32(message.direction);
        /* optional int32 posX = 3; */
        if (message.posX !== undefined)
            writer.tag(3, WireType.Varint).int32(message.posX);
        /* optional int32 posY = 4; */
        if (message.posY !== undefined)
            writer.tag(4, WireType.Varint).int32(message.posY);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TalentCubeInfo
 */
export const TalentCubeInfo = new TalentCubeInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroInfo$Type extends MessageType<HeroInfo> {
    constructor() {
        super("HeroInfo", [
            { no: 1, name: "uid", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "userId", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "heroId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "createTime", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "level", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "exp", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "rank", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "breakthrough", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "skin", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "faith", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 11, name: "activeSkillLevel", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 12, name: "passiveSkillLevel", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "exSkillLevel", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "voice", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "voiceHeard", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 16, name: "skinInfoList", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SkinInfo },
            { no: 17, name: "baseAttr", kind: "message", T: () => HeroAttribute },
            { no: 18, name: "exAttr", kind: "message", T: () => HeroExAttribute },
            { no: 19, name: "spAttr", kind: "message", T: () => HeroSpAttribute },
            { no: 20, name: "equipAttrList", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => HeroEquipAttribute },
            { no: 21, name: "isNew", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 22, name: "itemUnlock", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 23, name: "talent", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 24, name: "talentCubeInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TalentCubeInfo },
            { no: 25, name: "defaultEquipUid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<HeroInfo>): HeroInfo {
        const message = { uid: 0n, userId: 0n, heroId: 0, passiveSkillLevel: [], voice: [], voiceHeard: [], skinInfoList: [], equipAttrList: [], itemUnlock: [], talentCubeInfos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroInfo): HeroInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int64 uid */ 1:
                    message.uid = reader.int64().toBigInt();
                    break;
                case /* int64 userId */ 2:
                    message.userId = reader.int64().toBigInt();
                    break;
                case /* int32 heroId */ 3:
                    message.heroId = reader.int32();
                    break;
                case /* optional int64 createTime */ 4:
                    message.createTime = reader.int64().toBigInt();
                    break;
                case /* optional int32 level */ 5:
                    message.level = reader.int32();
                    break;
                case /* optional int32 exp */ 6:
                    message.exp = reader.int32();
                    break;
                case /* optional int32 rank */ 7:
                    message.rank = reader.int32();
                    break;
                case /* optional int32 breakthrough */ 8:
                    message.breakthrough = reader.int32();
                    break;
                case /* optional int32 skin */ 9:
                    message.skin = reader.int32();
                    break;
                case /* optional int32 faith */ 10:
                    message.faith = reader.int32();
                    break;
                case /* optional int32 activeSkillLevel */ 11:
                    message.activeSkillLevel = reader.int32();
                    break;
                case /* repeated int32 passiveSkillLevel */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.passiveSkillLevel.push(reader.int32());
                    else
                        message.passiveSkillLevel.push(reader.int32());
                    break;
                case /* optional int32 exSkillLevel */ 13:
                    message.exSkillLevel = reader.int32();
                    break;
                case /* repeated int32 voice */ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.voice.push(reader.int32());
                    else
                        message.voice.push(reader.int32());
                    break;
                case /* repeated int32 voiceHeard */ 15:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.voiceHeard.push(reader.int32());
                    else
                        message.voiceHeard.push(reader.int32());
                    break;
                case /* repeated SkinInfo skinInfoList */ 16:
                    message.skinInfoList.push(SkinInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional HeroAttribute baseAttr */ 17:
                    message.baseAttr = HeroAttribute.internalBinaryRead(reader, reader.uint32(), options, message.baseAttr);
                    break;
                case /* optional HeroExAttribute exAttr */ 18:
                    message.exAttr = HeroExAttribute.internalBinaryRead(reader, reader.uint32(), options, message.exAttr);
                    break;
                case /* optional HeroSpAttribute spAttr */ 19:
                    message.spAttr = HeroSpAttribute.internalBinaryRead(reader, reader.uint32(), options, message.spAttr);
                    break;
                case /* repeated HeroEquipAttribute equipAttrList */ 20:
                    message.equipAttrList.push(HeroEquipAttribute.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool isNew */ 21:
                    message.isNew = reader.bool();
                    break;
                case /* repeated int32 itemUnlock */ 22:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.itemUnlock.push(reader.int32());
                    else
                        message.itemUnlock.push(reader.int32());
                    break;
                case /* optional int32 talent */ 23:
                    message.talent = reader.int32();
                    break;
                case /* repeated TalentCubeInfo talentCubeInfos */ 24:
                    message.talentCubeInfos.push(TalentCubeInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int64 defaultEquipUid */ 25:
                    message.defaultEquipUid = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int64 uid = 1; */
        if (message.uid !== 0n)
            writer.tag(1, WireType.Varint).int64(message.uid);
        /* int64 userId = 2; */
        if (message.userId !== 0n)
            writer.tag(2, WireType.Varint).int64(message.userId);
        /* int32 heroId = 3; */
        if (message.heroId !== 0)
            writer.tag(3, WireType.Varint).int32(message.heroId);
        /* optional int64 createTime = 4; */
        if (message.createTime !== undefined)
            writer.tag(4, WireType.Varint).int64(message.createTime);
        /* optional int32 level = 5; */
        if (message.level !== undefined)
            writer.tag(5, WireType.Varint).int32(message.level);
        /* optional int32 exp = 6; */
        if (message.exp !== undefined)
            writer.tag(6, WireType.Varint).int32(message.exp);
        /* optional int32 rank = 7; */
        if (message.rank !== undefined)
            writer.tag(7, WireType.Varint).int32(message.rank);
        /* optional int32 breakthrough = 8; */
        if (message.breakthrough !== undefined)
            writer.tag(8, WireType.Varint).int32(message.breakthrough);
        /* optional int32 skin = 9; */
        if (message.skin !== undefined)
            writer.tag(9, WireType.Varint).int32(message.skin);
        /* optional int32 faith = 10; */
        if (message.faith !== undefined)
            writer.tag(10, WireType.Varint).int32(message.faith);
        /* optional int32 activeSkillLevel = 11; */
        if (message.activeSkillLevel !== undefined)
            writer.tag(11, WireType.Varint).int32(message.activeSkillLevel);
        /* repeated int32 passiveSkillLevel = 12; */
        for (let i = 0; i < message.passiveSkillLevel.length; i++)
            writer.tag(12, WireType.Varint).int32(message.passiveSkillLevel[i]);
        /* optional int32 exSkillLevel = 13; */
        if (message.exSkillLevel !== undefined)
            writer.tag(13, WireType.Varint).int32(message.exSkillLevel);
        /* repeated int32 voice = 14; */
        for (let i = 0; i < message.voice.length; i++)
            writer.tag(14, WireType.Varint).int32(message.voice[i]);
        /* repeated int32 voiceHeard = 15; */
        for (let i = 0; i < message.voiceHeard.length; i++)
            writer.tag(15, WireType.Varint).int32(message.voiceHeard[i]);
        /* repeated SkinInfo skinInfoList = 16; */
        for (let i = 0; i < message.skinInfoList.length; i++)
            SkinInfo.internalBinaryWrite(message.skinInfoList[i], writer.tag(16, WireType.LengthDelimited).fork(), options).join();
        /* optional HeroAttribute baseAttr = 17; */
        if (message.baseAttr)
            HeroAttribute.internalBinaryWrite(message.baseAttr, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* optional HeroExAttribute exAttr = 18; */
        if (message.exAttr)
            HeroExAttribute.internalBinaryWrite(message.exAttr, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
        /* optional HeroSpAttribute spAttr = 19; */
        if (message.spAttr)
            HeroSpAttribute.internalBinaryWrite(message.spAttr, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
        /* repeated HeroEquipAttribute equipAttrList = 20; */
        for (let i = 0; i < message.equipAttrList.length; i++)
            HeroEquipAttribute.internalBinaryWrite(message.equipAttrList[i], writer.tag(20, WireType.LengthDelimited).fork(), options).join();
        /* optional bool isNew = 21; */
        if (message.isNew !== undefined)
            writer.tag(21, WireType.Varint).bool(message.isNew);
        /* repeated int32 itemUnlock = 22; */
        for (let i = 0; i < message.itemUnlock.length; i++)
            writer.tag(22, WireType.Varint).int32(message.itemUnlock[i]);
        /* optional int32 talent = 23; */
        if (message.talent !== undefined)
            writer.tag(23, WireType.Varint).int32(message.talent);
        /* repeated TalentCubeInfo talentCubeInfos = 24; */
        for (let i = 0; i < message.talentCubeInfos.length; i++)
            TalentCubeInfo.internalBinaryWrite(message.talentCubeInfos[i], writer.tag(24, WireType.LengthDelimited).fork(), options).join();
        /* optional int64 defaultEquipUid = 25; */
        if (message.defaultEquipUid !== undefined)
            writer.tag(25, WireType.Varint).int64(message.defaultEquipUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroInfo
 */
export const HeroInfo = new HeroInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroAttribute$Type extends MessageType<HeroAttribute> {
    constructor() {
        super("HeroAttribute", [
            { no: 1, name: "hp", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "attack", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "defense", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "mdefense", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "technic", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HeroAttribute>): HeroAttribute {
        const message = { hp: 0, attack: 0, defense: 0, mdefense: 0, technic: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroAttribute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroAttribute): HeroAttribute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 hp */ 1:
                    message.hp = reader.int32();
                    break;
                case /* int32 attack */ 2:
                    message.attack = reader.int32();
                    break;
                case /* int32 defense */ 3:
                    message.defense = reader.int32();
                    break;
                case /* int32 mdefense */ 4:
                    message.mdefense = reader.int32();
                    break;
                case /* int32 technic */ 5:
                    message.technic = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroAttribute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 hp = 1; */
        if (message.hp !== 0)
            writer.tag(1, WireType.Varint).int32(message.hp);
        /* int32 attack = 2; */
        if (message.attack !== 0)
            writer.tag(2, WireType.Varint).int32(message.attack);
        /* int32 defense = 3; */
        if (message.defense !== 0)
            writer.tag(3, WireType.Varint).int32(message.defense);
        /* int32 mdefense = 4; */
        if (message.mdefense !== 0)
            writer.tag(4, WireType.Varint).int32(message.mdefense);
        /* int32 technic = 5; */
        if (message.technic !== 0)
            writer.tag(5, WireType.Varint).int32(message.technic);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroAttribute
 */
export const HeroAttribute = new HeroAttribute$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroGroupInfo$Type extends MessageType<HeroGroupInfo> {
    constructor() {
        super("HeroGroupInfo", [
            { no: 1, name: "groupId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "heroList", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "clothId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "equips", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => HeroGroupEquip },
            { no: 6, name: "activity104Equips", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => HeroGroupEquip }
        ]);
    }
    create(value?: PartialMessage<HeroGroupInfo>): HeroGroupInfo {
        const message = { groupId: 0, heroList: [], equips: [], activity104Equips: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroGroupInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroGroupInfo): HeroGroupInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 groupId */ 1:
                    message.groupId = reader.int32();
                    break;
                case /* repeated int64 heroList */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.heroList.push(reader.int64().toBigInt());
                    else
                        message.heroList.push(reader.int64().toBigInt());
                    break;
                case /* optional string name */ 3:
                    message.name = reader.string();
                    break;
                case /* optional int32 clothId */ 4:
                    message.clothId = reader.int32();
                    break;
                case /* repeated HeroGroupEquip equips */ 5:
                    message.equips.push(HeroGroupEquip.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated HeroGroupEquip activity104Equips */ 6:
                    message.activity104Equips.push(HeroGroupEquip.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroGroupInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 groupId = 1; */
        if (message.groupId !== 0)
            writer.tag(1, WireType.Varint).int32(message.groupId);
        /* repeated int64 heroList = 2; */
        for (let i = 0; i < message.heroList.length; i++)
            writer.tag(2, WireType.Varint).int64(message.heroList[i]);
        /* optional string name = 3; */
        if (message.name !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* optional int32 clothId = 4; */
        if (message.clothId !== undefined)
            writer.tag(4, WireType.Varint).int32(message.clothId);
        /* repeated HeroGroupEquip equips = 5; */
        for (let i = 0; i < message.equips.length; i++)
            HeroGroupEquip.internalBinaryWrite(message.equips[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated HeroGroupEquip activity104Equips = 6; */
        for (let i = 0; i < message.activity104Equips.length; i++)
            HeroGroupEquip.internalBinaryWrite(message.activity104Equips[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroGroupInfo
 */
export const HeroGroupInfo = new HeroGroupInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroEquipAttribute$Type extends MessageType<HeroEquipAttribute> {
    constructor() {
        super("HeroEquipAttribute", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "equipAttr", kind: "message", T: () => HeroAttribute }
        ]);
    }
    create(value?: PartialMessage<HeroEquipAttribute>): HeroEquipAttribute {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroEquipAttribute>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroEquipAttribute): HeroEquipAttribute {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* optional HeroAttribute equipAttr */ 2:
                    message.equipAttr = HeroAttribute.internalBinaryRead(reader, reader.uint32(), options, message.equipAttr);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroEquipAttribute, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* optional HeroAttribute equipAttr = 2; */
        if (message.equipAttr)
            HeroAttribute.internalBinaryWrite(message.equipAttr, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroEquipAttribute
 */
export const HeroEquipAttribute = new HeroEquipAttribute$Type();
