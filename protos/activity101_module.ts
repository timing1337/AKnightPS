// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "activity101_module.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message Act101Info
 */
export interface Act101Info {
    /**
     * @generated from protobuf field: optional uint32 id = 1;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional uint32 state = 2;
     */
    state?: number;
}
/**
 * @generated from protobuf message Get101InfosRequest
 */
export interface Get101InfosRequest {
    /**
     * @generated from protobuf field: optional int32 activityId = 1;
     */
    activityId?: number;
}
/**
 * @generated from protobuf message Get101InfosReply
 */
export interface Get101InfosReply {
    /**
     * @generated from protobuf field: Act101Info infos = 1;
     */
    infos?: Act101Info;
    /**
     * @generated from protobuf field: optional uint32 loginCount = 2;
     */
    loginCount?: number;
    /**
     * @generated from protobuf field: optional int32 activityId = 3;
     */
    activityId?: number;
}
/**
 * @generated from protobuf message Get101BonusRequest
 */
export interface Get101BonusRequest {
    /**
     * @generated from protobuf field: optional int32 activityId = 1;
     */
    activityId?: number;
    /**
     * @generated from protobuf field: optional uint32 id = 2;
     */
    id?: number;
}
/**
 * @generated from protobuf message Get101BonusReply
 */
export interface Get101BonusReply {
    /**
     * @generated from protobuf field: optional uint32 id = 1;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional int32 activityId = 2;
     */
    activityId?: number;
}
// @generated message type with reflection information, may provide speed optimized methods
class Act101Info$Type extends MessageType<Act101Info> {
    constructor() {
        super("Act101Info", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "state", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Act101Info>): Act101Info {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Act101Info>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Act101Info): Act101Info {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* optional uint32 state */ 2:
                    message.state = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Act101Info, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* optional uint32 state = 2; */
        if (message.state !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.state);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Act101Info
 */
export const Act101Info = new Act101Info$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Get101InfosRequest$Type extends MessageType<Get101InfosRequest> {
    constructor() {
        super("Get101InfosRequest", [
            { no: 1, name: "activityId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Get101InfosRequest>): Get101InfosRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Get101InfosRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Get101InfosRequest): Get101InfosRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 activityId */ 1:
                    message.activityId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Get101InfosRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 activityId = 1; */
        if (message.activityId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.activityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Get101InfosRequest
 */
export const Get101InfosRequest = new Get101InfosRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Get101InfosReply$Type extends MessageType<Get101InfosReply> {
    constructor() {
        super("Get101InfosReply", [
            { no: 1, name: "infos", kind: "message", T: () => Act101Info },
            { no: 2, name: "loginCount", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "activityId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Get101InfosReply>): Get101InfosReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Get101InfosReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Get101InfosReply): Get101InfosReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Act101Info infos */ 1:
                    message.infos = Act101Info.internalBinaryRead(reader, reader.uint32(), options, message.infos);
                    break;
                case /* optional uint32 loginCount */ 2:
                    message.loginCount = reader.uint32();
                    break;
                case /* optional int32 activityId */ 3:
                    message.activityId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Get101InfosReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Act101Info infos = 1; */
        if (message.infos)
            Act101Info.internalBinaryWrite(message.infos, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional uint32 loginCount = 2; */
        if (message.loginCount !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.loginCount);
        /* optional int32 activityId = 3; */
        if (message.activityId !== undefined)
            writer.tag(3, WireType.Varint).int32(message.activityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Get101InfosReply
 */
export const Get101InfosReply = new Get101InfosReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Get101BonusRequest$Type extends MessageType<Get101BonusRequest> {
    constructor() {
        super("Get101BonusRequest", [
            { no: 1, name: "activityId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<Get101BonusRequest>): Get101BonusRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Get101BonusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Get101BonusRequest): Get101BonusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 activityId */ 1:
                    message.activityId = reader.int32();
                    break;
                case /* optional uint32 id */ 2:
                    message.id = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Get101BonusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 activityId = 1; */
        if (message.activityId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.activityId);
        /* optional uint32 id = 2; */
        if (message.id !== undefined)
            writer.tag(2, WireType.Varint).uint32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Get101BonusRequest
 */
export const Get101BonusRequest = new Get101BonusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Get101BonusReply$Type extends MessageType<Get101BonusReply> {
    constructor() {
        super("Get101BonusReply", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "activityId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Get101BonusReply>): Get101BonusReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Get101BonusReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Get101BonusReply): Get101BonusReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 id */ 1:
                    message.id = reader.uint32();
                    break;
                case /* optional int32 activityId */ 2:
                    message.activityId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Get101BonusReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.id);
        /* optional int32 activityId = 2; */
        if (message.activityId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.activityId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Get101BonusReply
 */
export const Get101BonusReply = new Get101BonusReply$Type();
