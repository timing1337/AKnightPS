// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "hero_module.proto" (syntax proto2)
// tslint:disable
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { HeroInfo } from "./hero_def";
import { TalentCubeInfo } from "./hero_def";
/**
 * @generated from protobuf message HeroInfoListRequest
 */
export interface HeroInfoListRequest {
}
/**
 * @generated from protobuf message HeroLevelUpRequest
 */
export interface HeroLevelUpRequest {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
    /**
     * @generated from protobuf field: optional int32 expectLevel = 2;
     */
    expectLevel?: number;
}
/**
 * @generated from protobuf message UseSkinReply
 */
export interface UseSkinReply {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
    /**
     * @generated from protobuf field: optional int32 skinId = 2;
     */
    skinId?: number;
}
/**
 * @generated from protobuf message HeroGainPush
 */
export interface HeroGainPush {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
    /**
     * @generated from protobuf field: optional bool isFirst = 2;
     */
    isFirst?: boolean;
    /**
     * @generated from protobuf field: optional int32 duplicateCount = 3;
     */
    duplicateCount?: number;
}
/**
 * @generated from protobuf message HeroDefaultEquipRequest
 */
export interface HeroDefaultEquipRequest {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
    /**
     * @generated from protobuf field: optional int64 defaultEquipUid = 2;
     */
    defaultEquipUid?: bigint;
}
/**
 * @generated from protobuf message HeroLevelUpReply
 */
export interface HeroLevelUpReply {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
    /**
     * @generated from protobuf field: optional int32 newLevel = 2;
     */
    newLevel?: number;
}
/**
 * @generated from protobuf message HeroRankUpRequest
 */
export interface HeroRankUpRequest {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
}
/**
 * @generated from protobuf message HeroUpgradeSkillRequest
 */
export interface HeroUpgradeSkillRequest {
    /**
     * @generated from protobuf field: int32 heroId = 1;
     */
    heroId: number;
    /**
     * @generated from protobuf field: int32 type = 2;
     */
    type: number;
    /**
     * @generated from protobuf field: optional int32 consume = 3;
     */
    consume?: number;
}
/**
 * @generated from protobuf message UnMarkIsNewReply
 */
export interface UnMarkIsNewReply {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
}
/**
 * @generated from protobuf message HeroTouchReply
 */
export interface HeroTouchReply {
    /**
     * @generated from protobuf field: optional int32 touchCountLeft = 1;
     */
    touchCountLeft?: number;
    /**
     * @generated from protobuf field: optional bool success = 2;
     */
    success?: boolean;
}
/**
 * @generated from protobuf message TakeoffAllTalentCubeReply
 */
export interface TakeoffAllTalentCubeReply {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
}
/**
 * @generated from protobuf message HeroTalentUpReply
 */
export interface HeroTalentUpReply {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
    /**
     * @generated from protobuf field: optional int32 talentId = 2;
     */
    talentId?: number;
}
/**
 * @generated from protobuf message HeroSkinGainPush
 */
export interface HeroSkinGainPush {
    /**
     * @generated from protobuf field: optional int32 skinId = 1;
     */
    skinId?: number;
    /**
     * @generated from protobuf field: optional bool firstGain = 2;
     */
    firstGain?: boolean;
    /**
     * @generated from protobuf field: optional int32 getApproach = 3;
     */
    getApproach?: number;
}
/**
 * @generated from protobuf message HeroTouchRequest
 */
export interface HeroTouchRequest {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
}
/**
 * @generated from protobuf message UseSkinRequest
 */
export interface UseSkinRequest {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
    /**
     * @generated from protobuf field: optional int32 skinId = 2;
     */
    skinId?: number;
}
/**
 * @generated from protobuf message ItemUnlockReply
 */
export interface ItemUnlockReply {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
    /**
     * @generated from protobuf field: optional int32 itemId = 2;
     */
    itemId?: number;
}
/**
 * @generated from protobuf message PutTalentSchemeReply
 */
export interface PutTalentSchemeReply {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
    /**
     * @generated from protobuf field: repeated TalentCubeInfo cubeInfos = 2;
     */
    cubeInfos: TalentCubeInfo[];
}
/**
 * @generated from protobuf message PutTalentSchemeRequest
 */
export interface PutTalentSchemeRequest {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
    /**
     * @generated from protobuf field: optional int32 talentId = 2;
     */
    talentId?: number;
    /**
     * @generated from protobuf field: optional int32 talentMould = 3;
     */
    talentMould?: number;
    /**
     * @generated from protobuf field: optional int32 starMould = 4;
     */
    starMould?: number;
}
/**
 * @generated from protobuf message UnMarkIsNewRequest
 */
export interface UnMarkIsNewRequest {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
}
/**
 * @generated from protobuf message UnlockVoiceRequest
 */
export interface UnlockVoiceRequest {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
    /**
     * @generated from protobuf field: optional int32 voiceId = 2;
     */
    voiceId?: number;
}
/**
 * @generated from protobuf message TakeoffAllTalentCubeRequest
 */
export interface TakeoffAllTalentCubeRequest {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
}
/**
 * @generated from protobuf message HeroBirthdayInfo
 */
export interface HeroBirthdayInfo {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
    /**
     * @generated from protobuf field: optional int32 birthdayCount = 2;
     */
    birthdayCount?: number;
}
/**
 * @generated from protobuf message UnlockVoiceReply
 */
export interface UnlockVoiceReply {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
    /**
     * @generated from protobuf field: optional int32 voiceId = 2;
     */
    voiceId?: number;
}
/**
 * @generated from protobuf message ItemUnlockRequest
 */
export interface ItemUnlockRequest {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
    /**
     * @generated from protobuf field: optional int32 itemId = 2;
     */
    itemId?: number;
}
/**
 * @generated from protobuf message HeroUpgradeSkillReply
 */
export interface HeroUpgradeSkillReply {
}
/**
 * @generated from protobuf message PutTalentCubeRequest
 */
export interface PutTalentCubeRequest {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
    /**
     * @generated from protobuf field: optional TalentCubeInfo getCubeInfo = 2;
     */
    getCubeInfo?: TalentCubeInfo;
    /**
     * @generated from protobuf field: optional TalentCubeInfo putCubeInfo = 3;
     */
    putCubeInfo?: TalentCubeInfo;
}
/**
 * @generated from protobuf message HeroUpdatePush
 */
export interface HeroUpdatePush {
    /**
     * @generated from protobuf field: repeated HeroInfo heroUpdates = 1;
     */
    heroUpdates: HeroInfo[];
}
/**
 * @generated from protobuf message HeroRankUpReply
 */
export interface HeroRankUpReply {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
    /**
     * @generated from protobuf field: optional int32 newRank = 2;
     */
    newRank?: number;
}
/**
 * @generated from protobuf message HeroTalentUpRequest
 */
export interface HeroTalentUpRequest {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
}
/**
 * @generated from protobuf message HeroInfoListReply
 */
export interface HeroInfoListReply {
    /**
     * @generated from protobuf field: repeated HeroInfo heros = 1;
     */
    heros: HeroInfo[];
    /**
     * @generated from protobuf field: optional int32 touchCountLeft = 2;
     */
    touchCountLeft?: number;
    /**
     * @generated from protobuf field: repeated int32 allHeroSkin = 3;
     */
    allHeroSkin: number[];
    /**
     * @generated from protobuf field: repeated HeroBirthdayInfo birthdayInfos = 4;
     */
    birthdayInfos: HeroBirthdayInfo[];
}
/**
 * @generated from protobuf message PutTalentCubeReply
 */
export interface PutTalentCubeReply {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
    /**
     * @generated from protobuf field: repeated TalentCubeInfo cubeInfos = 2;
     */
    cubeInfos: TalentCubeInfo[];
}
/**
 * @generated from protobuf message HeroDefaultEquipReply
 */
export interface HeroDefaultEquipReply {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
    /**
     * @generated from protobuf field: optional int64 defaultEquipUid = 2;
     */
    defaultEquipUid?: bigint;
}
// @generated message type with reflection information, may provide speed optimized methods
class HeroInfoListRequest$Type extends MessageType<HeroInfoListRequest> {
    constructor() {
        super("HeroInfoListRequest", []);
    }
    create(value?: PartialMessage<HeroInfoListRequest>): HeroInfoListRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroInfoListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroInfoListRequest): HeroInfoListRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: HeroInfoListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroInfoListRequest
 */
export const HeroInfoListRequest = new HeroInfoListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroLevelUpRequest$Type extends MessageType<HeroLevelUpRequest> {
    constructor() {
        super("HeroLevelUpRequest", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "expectLevel", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HeroLevelUpRequest>): HeroLevelUpRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroLevelUpRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroLevelUpRequest): HeroLevelUpRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                case /* optional int32 expectLevel */ 2:
                    message.expectLevel = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroLevelUpRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        /* optional int32 expectLevel = 2; */
        if (message.expectLevel !== undefined)
            writer.tag(2, WireType.Varint).int32(message.expectLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroLevelUpRequest
 */
export const HeroLevelUpRequest = new HeroLevelUpRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UseSkinReply$Type extends MessageType<UseSkinReply> {
    constructor() {
        super("UseSkinReply", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "skinId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<UseSkinReply>): UseSkinReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UseSkinReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UseSkinReply): UseSkinReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                case /* optional int32 skinId */ 2:
                    message.skinId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UseSkinReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        /* optional int32 skinId = 2; */
        if (message.skinId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.skinId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UseSkinReply
 */
export const UseSkinReply = new UseSkinReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroGainPush$Type extends MessageType<HeroGainPush> {
    constructor() {
        super("HeroGainPush", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "isFirst", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "duplicateCount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HeroGainPush>): HeroGainPush {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroGainPush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroGainPush): HeroGainPush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                case /* optional bool isFirst */ 2:
                    message.isFirst = reader.bool();
                    break;
                case /* optional int32 duplicateCount */ 3:
                    message.duplicateCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroGainPush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        /* optional bool isFirst = 2; */
        if (message.isFirst !== undefined)
            writer.tag(2, WireType.Varint).bool(message.isFirst);
        /* optional int32 duplicateCount = 3; */
        if (message.duplicateCount !== undefined)
            writer.tag(3, WireType.Varint).int32(message.duplicateCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroGainPush
 */
export const HeroGainPush = new HeroGainPush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroDefaultEquipRequest$Type extends MessageType<HeroDefaultEquipRequest> {
    constructor() {
        super("HeroDefaultEquipRequest", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "defaultEquipUid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<HeroDefaultEquipRequest>): HeroDefaultEquipRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroDefaultEquipRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroDefaultEquipRequest): HeroDefaultEquipRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                case /* optional int64 defaultEquipUid */ 2:
                    message.defaultEquipUid = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroDefaultEquipRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        /* optional int64 defaultEquipUid = 2; */
        if (message.defaultEquipUid !== undefined)
            writer.tag(2, WireType.Varint).int64(message.defaultEquipUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroDefaultEquipRequest
 */
export const HeroDefaultEquipRequest = new HeroDefaultEquipRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroLevelUpReply$Type extends MessageType<HeroLevelUpReply> {
    constructor() {
        super("HeroLevelUpReply", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "newLevel", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HeroLevelUpReply>): HeroLevelUpReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroLevelUpReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroLevelUpReply): HeroLevelUpReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                case /* optional int32 newLevel */ 2:
                    message.newLevel = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroLevelUpReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        /* optional int32 newLevel = 2; */
        if (message.newLevel !== undefined)
            writer.tag(2, WireType.Varint).int32(message.newLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroLevelUpReply
 */
export const HeroLevelUpReply = new HeroLevelUpReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroRankUpRequest$Type extends MessageType<HeroRankUpRequest> {
    constructor() {
        super("HeroRankUpRequest", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HeroRankUpRequest>): HeroRankUpRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroRankUpRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroRankUpRequest): HeroRankUpRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroRankUpRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroRankUpRequest
 */
export const HeroRankUpRequest = new HeroRankUpRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroUpgradeSkillRequest$Type extends MessageType<HeroUpgradeSkillRequest> {
    constructor() {
        super("HeroUpgradeSkillRequest", [
            { no: 1, name: "heroId", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "type", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "consume", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HeroUpgradeSkillRequest>): HeroUpgradeSkillRequest {
        const message = { heroId: 0, type: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroUpgradeSkillRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroUpgradeSkillRequest): HeroUpgradeSkillRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                case /* int32 type */ 2:
                    message.type = reader.int32();
                    break;
                case /* optional int32 consume */ 3:
                    message.consume = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroUpgradeSkillRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 heroId = 1; */
        if (message.heroId !== 0)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        /* int32 type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* optional int32 consume = 3; */
        if (message.consume !== undefined)
            writer.tag(3, WireType.Varint).int32(message.consume);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroUpgradeSkillRequest
 */
export const HeroUpgradeSkillRequest = new HeroUpgradeSkillRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnMarkIsNewReply$Type extends MessageType<UnMarkIsNewReply> {
    constructor() {
        super("UnMarkIsNewReply", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<UnMarkIsNewReply>): UnMarkIsNewReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UnMarkIsNewReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnMarkIsNewReply): UnMarkIsNewReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnMarkIsNewReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UnMarkIsNewReply
 */
export const UnMarkIsNewReply = new UnMarkIsNewReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroTouchReply$Type extends MessageType<HeroTouchReply> {
    constructor() {
        super("HeroTouchReply", [
            { no: 1, name: "touchCountLeft", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "success", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<HeroTouchReply>): HeroTouchReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroTouchReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroTouchReply): HeroTouchReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 touchCountLeft */ 1:
                    message.touchCountLeft = reader.int32();
                    break;
                case /* optional bool success */ 2:
                    message.success = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroTouchReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 touchCountLeft = 1; */
        if (message.touchCountLeft !== undefined)
            writer.tag(1, WireType.Varint).int32(message.touchCountLeft);
        /* optional bool success = 2; */
        if (message.success !== undefined)
            writer.tag(2, WireType.Varint).bool(message.success);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroTouchReply
 */
export const HeroTouchReply = new HeroTouchReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TakeoffAllTalentCubeReply$Type extends MessageType<TakeoffAllTalentCubeReply> {
    constructor() {
        super("TakeoffAllTalentCubeReply", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TakeoffAllTalentCubeReply>): TakeoffAllTalentCubeReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TakeoffAllTalentCubeReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TakeoffAllTalentCubeReply): TakeoffAllTalentCubeReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TakeoffAllTalentCubeReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TakeoffAllTalentCubeReply
 */
export const TakeoffAllTalentCubeReply = new TakeoffAllTalentCubeReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroTalentUpReply$Type extends MessageType<HeroTalentUpReply> {
    constructor() {
        super("HeroTalentUpReply", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "talentId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HeroTalentUpReply>): HeroTalentUpReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroTalentUpReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroTalentUpReply): HeroTalentUpReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                case /* optional int32 talentId */ 2:
                    message.talentId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroTalentUpReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        /* optional int32 talentId = 2; */
        if (message.talentId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.talentId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroTalentUpReply
 */
export const HeroTalentUpReply = new HeroTalentUpReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroSkinGainPush$Type extends MessageType<HeroSkinGainPush> {
    constructor() {
        super("HeroSkinGainPush", [
            { no: 1, name: "skinId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "firstGain", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "getApproach", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HeroSkinGainPush>): HeroSkinGainPush {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroSkinGainPush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroSkinGainPush): HeroSkinGainPush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 skinId */ 1:
                    message.skinId = reader.int32();
                    break;
                case /* optional bool firstGain */ 2:
                    message.firstGain = reader.bool();
                    break;
                case /* optional int32 getApproach */ 3:
                    message.getApproach = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroSkinGainPush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 skinId = 1; */
        if (message.skinId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.skinId);
        /* optional bool firstGain = 2; */
        if (message.firstGain !== undefined)
            writer.tag(2, WireType.Varint).bool(message.firstGain);
        /* optional int32 getApproach = 3; */
        if (message.getApproach !== undefined)
            writer.tag(3, WireType.Varint).int32(message.getApproach);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroSkinGainPush
 */
export const HeroSkinGainPush = new HeroSkinGainPush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroTouchRequest$Type extends MessageType<HeroTouchRequest> {
    constructor() {
        super("HeroTouchRequest", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HeroTouchRequest>): HeroTouchRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroTouchRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroTouchRequest): HeroTouchRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroTouchRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroTouchRequest
 */
export const HeroTouchRequest = new HeroTouchRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UseSkinRequest$Type extends MessageType<UseSkinRequest> {
    constructor() {
        super("UseSkinRequest", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "skinId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<UseSkinRequest>): UseSkinRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UseSkinRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UseSkinRequest): UseSkinRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                case /* optional int32 skinId */ 2:
                    message.skinId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UseSkinRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        /* optional int32 skinId = 2; */
        if (message.skinId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.skinId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UseSkinRequest
 */
export const UseSkinRequest = new UseSkinRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ItemUnlockReply$Type extends MessageType<ItemUnlockReply> {
    constructor() {
        super("ItemUnlockReply", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "itemId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ItemUnlockReply>): ItemUnlockReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ItemUnlockReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ItemUnlockReply): ItemUnlockReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                case /* optional int32 itemId */ 2:
                    message.itemId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ItemUnlockReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        /* optional int32 itemId = 2; */
        if (message.itemId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.itemId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ItemUnlockReply
 */
export const ItemUnlockReply = new ItemUnlockReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PutTalentSchemeReply$Type extends MessageType<PutTalentSchemeReply> {
    constructor() {
        super("PutTalentSchemeReply", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "cubeInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TalentCubeInfo }
        ]);
    }
    create(value?: PartialMessage<PutTalentSchemeReply>): PutTalentSchemeReply {
        const message = { cubeInfos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PutTalentSchemeReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PutTalentSchemeReply): PutTalentSchemeReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                case /* repeated TalentCubeInfo cubeInfos */ 2:
                    message.cubeInfos.push(TalentCubeInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PutTalentSchemeReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        /* repeated TalentCubeInfo cubeInfos = 2; */
        for (let i = 0; i < message.cubeInfos.length; i++)
            TalentCubeInfo.internalBinaryWrite(message.cubeInfos[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PutTalentSchemeReply
 */
export const PutTalentSchemeReply = new PutTalentSchemeReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PutTalentSchemeRequest$Type extends MessageType<PutTalentSchemeRequest> {
    constructor() {
        super("PutTalentSchemeRequest", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "talentId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "talentMould", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "starMould", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PutTalentSchemeRequest>): PutTalentSchemeRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PutTalentSchemeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PutTalentSchemeRequest): PutTalentSchemeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                case /* optional int32 talentId */ 2:
                    message.talentId = reader.int32();
                    break;
                case /* optional int32 talentMould */ 3:
                    message.talentMould = reader.int32();
                    break;
                case /* optional int32 starMould */ 4:
                    message.starMould = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PutTalentSchemeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        /* optional int32 talentId = 2; */
        if (message.talentId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.talentId);
        /* optional int32 talentMould = 3; */
        if (message.talentMould !== undefined)
            writer.tag(3, WireType.Varint).int32(message.talentMould);
        /* optional int32 starMould = 4; */
        if (message.starMould !== undefined)
            writer.tag(4, WireType.Varint).int32(message.starMould);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PutTalentSchemeRequest
 */
export const PutTalentSchemeRequest = new PutTalentSchemeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnMarkIsNewRequest$Type extends MessageType<UnMarkIsNewRequest> {
    constructor() {
        super("UnMarkIsNewRequest", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<UnMarkIsNewRequest>): UnMarkIsNewRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UnMarkIsNewRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnMarkIsNewRequest): UnMarkIsNewRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnMarkIsNewRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UnMarkIsNewRequest
 */
export const UnMarkIsNewRequest = new UnMarkIsNewRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnlockVoiceRequest$Type extends MessageType<UnlockVoiceRequest> {
    constructor() {
        super("UnlockVoiceRequest", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "voiceId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<UnlockVoiceRequest>): UnlockVoiceRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UnlockVoiceRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnlockVoiceRequest): UnlockVoiceRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                case /* optional int32 voiceId */ 2:
                    message.voiceId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnlockVoiceRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        /* optional int32 voiceId = 2; */
        if (message.voiceId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.voiceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UnlockVoiceRequest
 */
export const UnlockVoiceRequest = new UnlockVoiceRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TakeoffAllTalentCubeRequest$Type extends MessageType<TakeoffAllTalentCubeRequest> {
    constructor() {
        super("TakeoffAllTalentCubeRequest", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<TakeoffAllTalentCubeRequest>): TakeoffAllTalentCubeRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TakeoffAllTalentCubeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TakeoffAllTalentCubeRequest): TakeoffAllTalentCubeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TakeoffAllTalentCubeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TakeoffAllTalentCubeRequest
 */
export const TakeoffAllTalentCubeRequest = new TakeoffAllTalentCubeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroBirthdayInfo$Type extends MessageType<HeroBirthdayInfo> {
    constructor() {
        super("HeroBirthdayInfo", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "birthdayCount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HeroBirthdayInfo>): HeroBirthdayInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroBirthdayInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroBirthdayInfo): HeroBirthdayInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                case /* optional int32 birthdayCount */ 2:
                    message.birthdayCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroBirthdayInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        /* optional int32 birthdayCount = 2; */
        if (message.birthdayCount !== undefined)
            writer.tag(2, WireType.Varint).int32(message.birthdayCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroBirthdayInfo
 */
export const HeroBirthdayInfo = new HeroBirthdayInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnlockVoiceReply$Type extends MessageType<UnlockVoiceReply> {
    constructor() {
        super("UnlockVoiceReply", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "voiceId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<UnlockVoiceReply>): UnlockVoiceReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UnlockVoiceReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnlockVoiceReply): UnlockVoiceReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                case /* optional int32 voiceId */ 2:
                    message.voiceId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnlockVoiceReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        /* optional int32 voiceId = 2; */
        if (message.voiceId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.voiceId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UnlockVoiceReply
 */
export const UnlockVoiceReply = new UnlockVoiceReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ItemUnlockRequest$Type extends MessageType<ItemUnlockRequest> {
    constructor() {
        super("ItemUnlockRequest", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "itemId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ItemUnlockRequest>): ItemUnlockRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ItemUnlockRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ItemUnlockRequest): ItemUnlockRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                case /* optional int32 itemId */ 2:
                    message.itemId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ItemUnlockRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        /* optional int32 itemId = 2; */
        if (message.itemId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.itemId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ItemUnlockRequest
 */
export const ItemUnlockRequest = new ItemUnlockRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroUpgradeSkillReply$Type extends MessageType<HeroUpgradeSkillReply> {
    constructor() {
        super("HeroUpgradeSkillReply", []);
    }
    create(value?: PartialMessage<HeroUpgradeSkillReply>): HeroUpgradeSkillReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroUpgradeSkillReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroUpgradeSkillReply): HeroUpgradeSkillReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: HeroUpgradeSkillReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroUpgradeSkillReply
 */
export const HeroUpgradeSkillReply = new HeroUpgradeSkillReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PutTalentCubeRequest$Type extends MessageType<PutTalentCubeRequest> {
    constructor() {
        super("PutTalentCubeRequest", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "getCubeInfo", kind: "message", T: () => TalentCubeInfo },
            { no: 3, name: "putCubeInfo", kind: "message", T: () => TalentCubeInfo }
        ]);
    }
    create(value?: PartialMessage<PutTalentCubeRequest>): PutTalentCubeRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PutTalentCubeRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PutTalentCubeRequest): PutTalentCubeRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                case /* optional TalentCubeInfo getCubeInfo */ 2:
                    message.getCubeInfo = TalentCubeInfo.internalBinaryRead(reader, reader.uint32(), options, message.getCubeInfo);
                    break;
                case /* optional TalentCubeInfo putCubeInfo */ 3:
                    message.putCubeInfo = TalentCubeInfo.internalBinaryRead(reader, reader.uint32(), options, message.putCubeInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PutTalentCubeRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        /* optional TalentCubeInfo getCubeInfo = 2; */
        if (message.getCubeInfo)
            TalentCubeInfo.internalBinaryWrite(message.getCubeInfo, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional TalentCubeInfo putCubeInfo = 3; */
        if (message.putCubeInfo)
            TalentCubeInfo.internalBinaryWrite(message.putCubeInfo, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PutTalentCubeRequest
 */
export const PutTalentCubeRequest = new PutTalentCubeRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroUpdatePush$Type extends MessageType<HeroUpdatePush> {
    constructor() {
        super("HeroUpdatePush", [
            { no: 1, name: "heroUpdates", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => HeroInfo }
        ]);
    }
    create(value?: PartialMessage<HeroUpdatePush>): HeroUpdatePush {
        const message = { heroUpdates: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroUpdatePush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroUpdatePush): HeroUpdatePush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated HeroInfo heroUpdates */ 1:
                    message.heroUpdates.push(HeroInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroUpdatePush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated HeroInfo heroUpdates = 1; */
        for (let i = 0; i < message.heroUpdates.length; i++)
            HeroInfo.internalBinaryWrite(message.heroUpdates[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroUpdatePush
 */
export const HeroUpdatePush = new HeroUpdatePush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroRankUpReply$Type extends MessageType<HeroRankUpReply> {
    constructor() {
        super("HeroRankUpReply", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "newRank", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HeroRankUpReply>): HeroRankUpReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroRankUpReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroRankUpReply): HeroRankUpReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                case /* optional int32 newRank */ 2:
                    message.newRank = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroRankUpReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        /* optional int32 newRank = 2; */
        if (message.newRank !== undefined)
            writer.tag(2, WireType.Varint).int32(message.newRank);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroRankUpReply
 */
export const HeroRankUpReply = new HeroRankUpReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroTalentUpRequest$Type extends MessageType<HeroTalentUpRequest> {
    constructor() {
        super("HeroTalentUpRequest", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HeroTalentUpRequest>): HeroTalentUpRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroTalentUpRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroTalentUpRequest): HeroTalentUpRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroTalentUpRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroTalentUpRequest
 */
export const HeroTalentUpRequest = new HeroTalentUpRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroInfoListReply$Type extends MessageType<HeroInfoListReply> {
    constructor() {
        super("HeroInfoListReply", [
            { no: 1, name: "heros", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => HeroInfo },
            { no: 2, name: "touchCountLeft", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "allHeroSkin", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "birthdayInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => HeroBirthdayInfo }
        ]);
    }
    create(value?: PartialMessage<HeroInfoListReply>): HeroInfoListReply {
        const message = { heros: [], allHeroSkin: [], birthdayInfos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroInfoListReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroInfoListReply): HeroInfoListReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated HeroInfo heros */ 1:
                    message.heros.push(HeroInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 touchCountLeft */ 2:
                    message.touchCountLeft = reader.int32();
                    break;
                case /* repeated int32 allHeroSkin */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.allHeroSkin.push(reader.int32());
                    else
                        message.allHeroSkin.push(reader.int32());
                    break;
                case /* repeated HeroBirthdayInfo birthdayInfos */ 4:
                    message.birthdayInfos.push(HeroBirthdayInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroInfoListReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated HeroInfo heros = 1; */
        for (let i = 0; i < message.heros.length; i++)
            HeroInfo.internalBinaryWrite(message.heros[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 touchCountLeft = 2; */
        if (message.touchCountLeft !== undefined)
            writer.tag(2, WireType.Varint).int32(message.touchCountLeft);
        /* repeated int32 allHeroSkin = 3; */
        for (let i = 0; i < message.allHeroSkin.length; i++)
            writer.tag(3, WireType.Varint).int32(message.allHeroSkin[i]);
        /* repeated HeroBirthdayInfo birthdayInfos = 4; */
        for (let i = 0; i < message.birthdayInfos.length; i++)
            HeroBirthdayInfo.internalBinaryWrite(message.birthdayInfos[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroInfoListReply
 */
export const HeroInfoListReply = new HeroInfoListReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PutTalentCubeReply$Type extends MessageType<PutTalentCubeReply> {
    constructor() {
        super("PutTalentCubeReply", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "cubeInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TalentCubeInfo }
        ]);
    }
    create(value?: PartialMessage<PutTalentCubeReply>): PutTalentCubeReply {
        const message = { cubeInfos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PutTalentCubeReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PutTalentCubeReply): PutTalentCubeReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                case /* repeated TalentCubeInfo cubeInfos */ 2:
                    message.cubeInfos.push(TalentCubeInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PutTalentCubeReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        /* repeated TalentCubeInfo cubeInfos = 2; */
        for (let i = 0; i < message.cubeInfos.length; i++)
            TalentCubeInfo.internalBinaryWrite(message.cubeInfos[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PutTalentCubeReply
 */
export const PutTalentCubeReply = new PutTalentCubeReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HeroDefaultEquipReply$Type extends MessageType<HeroDefaultEquipReply> {
    constructor() {
        super("HeroDefaultEquipReply", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "defaultEquipUid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<HeroDefaultEquipReply>): HeroDefaultEquipReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HeroDefaultEquipReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HeroDefaultEquipReply): HeroDefaultEquipReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                case /* optional int64 defaultEquipUid */ 2:
                    message.defaultEquipUid = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HeroDefaultEquipReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        /* optional int64 defaultEquipUid = 2; */
        if (message.defaultEquipUid !== undefined)
            writer.tag(2, WireType.Varint).int64(message.defaultEquipUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HeroDefaultEquipReply
 */
export const HeroDefaultEquipReply = new HeroDefaultEquipReply$Type();
