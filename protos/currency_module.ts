// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "currency_module.proto" (syntax proto2)
// tslint:disable
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message GetBuyPowerInfoRequest
 */
export interface GetBuyPowerInfoRequest {
}
/**
 * @generated from protobuf message BuyPowerReply
 */
export interface BuyPowerReply {
    /**
     * @generated from protobuf field: optional int32 canBuyCount = 1;
     */
    canBuyCount?: number;
}
/**
 * @generated from protobuf message ExchangeDiamondReply
 */
export interface ExchangeDiamondReply {
    /**
     * @generated from protobuf field: optional int32 exchangeDiamond = 1;
     */
    exchangeDiamond?: number;
    /**
     * @generated from protobuf field: optional int32 opType = 2;
     */
    opType?: number;
}
/**
 * @generated from protobuf message Currency
 */
export interface Currency {
    /**
     * @generated from protobuf field: optional uint32 currencyId = 1;
     */
    currencyId?: number;
    /**
     * @generated from protobuf field: optional int32 quantity = 2;
     */
    quantity?: number;
    /**
     * @generated from protobuf field: optional uint64 lastRecoverTime = 3;
     */
    lastRecoverTime?: bigint;
    /**
     * @generated from protobuf field: optional uint64 expiredTime = 4;
     */
    expiredTime?: bigint;
}
/**
 * @generated from protobuf message GetBuyPowerInfoReply
 */
export interface GetBuyPowerInfoReply {
    /**
     * @generated from protobuf field: optional int32 canBuyCount = 1;
     */
    canBuyCount?: number;
}
/**
 * @generated from protobuf message CurrencyChangePush
 */
export interface CurrencyChangePush {
    /**
     * @generated from protobuf field: Currency changeCurrency = 1;
     */
    changeCurrency?: Currency;
}
/**
 * @generated from protobuf message BuyPowerRequest
 */
export interface BuyPowerRequest {
}
/**
 * @generated from protobuf message ExchangeDiamondRequest
 */
export interface ExchangeDiamondRequest {
    /**
     * @generated from protobuf field: optional int32 exchangeDiamond = 1;
     */
    exchangeDiamond?: number;
    /**
     * @generated from protobuf field: optional int32 opType = 2;
     */
    opType?: number;
}
/**
 * @generated from protobuf message GetCurrencyListRequest
 */
export interface GetCurrencyListRequest {
    /**
     * @generated from protobuf field: int32 currencyIds = 1;
     */
    currencyIds: number;
}
/**
 * @generated from protobuf message GetCurrencyListReply
 */
export interface GetCurrencyListReply {
    /**
     * @generated from protobuf field: Currency currencyList = 1;
     */
    currencyList?: Currency;
}
// @generated message type with reflection information, may provide speed optimized methods
class GetBuyPowerInfoRequest$Type extends MessageType<GetBuyPowerInfoRequest> {
    constructor() {
        super("GetBuyPowerInfoRequest", []);
    }
    create(value?: PartialMessage<GetBuyPowerInfoRequest>): GetBuyPowerInfoRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetBuyPowerInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBuyPowerInfoRequest): GetBuyPowerInfoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetBuyPowerInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetBuyPowerInfoRequest
 */
export const GetBuyPowerInfoRequest = new GetBuyPowerInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuyPowerReply$Type extends MessageType<BuyPowerReply> {
    constructor() {
        super("BuyPowerReply", [
            { no: 1, name: "canBuyCount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BuyPowerReply>): BuyPowerReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuyPowerReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuyPowerReply): BuyPowerReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 canBuyCount */ 1:
                    message.canBuyCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuyPowerReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 canBuyCount = 1; */
        if (message.canBuyCount !== undefined)
            writer.tag(1, WireType.Varint).int32(message.canBuyCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BuyPowerReply
 */
export const BuyPowerReply = new BuyPowerReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExchangeDiamondReply$Type extends MessageType<ExchangeDiamondReply> {
    constructor() {
        super("ExchangeDiamondReply", [
            { no: 1, name: "exchangeDiamond", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "opType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ExchangeDiamondReply>): ExchangeDiamondReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExchangeDiamondReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExchangeDiamondReply): ExchangeDiamondReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 exchangeDiamond */ 1:
                    message.exchangeDiamond = reader.int32();
                    break;
                case /* optional int32 opType */ 2:
                    message.opType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExchangeDiamondReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 exchangeDiamond = 1; */
        if (message.exchangeDiamond !== undefined)
            writer.tag(1, WireType.Varint).int32(message.exchangeDiamond);
        /* optional int32 opType = 2; */
        if (message.opType !== undefined)
            writer.tag(2, WireType.Varint).int32(message.opType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExchangeDiamondReply
 */
export const ExchangeDiamondReply = new ExchangeDiamondReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Currency$Type extends MessageType<Currency> {
    constructor() {
        super("Currency", [
            { no: 1, name: "currencyId", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "quantity", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "lastRecoverTime", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "expiredTime", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Currency>): Currency {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Currency>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Currency): Currency {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint32 currencyId */ 1:
                    message.currencyId = reader.uint32();
                    break;
                case /* optional int32 quantity */ 2:
                    message.quantity = reader.int32();
                    break;
                case /* optional uint64 lastRecoverTime */ 3:
                    message.lastRecoverTime = reader.uint64().toBigInt();
                    break;
                case /* optional uint64 expiredTime */ 4:
                    message.expiredTime = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Currency, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint32 currencyId = 1; */
        if (message.currencyId !== undefined)
            writer.tag(1, WireType.Varint).uint32(message.currencyId);
        /* optional int32 quantity = 2; */
        if (message.quantity !== undefined)
            writer.tag(2, WireType.Varint).int32(message.quantity);
        /* optional uint64 lastRecoverTime = 3; */
        if (message.lastRecoverTime !== undefined)
            writer.tag(3, WireType.Varint).uint64(message.lastRecoverTime);
        /* optional uint64 expiredTime = 4; */
        if (message.expiredTime !== undefined)
            writer.tag(4, WireType.Varint).uint64(message.expiredTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Currency
 */
export const Currency = new Currency$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBuyPowerInfoReply$Type extends MessageType<GetBuyPowerInfoReply> {
    constructor() {
        super("GetBuyPowerInfoReply", [
            { no: 1, name: "canBuyCount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetBuyPowerInfoReply>): GetBuyPowerInfoReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetBuyPowerInfoReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBuyPowerInfoReply): GetBuyPowerInfoReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 canBuyCount */ 1:
                    message.canBuyCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBuyPowerInfoReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 canBuyCount = 1; */
        if (message.canBuyCount !== undefined)
            writer.tag(1, WireType.Varint).int32(message.canBuyCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetBuyPowerInfoReply
 */
export const GetBuyPowerInfoReply = new GetBuyPowerInfoReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CurrencyChangePush$Type extends MessageType<CurrencyChangePush> {
    constructor() {
        super("CurrencyChangePush", [
            { no: 1, name: "changeCurrency", kind: "message", T: () => Currency }
        ]);
    }
    create(value?: PartialMessage<CurrencyChangePush>): CurrencyChangePush {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CurrencyChangePush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CurrencyChangePush): CurrencyChangePush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Currency changeCurrency */ 1:
                    message.changeCurrency = Currency.internalBinaryRead(reader, reader.uint32(), options, message.changeCurrency);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CurrencyChangePush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Currency changeCurrency = 1; */
        if (message.changeCurrency)
            Currency.internalBinaryWrite(message.changeCurrency, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CurrencyChangePush
 */
export const CurrencyChangePush = new CurrencyChangePush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuyPowerRequest$Type extends MessageType<BuyPowerRequest> {
    constructor() {
        super("BuyPowerRequest", []);
    }
    create(value?: PartialMessage<BuyPowerRequest>): BuyPowerRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuyPowerRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuyPowerRequest): BuyPowerRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: BuyPowerRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BuyPowerRequest
 */
export const BuyPowerRequest = new BuyPowerRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ExchangeDiamondRequest$Type extends MessageType<ExchangeDiamondRequest> {
    constructor() {
        super("ExchangeDiamondRequest", [
            { no: 1, name: "exchangeDiamond", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "opType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ExchangeDiamondRequest>): ExchangeDiamondRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ExchangeDiamondRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ExchangeDiamondRequest): ExchangeDiamondRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 exchangeDiamond */ 1:
                    message.exchangeDiamond = reader.int32();
                    break;
                case /* optional int32 opType */ 2:
                    message.opType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ExchangeDiamondRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 exchangeDiamond = 1; */
        if (message.exchangeDiamond !== undefined)
            writer.tag(1, WireType.Varint).int32(message.exchangeDiamond);
        /* optional int32 opType = 2; */
        if (message.opType !== undefined)
            writer.tag(2, WireType.Varint).int32(message.opType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ExchangeDiamondRequest
 */
export const ExchangeDiamondRequest = new ExchangeDiamondRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCurrencyListRequest$Type extends MessageType<GetCurrencyListRequest> {
    constructor() {
        super("GetCurrencyListRequest", [
            { no: 1, name: "currencyIds", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetCurrencyListRequest>): GetCurrencyListRequest {
        const message = { currencyIds: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetCurrencyListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCurrencyListRequest): GetCurrencyListRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 currencyIds */ 1:
                    message.currencyIds = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCurrencyListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 currencyIds = 1; */
        if (message.currencyIds !== 0)
            writer.tag(1, WireType.Varint).int32(message.currencyIds);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetCurrencyListRequest
 */
export const GetCurrencyListRequest = new GetCurrencyListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCurrencyListReply$Type extends MessageType<GetCurrencyListReply> {
    constructor() {
        super("GetCurrencyListReply", [
            { no: 1, name: "currencyList", kind: "message", T: () => Currency }
        ]);
    }
    create(value?: PartialMessage<GetCurrencyListReply>): GetCurrencyListReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetCurrencyListReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCurrencyListReply): GetCurrencyListReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* Currency currencyList */ 1:
                    message.currencyList = Currency.internalBinaryRead(reader, reader.uint32(), options, message.currencyList);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCurrencyListReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* Currency currencyList = 1; */
        if (message.currencyList)
            Currency.internalBinaryWrite(message.currencyList, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetCurrencyListReply
 */
export const GetCurrencyListReply = new GetCurrencyListReply$Type();
