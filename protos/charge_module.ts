// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "charge_module.proto" (syntax proto2)
// tslint:disable
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message GetChargeInfoRequest
 */
export interface GetChargeInfoRequest {
}
/**
 * @generated from protobuf message GetMonthCardBonusReply
 */
export interface GetMonthCardBonusReply {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
}
/**
 * @generated from protobuf message GetChargeInfoReply
 */
export interface GetChargeInfoReply {
    /**
     * @generated from protobuf field: repeated ChargeInfo infos = 1;
     */
    infos: ChargeInfo[];
    /**
     * @generated from protobuf field: optional bool sandboxEnable = 2;
     */
    sandboxEnable?: boolean;
    /**
     * @generated from protobuf field: optional int32 sandboxBalance = 3;
     */
    sandboxBalance?: number;
}
/**
 * @generated from protobuf message NewOrderReply
 */
export interface NewOrderReply {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional string passBackParam = 2;
     */
    passBackParam?: string;
    /**
     * @generated from protobuf field: optional string notifyUrl = 3;
     */
    notifyUrl?: string;
    /**
     * @generated from protobuf field: optional int64 gameOrderId = 4;
     */
    gameOrderId?: bigint;
    /**
     * @generated from protobuf field: optional int64 timestamp = 5;
     */
    timestamp?: bigint;
    /**
     * @generated from protobuf field: optional string sign = 6;
     */
    sign?: string;
    /**
     * @generated from protobuf field: optional int32 serverId = 7;
     */
    serverId?: number;
    /**
     * @generated from protobuf field: optional string currency = 8;
     */
    currency?: string;
}
/**
 * @generated from protobuf message OrderCompletePush
 */
export interface OrderCompletePush {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional int64 gameOrderId = 2;
     */
    gameOrderId?: bigint;
}
/**
 * @generated from protobuf message NewOrderRequest
 */
export interface NewOrderRequest {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional string originCurrency = 2;
     */
    originCurrency?: string;
    /**
     * @generated from protobuf field: optional int32 originAmount = 3;
     */
    originAmount?: number;
}
/**
 * @generated from protobuf message SandboxChargeRequset
 */
export interface SandboxChargeRequset {
    /**
     * @generated from protobuf field: optional int64 gameOrderId = 1;
     */
    gameOrderId?: bigint;
}
/**
 * @generated from protobuf message ChargeInfo
 */
export interface ChargeInfo {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional int32 buyCount = 2;
     */
    buyCount?: number;
}
/**
 * @generated from protobuf message SandboxChargeReply
 */
export interface SandboxChargeReply {
    /**
     * @generated from protobuf field: optional int64 gameOrderId = 1;
     */
    gameOrderId?: bigint;
    /**
     * @generated from protobuf field: optional int32 sandboxBalance = 2;
     */
    sandboxBalance?: number;
}
/**
 * @generated from protobuf message ReadChargeNewRequest
 */
export interface ReadChargeNewRequest {
    /**
     * @generated from protobuf field: repeated int32 goodsIds = 1;
     */
    goodsIds: number[];
}
/**
 * @generated from protobuf message GetMonthCardInfoRequest
 */
export interface GetMonthCardInfoRequest {
}
/**
 * @generated from protobuf message GetMonthCardInfoReply
 */
export interface GetMonthCardInfoReply {
    /**
     * @generated from protobuf field: repeated MonthCardInfo infos = 1;
     */
    infos: MonthCardInfo[];
}
/**
 * @generated from protobuf message ReadChargeNewReply
 */
export interface ReadChargeNewReply {
    /**
     * @generated from protobuf field: repeated int32 goodsIds = 1;
     */
    goodsIds: number[];
}
/**
 * @generated from protobuf message MonthCardInfo
 */
export interface MonthCardInfo {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional int32 expireTime = 2;
     */
    expireTime?: number;
    /**
     * @generated from protobuf field: optional bool hasGetBonus = 3;
     */
    hasGetBonus?: boolean;
}
/**
 * @generated from protobuf message GetMonthCardBonusRequest
 */
export interface GetMonthCardBonusRequest {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
}
// @generated message type with reflection information, may provide speed optimized methods
class GetChargeInfoRequest$Type extends MessageType<GetChargeInfoRequest> {
    constructor() {
        super("GetChargeInfoRequest", []);
    }
    create(value?: PartialMessage<GetChargeInfoRequest>): GetChargeInfoRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetChargeInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetChargeInfoRequest): GetChargeInfoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetChargeInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetChargeInfoRequest
 */
export const GetChargeInfoRequest = new GetChargeInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMonthCardBonusReply$Type extends MessageType<GetMonthCardBonusReply> {
    constructor() {
        super("GetMonthCardBonusReply", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetMonthCardBonusReply>): GetMonthCardBonusReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMonthCardBonusReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMonthCardBonusReply): GetMonthCardBonusReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMonthCardBonusReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetMonthCardBonusReply
 */
export const GetMonthCardBonusReply = new GetMonthCardBonusReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetChargeInfoReply$Type extends MessageType<GetChargeInfoReply> {
    constructor() {
        super("GetChargeInfoReply", [
            { no: 1, name: "infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ChargeInfo },
            { no: 2, name: "sandboxEnable", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "sandboxBalance", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetChargeInfoReply>): GetChargeInfoReply {
        const message = { infos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetChargeInfoReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetChargeInfoReply): GetChargeInfoReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ChargeInfo infos */ 1:
                    message.infos.push(ChargeInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool sandboxEnable */ 2:
                    message.sandboxEnable = reader.bool();
                    break;
                case /* optional int32 sandboxBalance */ 3:
                    message.sandboxBalance = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetChargeInfoReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ChargeInfo infos = 1; */
        for (let i = 0; i < message.infos.length; i++)
            ChargeInfo.internalBinaryWrite(message.infos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional bool sandboxEnable = 2; */
        if (message.sandboxEnable !== undefined)
            writer.tag(2, WireType.Varint).bool(message.sandboxEnable);
        /* optional int32 sandboxBalance = 3; */
        if (message.sandboxBalance !== undefined)
            writer.tag(3, WireType.Varint).int32(message.sandboxBalance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetChargeInfoReply
 */
export const GetChargeInfoReply = new GetChargeInfoReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NewOrderReply$Type extends MessageType<NewOrderReply> {
    constructor() {
        super("NewOrderReply", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "passBackParam", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "notifyUrl", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "gameOrderId", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "timestamp", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "sign", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "serverId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "currency", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<NewOrderReply>): NewOrderReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NewOrderReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NewOrderReply): NewOrderReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* optional string passBackParam */ 2:
                    message.passBackParam = reader.string();
                    break;
                case /* optional string notifyUrl */ 3:
                    message.notifyUrl = reader.string();
                    break;
                case /* optional int64 gameOrderId */ 4:
                    message.gameOrderId = reader.int64().toBigInt();
                    break;
                case /* optional int64 timestamp */ 5:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                case /* optional string sign */ 6:
                    message.sign = reader.string();
                    break;
                case /* optional int32 serverId */ 7:
                    message.serverId = reader.int32();
                    break;
                case /* optional string currency */ 8:
                    message.currency = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NewOrderReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* optional string passBackParam = 2; */
        if (message.passBackParam !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.passBackParam);
        /* optional string notifyUrl = 3; */
        if (message.notifyUrl !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.notifyUrl);
        /* optional int64 gameOrderId = 4; */
        if (message.gameOrderId !== undefined)
            writer.tag(4, WireType.Varint).int64(message.gameOrderId);
        /* optional int64 timestamp = 5; */
        if (message.timestamp !== undefined)
            writer.tag(5, WireType.Varint).int64(message.timestamp);
        /* optional string sign = 6; */
        if (message.sign !== undefined)
            writer.tag(6, WireType.LengthDelimited).string(message.sign);
        /* optional int32 serverId = 7; */
        if (message.serverId !== undefined)
            writer.tag(7, WireType.Varint).int32(message.serverId);
        /* optional string currency = 8; */
        if (message.currency !== undefined)
            writer.tag(8, WireType.LengthDelimited).string(message.currency);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message NewOrderReply
 */
export const NewOrderReply = new NewOrderReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OrderCompletePush$Type extends MessageType<OrderCompletePush> {
    constructor() {
        super("OrderCompletePush", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "gameOrderId", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<OrderCompletePush>): OrderCompletePush {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OrderCompletePush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OrderCompletePush): OrderCompletePush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* optional int64 gameOrderId */ 2:
                    message.gameOrderId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OrderCompletePush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* optional int64 gameOrderId = 2; */
        if (message.gameOrderId !== undefined)
            writer.tag(2, WireType.Varint).int64(message.gameOrderId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message OrderCompletePush
 */
export const OrderCompletePush = new OrderCompletePush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class NewOrderRequest$Type extends MessageType<NewOrderRequest> {
    constructor() {
        super("NewOrderRequest", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "originCurrency", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "originAmount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<NewOrderRequest>): NewOrderRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<NewOrderRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: NewOrderRequest): NewOrderRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* optional string originCurrency */ 2:
                    message.originCurrency = reader.string();
                    break;
                case /* optional int32 originAmount */ 3:
                    message.originAmount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: NewOrderRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* optional string originCurrency = 2; */
        if (message.originCurrency !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.originCurrency);
        /* optional int32 originAmount = 3; */
        if (message.originAmount !== undefined)
            writer.tag(3, WireType.Varint).int32(message.originAmount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message NewOrderRequest
 */
export const NewOrderRequest = new NewOrderRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SandboxChargeRequset$Type extends MessageType<SandboxChargeRequset> {
    constructor() {
        super("SandboxChargeRequset", [
            { no: 1, name: "gameOrderId", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<SandboxChargeRequset>): SandboxChargeRequset {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SandboxChargeRequset>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SandboxChargeRequset): SandboxChargeRequset {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 gameOrderId */ 1:
                    message.gameOrderId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SandboxChargeRequset, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 gameOrderId = 1; */
        if (message.gameOrderId !== undefined)
            writer.tag(1, WireType.Varint).int64(message.gameOrderId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SandboxChargeRequset
 */
export const SandboxChargeRequset = new SandboxChargeRequset$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ChargeInfo$Type extends MessageType<ChargeInfo> {
    constructor() {
        super("ChargeInfo", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "buyCount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ChargeInfo>): ChargeInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ChargeInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ChargeInfo): ChargeInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* optional int32 buyCount */ 2:
                    message.buyCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ChargeInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* optional int32 buyCount = 2; */
        if (message.buyCount !== undefined)
            writer.tag(2, WireType.Varint).int32(message.buyCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ChargeInfo
 */
export const ChargeInfo = new ChargeInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SandboxChargeReply$Type extends MessageType<SandboxChargeReply> {
    constructor() {
        super("SandboxChargeReply", [
            { no: 1, name: "gameOrderId", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "sandboxBalance", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SandboxChargeReply>): SandboxChargeReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SandboxChargeReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SandboxChargeReply): SandboxChargeReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 gameOrderId */ 1:
                    message.gameOrderId = reader.int64().toBigInt();
                    break;
                case /* optional int32 sandboxBalance */ 2:
                    message.sandboxBalance = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SandboxChargeReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 gameOrderId = 1; */
        if (message.gameOrderId !== undefined)
            writer.tag(1, WireType.Varint).int64(message.gameOrderId);
        /* optional int32 sandboxBalance = 2; */
        if (message.sandboxBalance !== undefined)
            writer.tag(2, WireType.Varint).int32(message.sandboxBalance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SandboxChargeReply
 */
export const SandboxChargeReply = new SandboxChargeReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadChargeNewRequest$Type extends MessageType<ReadChargeNewRequest> {
    constructor() {
        super("ReadChargeNewRequest", [
            { no: 1, name: "goodsIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ReadChargeNewRequest>): ReadChargeNewRequest {
        const message = { goodsIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadChargeNewRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadChargeNewRequest): ReadChargeNewRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 goodsIds */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.goodsIds.push(reader.int32());
                    else
                        message.goodsIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadChargeNewRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 goodsIds = 1; */
        for (let i = 0; i < message.goodsIds.length; i++)
            writer.tag(1, WireType.Varint).int32(message.goodsIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ReadChargeNewRequest
 */
export const ReadChargeNewRequest = new ReadChargeNewRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMonthCardInfoRequest$Type extends MessageType<GetMonthCardInfoRequest> {
    constructor() {
        super("GetMonthCardInfoRequest", []);
    }
    create(value?: PartialMessage<GetMonthCardInfoRequest>): GetMonthCardInfoRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMonthCardInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMonthCardInfoRequest): GetMonthCardInfoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetMonthCardInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetMonthCardInfoRequest
 */
export const GetMonthCardInfoRequest = new GetMonthCardInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMonthCardInfoReply$Type extends MessageType<GetMonthCardInfoReply> {
    constructor() {
        super("GetMonthCardInfoReply", [
            { no: 1, name: "infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => MonthCardInfo }
        ]);
    }
    create(value?: PartialMessage<GetMonthCardInfoReply>): GetMonthCardInfoReply {
        const message = { infos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMonthCardInfoReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMonthCardInfoReply): GetMonthCardInfoReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated MonthCardInfo infos */ 1:
                    message.infos.push(MonthCardInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMonthCardInfoReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated MonthCardInfo infos = 1; */
        for (let i = 0; i < message.infos.length; i++)
            MonthCardInfo.internalBinaryWrite(message.infos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetMonthCardInfoReply
 */
export const GetMonthCardInfoReply = new GetMonthCardInfoReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ReadChargeNewReply$Type extends MessageType<ReadChargeNewReply> {
    constructor() {
        super("ReadChargeNewReply", [
            { no: 1, name: "goodsIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ReadChargeNewReply>): ReadChargeNewReply {
        const message = { goodsIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ReadChargeNewReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ReadChargeNewReply): ReadChargeNewReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 goodsIds */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.goodsIds.push(reader.int32());
                    else
                        message.goodsIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ReadChargeNewReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 goodsIds = 1; */
        for (let i = 0; i < message.goodsIds.length; i++)
            writer.tag(1, WireType.Varint).int32(message.goodsIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ReadChargeNewReply
 */
export const ReadChargeNewReply = new ReadChargeNewReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MonthCardInfo$Type extends MessageType<MonthCardInfo> {
    constructor() {
        super("MonthCardInfo", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "expireTime", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "hasGetBonus", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<MonthCardInfo>): MonthCardInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MonthCardInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MonthCardInfo): MonthCardInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* optional int32 expireTime */ 2:
                    message.expireTime = reader.int32();
                    break;
                case /* optional bool hasGetBonus */ 3:
                    message.hasGetBonus = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MonthCardInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* optional int32 expireTime = 2; */
        if (message.expireTime !== undefined)
            writer.tag(2, WireType.Varint).int32(message.expireTime);
        /* optional bool hasGetBonus = 3; */
        if (message.hasGetBonus !== undefined)
            writer.tag(3, WireType.Varint).bool(message.hasGetBonus);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MonthCardInfo
 */
export const MonthCardInfo = new MonthCardInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetMonthCardBonusRequest$Type extends MessageType<GetMonthCardBonusRequest> {
    constructor() {
        super("GetMonthCardBonusRequest", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetMonthCardBonusRequest>): GetMonthCardBonusRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetMonthCardBonusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetMonthCardBonusRequest): GetMonthCardBonusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetMonthCardBonusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetMonthCardBonusRequest
 */
export const GetMonthCardBonusRequest = new GetMonthCardBonusRequest$Type();
