// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "fight_def.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { HeroAttribute } from "./hero_def";
/**
 * @generated from protobuf message MoveCardOper
 */
export interface MoveCardOper {
    /**
     * @generated from protobuf field: optional int32 fromPosition = 1;
     */
    fromPosition?: number;
    /**
     * @generated from protobuf field: optional int32 toPosition = 2;
     */
    toPosition?: number;
}
/**
 * @generated from protobuf message FightRecord
 */
export interface FightRecord {
    /**
     * @generated from protobuf field: optional int64 fightId = 1;
     */
    fightId?: bigint;
    /**
     * @generated from protobuf field: optional string fightName = 2;
     */
    fightName?: string;
    /**
     * @generated from protobuf field: optional int64 fightTime = 3;
     */
    fightTime?: bigint;
    /**
     * @generated from protobuf field: optional int32 fightResult = 4;
     */
    fightResult?: number;
    /**
     * @generated from protobuf field: repeated FightStatistics attackStatistics = 5;
     */
    attackStatistics: FightStatistics[];
    /**
     * @generated from protobuf field: repeated FightStatistics defenseStatistics = 6;
     */
    defenseStatistics: FightStatistics[];
}
/**
 * @generated from protobuf message FightExPointInfo
 */
export interface FightExPointInfo {
    /**
     * @generated from protobuf field: optional int64 uid = 1;
     */
    uid?: bigint;
    /**
     * @generated from protobuf field: optional int32 exPoint = 2;
     */
    exPoint?: number;
}
/**
 * @generated from protobuf message FightRound
 */
export interface FightRound {
    /**
     * @generated from protobuf field: repeated FightStep fightStep = 1;
     */
    fightStep: FightStep[];
    /**
     * @generated from protobuf field: optional int32 actPoint = 2;
     */
    actPoint?: number;
    /**
     * @generated from protobuf field: optional bool isFinish = 3;
     */
    isFinish?: boolean;
    /**
     * @generated from protobuf field: optional int32 moveNum = 4;
     */
    moveNum?: number;
    /**
     * @generated from protobuf field: repeated FightExPointInfo exPointInfo = 5;
     */
    exPointInfo: FightExPointInfo[];
    /**
     * @generated from protobuf field: repeated CardInfo aiUseCards = 6;
     */
    aiUseCards: CardInfo[];
    /**
     * @generated from protobuf field: optional int32 power = 7;
     */
    power?: number;
    /**
     * @generated from protobuf field: repeated PlayerSkillInfo skillInfos = 8;
     */
    skillInfos: PlayerSkillInfo[];
    /**
     * @generated from protobuf field: repeated CardInfo beforeCards1 = 9;
     */
    beforeCards1: CardInfo[];
    /**
     * @generated from protobuf field: repeated CardInfo teamACards1 = 10;
     */
    teamACards1: CardInfo[];
    /**
     * @generated from protobuf field: repeated CardInfo beforeCards2 = 11;
     */
    beforeCards2: CardInfo[];
    /**
     * @generated from protobuf field: repeated CardInfo teamACards2 = 12;
     */
    teamACards2: CardInfo[];
    /**
     * @generated from protobuf field: repeated FightStep nextRoundBeginStep = 13;
     */
    nextRoundBeginStep: FightStep[];
    /**
     * @generated from protobuf field: repeated int32 useCardList = 14;
     */
    useCardList: number[];
    /**
     * @generated from protobuf field: repeated FightExPointInfo beginExPointInfo = 15;
     */
    beginExPointInfo: FightExPointInfo[];
}
/**
 * @generated from protobuf message TrialHero
 */
export interface TrialHero {
    /**
     * @generated from protobuf field: optional int32 trialId = 1;
     */
    trialId?: number;
    /**
     * @generated from protobuf field: optional int32 pos = 2;
     */
    pos?: number;
    /**
     * @generated from protobuf field: repeated int64 equipUid = 3;
     */
    equipUid: bigint[];
}
/**
 * @generated from protobuf message FightGroupRecord
 */
export interface FightGroupRecord {
    /**
     * @generated from protobuf field: repeated FightHeroRecord heroList = 1;
     */
    heroList: FightHeroRecord[];
    /**
     * @generated from protobuf field: repeated FightHeroRecord subHeroList = 2;
     */
    subHeroList: FightHeroRecord[];
    /**
     * @generated from protobuf field: optional int32 clothId = 3;
     */
    clothId?: number;
    /**
     * @generated from protobuf field: repeated FightEquipRecord equips = 4;
     */
    equips: FightEquipRecord[];
    /**
     * @generated from protobuf field: repeated TrialHeroRecord trialHeroList = 5;
     */
    trialHeroList: TrialHeroRecord[];
    /**
     * @generated from protobuf field: repeated FightActivity104EquipRecord activity104Equips = 6;
     */
    activity104Equips: FightActivity104EquipRecord[];
}
/**
 * @generated from protobuf message BuffInfo
 */
export interface BuffInfo {
    /**
     * @generated from protobuf field: optional int32 buffId = 1;
     */
    buffId?: number;
    /**
     * @generated from protobuf field: optional int32 duration = 2;
     */
    duration?: number;
    /**
     * @generated from protobuf field: optional int64 uid = 3;
     */
    uid?: bigint;
    /**
     * @generated from protobuf field: optional int32 exInfo = 4;
     */
    exInfo?: number;
    /**
     * @generated from protobuf field: optional int64 fromUid = 5;
     */
    fromUid?: bigint;
    /**
     * @generated from protobuf field: optional int32 count = 6;
     */
    count?: number;
}
/**
 * @generated from protobuf message UseCardStatistics
 */
export interface UseCardStatistics {
    /**
     * @generated from protobuf field: optional int32 skillId = 1;
     */
    skillId?: number;
    /**
     * @generated from protobuf field: optional int32 useCount = 2;
     */
    useCount?: number;
}
/**
 * @generated from protobuf message PlayerSkillInfo
 */
export interface PlayerSkillInfo {
    /**
     * @generated from protobuf field: optional int32 skillId = 1;
     */
    skillId?: number;
    /**
     * @generated from protobuf field: optional int32 cd = 2;
     */
    cd?: number;
    /**
     * @generated from protobuf field: optional int32 needPower = 3;
     */
    needPower?: number;
}
/**
 * @generated from protobuf message EquipRecord
 */
export interface EquipRecord {
    /**
     * @generated from protobuf field: optional int64 equipUid = 1;
     */
    equipUid?: bigint;
    /**
     * @generated from protobuf field: optional int32 equipId = 2;
     */
    equipId?: number;
    /**
     * @generated from protobuf field: optional int32 equipLv = 3;
     */
    equipLv?: number;
    /**
     * @generated from protobuf field: optional int32 refineLv = 4;
     */
    refineLv?: number;
}
/**
 * @generated from protobuf message FightTeam
 */
export interface FightTeam {
    /**
     * @generated from protobuf field: repeated FightEntityInfo entitys = 1;
     */
    entitys: FightEntityInfo[];
    /**
     * @generated from protobuf field: repeated FightEntityInfo subEntitys = 2;
     */
    subEntitys: FightEntityInfo[];
    /**
     * @generated from protobuf field: optional int32 power = 3;
     */
    power?: number;
    /**
     * @generated from protobuf field: optional int32 clothId = 4;
     */
    clothId?: number;
    /**
     * @generated from protobuf field: repeated PlayerSkillInfo skillInfos = 5;
     */
    skillInfos: PlayerSkillInfo[];
    /**
     * @generated from protobuf field: repeated FightEntityInfo spEntitys = 6;
     */
    spEntitys: FightEntityInfo[];
    /**
     * @generated from protobuf field: repeated IndicatorInfo indicators = 7;
     */
    indicators: IndicatorInfo[];
}
/**
 * @generated from protobuf message FightActivity104EquipRecord
 */
export interface FightActivity104EquipRecord {
    /**
     * @generated from protobuf field: optional int64 heroUid = 1;
     */
    heroUid?: bigint;
    /**
     * @generated from protobuf field: repeated Activity104EquipRecord activity104EquipRecords = 2;
     */
    activity104EquipRecords: Activity104EquipRecord[];
}
/**
 * @generated from protobuf message FightStatistics
 */
export interface FightStatistics {
    /**
     * @generated from protobuf field: optional int64 heroUid = 1;
     */
    heroUid?: bigint;
    /**
     * @generated from protobuf field: optional int64 harm = 2;
     */
    harm?: bigint;
    /**
     * @generated from protobuf field: optional int64 hurt = 3;
     */
    hurt?: bigint;
    /**
     * @generated from protobuf field: optional int64 heal = 4;
     */
    heal?: bigint;
    /**
     * @generated from protobuf field: repeated UseCardStatistics cards = 5;
     */
    cards: UseCardStatistics[];
}
/**
 * @generated from protobuf message FightEquip
 */
export interface FightEquip {
    /**
     * @generated from protobuf field: optional int64 heroUid = 1;
     */
    heroUid?: bigint;
    /**
     * @generated from protobuf field: repeated int64 equipUid = 2;
     */
    equipUid: bigint[];
}
/**
 * @generated from protobuf message FightHeroRecord
 */
export interface FightHeroRecord {
    /**
     * @generated from protobuf field: optional int64 heroUid = 1;
     */
    heroUid?: bigint;
    /**
     * @generated from protobuf field: optional int32 heroId = 2;
     */
    heroId?: number;
    /**
     * @generated from protobuf field: optional int32 level = 3;
     */
    level?: number;
    /**
     * @generated from protobuf field: optional int32 skin = 4;
     */
    skin?: number;
}
/**
 * @generated from protobuf message Activity104EquipRecord
 */
export interface Activity104EquipRecord {
    /**
     * @generated from protobuf field: optional int64 equipUid = 1;
     */
    equipUid?: bigint;
    /**
     * @generated from protobuf field: optional int32 equipId = 2;
     */
    equipId?: number;
}
/**
 * @generated from protobuf message FightEntityInfo
 */
export interface FightEntityInfo {
    /**
     * @generated from protobuf field: optional int64 uid = 1;
     */
    uid?: bigint;
    /**
     * @generated from protobuf field: optional int32 modelId = 2;
     */
    modelId?: number;
    /**
     * @generated from protobuf field: optional int32 skin = 3;
     */
    skin?: number;
    /**
     * @generated from protobuf field: optional int32 position = 4;
     */
    position?: number;
    /**
     * @generated from protobuf field: optional int32 entityType = 5;
     */
    entityType?: number;
    /**
     * @generated from protobuf field: optional int64 userId = 6;
     */
    userId?: bigint;
    /**
     * @generated from protobuf field: optional int32 exPoint = 7;
     */
    exPoint?: number;
    /**
     * @generated from protobuf field: optional int32 level = 8;
     */
    level?: number;
    /**
     * @generated from protobuf field: optional int32 currentHp = 9;
     */
    currentHp?: number;
    /**
     * @generated from protobuf field: optional HeroAttribute attr = 10;
     */
    attr?: HeroAttribute;
    /**
     * @generated from protobuf field: repeated BuffInfo buffs = 11;
     */
    buffs: BuffInfo[];
    /**
     * @generated from protobuf field: repeated int32 skillGroup1 = 12;
     */
    skillGroup1: number[];
    /**
     * @generated from protobuf field: repeated int32 skillGroup2 = 13;
     */
    skillGroup2: number[];
    /**
     * @generated from protobuf field: repeated int32 passiveSkill = 14;
     */
    passiveSkill: number[];
    /**
     * @generated from protobuf field: optional int32 exSkill = 15;
     */
    exSkill?: number;
    /**
     * @generated from protobuf field: optional int32 shieldValue = 16;
     */
    shieldValue?: number;
    /**
     * @generated from protobuf field: repeated BuffInfo noEffectBuffs = 17;
     */
    noEffectBuffs: BuffInfo[];
    /**
     * @generated from protobuf field: optional int32 expointMaxAdd = 18;
     */
    expointMaxAdd?: number;
    /**
     * @generated from protobuf field: optional int32 buffHarmStatistic = 19;
     */
    buffHarmStatistic?: number;
}
/**
 * @generated from protobuf message BeginRoundOper
 */
export interface BeginRoundOper {
    /**
     * @generated from protobuf field: optional int32 operType = 1;
     */
    operType?: number;
    /**
     * @generated from protobuf field: optional int32 param1 = 2;
     */
    param1?: number;
    /**
     * @generated from protobuf field: optional int32 param2 = 3;
     */
    param2?: number;
    /**
     * @generated from protobuf field: optional int64 toId = 4;
     */
    toId?: bigint;
}
/**
 * @generated from protobuf message CardInfo
 */
export interface CardInfo {
    /**
     * @generated from protobuf field: optional int64 uid = 1;
     */
    uid?: bigint;
    /**
     * @generated from protobuf field: optional int32 skillId = 2;
     */
    skillId?: number;
    /**
     * @generated from protobuf field: optional int32 cardEffect = 3;
     */
    cardEffect?: number;
}
/**
 * @generated from protobuf message FightStep
 */
export interface FightStep {
    /**
     * @generated from protobuf field: optional FightStep.ActType actType = 1;
     */
    actType?: FightStep_ActType;
    /**
     * @generated from protobuf field: optional int64 fromId = 2;
     */
    fromId?: bigint;
    /**
     * @generated from protobuf field: optional int64 toId = 3;
     */
    toId?: bigint;
    /**
     * @generated from protobuf field: optional int32 actId = 4;
     */
    actId?: number;
    /**
     * @generated from protobuf field: repeated ActEffect actEffect = 5;
     */
    actEffect: ActEffect[];
}
/**
 * @generated from protobuf enum FightStep.ActType
 */
export enum FightStep_ActType {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: ACTTYPESKILL = 1;
     */
    ACTTYPESKILL = 1,
    /**
     * @generated from protobuf enum value: ACTTYPEBUFF = 2;
     */
    ACTTYPEBUFF = 2,
    /**
     * @generated from protobuf enum value: ACTTYPEEFFECT = 3;
     */
    ACTTYPEEFFECT = 3,
    /**
     * @generated from protobuf enum value: ACTTYPECHANGEHERO = 4;
     */
    ACTTYPECHANGEHERO = 4,
    /**
     * @generated from protobuf enum value: ACTTYPECHANGEWAVE = 5;
     */
    ACTTYPECHANGEWAVE = 5
}
/**
 * @generated from protobuf message IndicatorInfo
 */
export interface IndicatorInfo {
    /**
     * @generated from protobuf field: optional int32 inticatorId = 1;
     */
    inticatorId?: number;
    /**
     * @generated from protobuf field: optional int32 num = 2;
     */
    num?: number;
}
/**
 * @generated from protobuf message ActEffect
 */
export interface ActEffect {
    /**
     * @generated from protobuf field: optional int64 targetId = 1;
     */
    targetId?: bigint;
    /**
     * @generated from protobuf field: optional int32 effectType = 2;
     */
    effectType?: number;
    /**
     * @generated from protobuf field: optional int32 effectNum = 3;
     */
    effectNum?: number;
    /**
     * @generated from protobuf field: optional BuffInfo buff = 4;
     */
    buff?: BuffInfo;
    /**
     * @generated from protobuf field: optional FightEntityInfo entity = 5;
     */
    entity?: FightEntityInfo;
    /**
     * @generated from protobuf field: optional int32 configEffect = 6;
     */
    configEffect?: number;
    /**
     * @generated from protobuf field: optional int32 buffActId = 7;
     */
    buffActId?: number;
    /**
     * @generated from protobuf field: optional int64 reserveId = 8;
     */
    reserveId?: bigint;
    /**
     * @generated from protobuf field: optional string reserveStr = 9;
     */
    reserveStr?: string;
}
/**
 * @generated from protobuf message TargetInfo
 */
export interface TargetInfo {
    /**
     * @generated from protobuf field: optional int32 cardIndex = 1;
     */
    cardIndex?: number;
    /**
     * @generated from protobuf field: optional int64 toId = 2;
     */
    toId?: bigint;
}
/**
 * @generated from protobuf message FightGroup
 */
export interface FightGroup {
    /**
     * @generated from protobuf field: repeated int64 heroList = 1;
     */
    heroList: bigint[];
    /**
     * @generated from protobuf field: repeated int64 subHeroList = 2;
     */
    subHeroList: bigint[];
    /**
     * @generated from protobuf field: optional int32 clothId = 3;
     */
    clothId?: number;
    /**
     * @generated from protobuf field: repeated FightEquip equips = 4;
     */
    equips: FightEquip[];
    /**
     * @generated from protobuf field: repeated TrialHero trialHeroList = 5;
     */
    trialHeroList: TrialHero[];
    /**
     * @generated from protobuf field: repeated FightEquip activity104Equips = 6;
     */
    activity104Equips: FightEquip[];
}
/**
 * @generated from protobuf message TrialHeroRecord
 */
export interface TrialHeroRecord {
    /**
     * @generated from protobuf field: optional int32 trialId = 1;
     */
    trialId?: number;
    /**
     * @generated from protobuf field: optional int32 pos = 2;
     */
    pos?: number;
    /**
     * @generated from protobuf field: repeated EquipRecord equipRecords = 3;
     */
    equipRecords: EquipRecord[];
}
/**
 * @generated from protobuf message UseClothSkillRound
 */
export interface UseClothSkillRound {
    /**
     * @generated from protobuf field: optional int32 skillId = 1;
     */
    skillId?: number;
    /**
     * @generated from protobuf field: optional int64 fromId = 2;
     */
    fromId?: bigint;
    /**
     * @generated from protobuf field: optional int64 toId = 3;
     */
    toId?: bigint;
    /**
     * @generated from protobuf field: optional FightRound round = 4;
     */
    round?: FightRound;
}
/**
 * @generated from protobuf message Fight
 */
export interface Fight {
    /**
     * @generated from protobuf field: optional FightTeam attacker = 1;
     */
    attacker?: FightTeam;
    /**
     * @generated from protobuf field: optional FightTeam defender = 2;
     */
    defender?: FightTeam;
    /**
     * @generated from protobuf field: optional int32 curRound = 3;
     */
    curRound?: number;
    /**
     * @generated from protobuf field: optional int32 maxRound = 4;
     */
    maxRound?: number;
    /**
     * @generated from protobuf field: optional bool isFinish = 5;
     */
    isFinish?: boolean;
    /**
     * @generated from protobuf field: optional int32 curWave = 6;
     */
    curWave?: number;
    /**
     * @generated from protobuf field: optional int32 battleId = 7;
     */
    battleId?: number;
}
/**
 * @generated from protobuf message FightReason
 */
export interface FightReason {
    /**
     * @generated from protobuf field: optional FightReason.FightType type = 1;
     */
    type?: FightReason_FightType;
    /**
     * @generated from protobuf field: optional string content = 2;
     */
    content?: string;
    /**
     * @generated from protobuf field: optional int32 battleId = 3;
     */
    battleId?: number;
    /**
     * @generated from protobuf field: optional int32 multiplication = 4;
     */
    multiplication?: number;
    /**
     * @generated from protobuf field: optional string data = 5;
     */
    data?: string;
}
/**
 * @generated from protobuf enum FightReason.FightType
 */
export enum FightReason_FightType {
    /**
     * @generated synthetic value - protobuf-ts requires all enums to have a 0 value
     */
    UNSPECIFIED$ = 0,
    /**
     * @generated from protobuf enum value: FIGHTTYPENONE = 1;
     */
    FIGHTTYPENONE = 1,
    /**
     * @generated from protobuf enum value: FIGHTTYPEDUNGEON = 2;
     */
    FIGHTTYPEDUNGEON = 2,
    /**
     * @generated from protobuf enum value: FIGHTTYPEDUNGEONRECORD = 3;
     */
    FIGHTTYPEDUNGEONRECORD = 3
}
/**
 * @generated from protobuf message FightEquipRecord
 */
export interface FightEquipRecord {
    /**
     * @generated from protobuf field: optional int64 heroUid = 1;
     */
    heroUid?: bigint;
    /**
     * @generated from protobuf field: repeated EquipRecord equipRecords = 2;
     */
    equipRecords: EquipRecord[];
}
/**
 * @generated from protobuf message FightRoundRecord
 */
export interface FightRoundRecord {
    /**
     * @generated from protobuf field: repeated UseClothSkillRound clothSkills = 1;
     */
    clothSkills: UseClothSkillRound[];
    /**
     * @generated from protobuf field: repeated BeginRoundOper opers = 2;
     */
    opers: BeginRoundOper[];
    /**
     * @generated from protobuf field: optional FightRound round = 3;
     */
    round?: FightRound;
    /**
     * @generated from protobuf field: optional bool newWave = 4;
     */
    newWave?: boolean;
}
/**
 * @generated from protobuf enum CardEffectEnum
 */
export enum CardEffectEnum {
    /**
     * @generated from protobuf enum value: CARDEFFECTNONE = 0;
     */
    CARDEFFECTNONE = 0,
    /**
     * @generated from protobuf enum value: CARDEFFECTFROZEN = 1;
     */
    CARDEFFECTFROZEN = 1,
    /**
     * @generated from protobuf enum value: CARDEFFECTBURN = 2;
     */
    CARDEFFECTBURN = 2,
    /**
     * @generated from protobuf enum value: CARDEFFECTECHO = 3;
     */
    CARDEFFECTECHO = 3,
    /**
     * @generated from protobuf enum value: CARDEFFECTPLUME = 4;
     */
    CARDEFFECTPLUME = 4,
    /**
     * @generated from protobuf enum value: CARDEFFECTINFECTER = 5;
     */
    CARDEFFECTINFECTER = 5,
    /**
     * @generated from protobuf enum value: CARDEFFECTASH = 6;
     */
    CARDEFFECTASH = 6
}
/**
 * @generated from protobuf enum EffectTypeEnum
 */
export enum EffectTypeEnum {
    /**
     * @generated from protobuf enum value: EFFECTTYPENONE = 0;
     */
    EFFECTTYPENONE = 0,
    /**
     * @generated from protobuf enum value: EFFECTTYPEMISS = 1;
     */
    EFFECTTYPEMISS = 1,
    /**
     * @generated from protobuf enum value: EFFECTTYPEDAMAGE = 2;
     */
    EFFECTTYPEDAMAGE = 2,
    /**
     * @generated from protobuf enum value: EFFECTTYPECRIT = 3;
     */
    EFFECTTYPECRIT = 3,
    /**
     * @generated from protobuf enum value: EFFECTTYPEHEAL = 4;
     */
    EFFECTTYPEHEAL = 4,
    /**
     * @generated from protobuf enum value: EFFECTTYPEBUFFADD = 5;
     */
    EFFECTTYPEBUFFADD = 5,
    /**
     * @generated from protobuf enum value: EFFECTTYPEBUFFDEL = 6;
     */
    EFFECTTYPEBUFFDEL = 6,
    /**
     * @generated from protobuf enum value: EFFECTTYPEBUFFUPDATE = 7;
     */
    EFFECTTYPEBUFFUPDATE = 7,
    /**
     * @generated from protobuf enum value: EFFECTTYPEBUFFEFFECT = 8;
     */
    EFFECTTYPEBUFFEFFECT = 8,
    /**
     * @generated from protobuf enum value: EFFECTTYPEDEAD = 9;
     */
    EFFECTTYPEDEAD = 9,
    /**
     * @generated from protobuf enum value: EFFECTTYPEATTACKALTER = 10;
     */
    EFFECTTYPEATTACKALTER = 10,
    /**
     * @generated from protobuf enum value: EFFECTTYPEDEFENSEALTER = 11;
     */
    EFFECTTYPEDEFENSEALTER = 11,
    /**
     * @generated from protobuf enum value: EFFECTTYPEBLOODLUST = 12;
     */
    EFFECTTYPEBLOODLUST = 12,
    /**
     * @generated from protobuf enum value: EFFECTTYPEPURIFY = 13;
     */
    EFFECTTYPEPURIFY = 13,
    /**
     * @generated from protobuf enum value: EFFECTTYPEDISPERSE = 14;
     */
    EFFECTTYPEDISPERSE = 14,
    /**
     * @generated from protobuf enum value: EFFECTTYPEADDACT = 15;
     */
    EFFECTTYPEADDACT = 15,
    /**
     * @generated from protobuf enum value: EFFECTTYPEADDCARD = 16;
     */
    EFFECTTYPEADDCARD = 16,
    /**
     * @generated from protobuf enum value: EFFECTTYPEADDEXPOINT = 17;
     */
    EFFECTTYPEADDEXPOINT = 17,
    /**
     * @generated from protobuf enum value: EFFECTTYPEDAMAGEEXTRA = 18;
     */
    EFFECTTYPEDAMAGEEXTRA = 18,
    /**
     * @generated from protobuf enum value: EFFECTTYPEBUFFREJECT = 19;
     */
    EFFECTTYPEBUFFREJECT = 19,
    /**
     * @generated from protobuf enum value: EFFECTTYPEDIZZY = 20;
     */
    EFFECTTYPEDIZZY = 20,
    /**
     * @generated from protobuf enum value: EFFECTTYPEINVINCIBLE = 21;
     */
    EFFECTTYPEINVINCIBLE = 21,
    /**
     * @generated from protobuf enum value: EFFECTTYPEPROTECT = 22;
     */
    EFFECTTYPEPROTECT = 22,
    /**
     * @generated from protobuf enum value: EFFECTTYPEFROZEN = 23;
     */
    EFFECTTYPEFROZEN = 23,
    /**
     * @generated from protobuf enum value: EFFECTTYPESILENCE = 24;
     */
    EFFECTTYPESILENCE = 24,
    /**
     * @generated from protobuf enum value: EFFECTTYPESHIELD = 25;
     */
    EFFECTTYPESHIELD = 25,
    /**
     * @generated from protobuf enum value: EFFECTTYPEATTR = 26;
     */
    EFFECTTYPEATTR = 26,
    /**
     * @generated from protobuf enum value: EFFECTTYPECURE = 27;
     */
    EFFECTTYPECURE = 27,
    /**
     * @generated from protobuf enum value: EFFECTTYPESEAL = 28;
     */
    EFFECTTYPESEAL = 28,
    /**
     * @generated from protobuf enum value: EFFECTTYPEDISARM = 29;
     */
    EFFECTTYPEDISARM = 29,
    /**
     * @generated from protobuf enum value: EFFECTTYPEFORBID = 30;
     */
    EFFECTTYPEFORBID = 30,
    /**
     * @generated from protobuf enum value: EFFECTTYPESLEEP = 31;
     */
    EFFECTTYPESLEEP = 31,
    /**
     * @generated from protobuf enum value: EFFECTTYPEPERTRIFIED = 32;
     */
    EFFECTTYPEPERTRIFIED = 32,
    /**
     * @generated from protobuf enum value: EFFECTTYPEIMMUNITY = 33;
     */
    EFFECTTYPEIMMUNITY = 33,
    /**
     * @generated from protobuf enum value: EFFECTTYPEINJURY = 34;
     */
    EFFECTTYPEINJURY = 34,
    /**
     * @generated from protobuf enum value: EFFECTTYPEDOT = 35;
     */
    EFFECTTYPEDOT = 35,
    /**
     * @generated from protobuf enum value: EFFECTTYPEREBOUND = 36;
     */
    EFFECTTYPEREBOUND = 36,
    /**
     * @generated from protobuf enum value: EFFECTTYPETAUNT = 37;
     */
    EFFECTTYPETAUNT = 37,
    /**
     * @generated from protobuf enum value: EFFECTTYPEBEATBACK = 38;
     */
    EFFECTTYPEBEATBACK = 38,
    /**
     * @generated from protobuf enum value: EFFECTTYPEEXPOINTFIX = 39;
     */
    EFFECTTYPEEXPOINTFIX = 39,
    /**
     * @generated from protobuf enum value: EFFECTTYPEAVERAGELIFE = 40;
     */
    EFFECTTYPEAVERAGELIFE = 40,
    /**
     * @generated from protobuf enum value: EFFECTTYPESHIELDCHANGE = 41;
     */
    EFFECTTYPESHIELDCHANGE = 41,
    /**
     * @generated from protobuf enum value: EFFECTTYPEADDTOATTACKER = 42;
     */
    EFFECTTYPEADDTOATTACKER = 42,
    /**
     * @generated from protobuf enum value: EFFECTTYPECURE2 = 43;
     */
    EFFECTTYPECURE2 = 43,
    /**
     * @generated from protobuf enum value: EFFECTTYPEFORBIDSPECEFFECT = 44;
     */
    EFFECTTYPEFORBIDSPECEFFECT = 44,
    /**
     * @generated from protobuf enum value: EFFECTTYPECANTCRIT = 45;
     */
    EFFECTTYPECANTCRIT = 45,
    /**
     * @generated from protobuf enum value: EFFECTTYPEPETRIFIEDRESIST = 46;
     */
    EFFECTTYPEPETRIFIEDRESIST = 46,
    /**
     * @generated from protobuf enum value: EFFECTTYPESLEEPRESIST = 47;
     */
    EFFECTTYPESLEEPRESIST = 47,
    /**
     * @generated from protobuf enum value: EFFECTTYPEFROZENRESIST = 48;
     */
    EFFECTTYPEFROZENRESIST = 48,
    /**
     * @generated from protobuf enum value: EFFECTTYPEDIZZYRESIST = 49;
     */
    EFFECTTYPEDIZZYRESIST = 49,
    /**
     * @generated from protobuf enum value: EFFECTTYPEADDTOTARGET = 50;
     */
    EFFECTTYPEADDTOTARGET = 50,
    /**
     * @generated from protobuf enum value: EFFECTTYPECRITPILEUP = 51;
     */
    EFFECTTYPECRITPILEUP = 51,
    /**
     * @generated from protobuf enum value: EFFECTTYPEDODGESPECSKILL = 52;
     */
    EFFECTTYPEDODGESPECSKILL = 52,
    /**
     * @generated from protobuf enum value: EFFECTTYPEDODGESPECSKILL2 = 53;
     */
    EFFECTTYPEDODGESPECSKILL2 = 53,
    /**
     * @generated from protobuf enum value: EFFECTTYPEREDEALCARD = 54;
     */
    EFFECTTYPEREDEALCARD = 54,
    /**
     * @generated from protobuf enum value: EFFECTTYPEBUFFADDNOEFFECT = 55;
     */
    EFFECTTYPEBUFFADDNOEFFECT = 55,
    /**
     * @generated from protobuf enum value: EFFECTTYPEBUFFDELNOEFFECT = 56;
     */
    EFFECTTYPEBUFFDELNOEFFECT = 56,
    /**
     * @generated from protobuf enum value: EFFECTTYPEHEALCRIT = 57;
     */
    EFFECTTYPEHEALCRIT = 57,
    /**
     * @generated from protobuf enum value: EFFECTTYPEUNIVERSALCARD = 58;
     */
    EFFECTTYPEUNIVERSALCARD = 58,
    /**
     * @generated from protobuf enum value: EFFECTTYPEDEALCARD1 = 59;
     */
    EFFECTTYPEDEALCARD1 = 59,
    /**
     * @generated from protobuf enum value: EFFECTTYPEDEALCARD2 = 60;
     */
    EFFECTTYPEDEALCARD2 = 60,
    /**
     * @generated from protobuf enum value: EFFECTTYPEROUNDEND = 61;
     */
    EFFECTTYPEROUNDEND = 61,
    /**
     * @generated from protobuf enum value: EFFECTTYPESHIELDDEL = 62;
     */
    EFFECTTYPESHIELDDEL = 62,
    /**
     * @generated from protobuf enum value: EFFECTTYPEEXPOINTCANTADD = 63;
     */
    EFFECTTYPEEXPOINTCANTADD = 63,
    /**
     * @generated from protobuf enum value: EFFECTTYPEADDBUFFROUND = 64;
     */
    EFFECTTYPEADDBUFFROUND = 64,
    /**
     * @generated from protobuf enum value: EFFECTTYPECARDLEVELADD = 65;
     */
    EFFECTTYPECARDLEVELADD = 65,
    /**
     * @generated from protobuf enum value: EFFECTTYPEIMMUNITYEXPOINTCHANGE = 66;
     */
    EFFECTTYPEIMMUNITYEXPOINTCHANGE = 66,
    /**
     * @generated from protobuf enum value: EFFECTTYPEMONSTERCHANGE = 67;
     */
    EFFECTTYPEMONSTERCHANGE = 67,
    /**
     * @generated from protobuf enum value: EFFECTTYPEEXPOINTADD = 68;
     */
    EFFECTTYPEEXPOINTADD = 68,
    /**
     * @generated from protobuf enum value: EFFECTTYPEEXPOINTDEL = 69;
     */
    EFFECTTYPEEXPOINTDEL = 69,
    /**
     * @generated from protobuf enum value: EFFECTTYPEDAMAGENOTMORETHAN = 70;
     */
    EFFECTTYPEDAMAGENOTMORETHAN = 70,
    /**
     * @generated from protobuf enum value: EFFECTTYPEBUFFATTR = 71;
     */
    EFFECTTYPEBUFFATTR = 71,
    /**
     * @generated from protobuf enum value: EFFECTTYPEEXPOINTCARDMOVE = 72;
     */
    EFFECTTYPEEXPOINTCARDMOVE = 72,
    /**
     * @generated from protobuf enum value: EFFECTTYPEEXPOINTCARDUPGRADE = 73;
     */
    EFFECTTYPEEXPOINTCARDUPGRADE = 73,
    /**
     * @generated from protobuf enum value: EFFECTTYPEFIXEDHURT = 74;
     */
    EFFECTTYPEFIXEDHURT = 74,
    /**
     * @generated from protobuf enum value: EFFECTTYPECARDLEVELCHANGE = 75;
     */
    EFFECTTYPECARDLEVELCHANGE = 75,
    /**
     * @generated from protobuf enum value: EFFECTTYPEBUFFREPLACE = 76;
     */
    EFFECTTYPEBUFFREPLACE = 76,
    /**
     * @generated from protobuf enum value: EFFECTTYPEEXTRAMOVEACT = 77;
     */
    EFFECTTYPEEXTRAMOVEACT = 77,
    /**
     * @generated from protobuf enum value: EFFECTTYPESPCARDADD = 78;
     */
    EFFECTTYPESPCARDADD = 78,
    /**
     * @generated from protobuf enum value: EFFECTTYPERIGID = 79;
     */
    EFFECTTYPERIGID = 79,
    /**
     * @generated from protobuf enum value: EFFECTTYPECOLD = 80;
     */
    EFFECTTYPECOLD = 80,
    /**
     * @generated from protobuf enum value: EFFECTTYPEPALSY = 81;
     */
    EFFECTTYPEPALSY = 81,
    /**
     * @generated from protobuf enum value: EFFECTTYPEADDBUFFROUNDBYTYPEID = 82;
     */
    EFFECTTYPEADDBUFFROUNDBYTYPEID = 82,
    /**
     * @generated from protobuf enum value: EFFECTTYPEEXSKILLNOCONSUMPTION = 83;
     */
    EFFECTTYPEEXSKILLNOCONSUMPTION = 83,
    /**
     * @generated from protobuf enum value: EFFECTTYPEEXPOINTADDAFTERDELORABSORBEXPOINT = 84;
     */
    EFFECTTYPEEXPOINTADDAFTERDELORABSORBEXPOINT = 84,
    /**
     * @generated from protobuf enum value: EFFECTTYPECARDEFFECTCHANGE = 85;
     */
    EFFECTTYPECARDEFFECTCHANGE = 85,
    /**
     * @generated from protobuf enum value: EFFECTTYPESUMMON = 86;
     */
    EFFECTTYPESUMMON = 86,
    /**
     * @generated from protobuf enum value: EFFECTTYPESKILLWEIGHTSELECT = 87;
     */
    EFFECTTYPESKILLWEIGHTSELECT = 87,
    /**
     * @generated from protobuf enum value: EFFECTTYPESKILLPOWERUP = 88;
     */
    EFFECTTYPESKILLPOWERUP = 88,
    /**
     * @generated from protobuf enum value: EFFECTTYPEBUFFRATEUP = 89;
     */
    EFFECTTYPEBUFFRATEUP = 89,
    /**
     * @generated from protobuf enum value: EFFECTTYPESKILLRATEUP = 90;
     */
    EFFECTTYPESKILLRATEUP = 90,
    /**
     * @generated from protobuf enum value: EFFECTTYPEEXPOINTMAXADD = 91;
     */
    EFFECTTYPEEXPOINTMAXADD = 91,
    /**
     * @generated from protobuf enum value: EFFECTTYPEHALOBASE = 92;
     */
    EFFECTTYPEHALOBASE = 92,
    /**
     * @generated from protobuf enum value: EFFECTTYPEHALOSLAVE = 93;
     */
    EFFECTTYPEHALOSLAVE = 93,
    /**
     * @generated from protobuf enum value: EFFECTTYPESELECTLAST = 94;
     */
    EFFECTTYPESELECTLAST = 94,
    /**
     * @generated from protobuf enum value: EFFECTTYPECANTSELECT = 95;
     */
    EFFECTTYPECANTSELECT = 95,
    /**
     * @generated from protobuf enum value: EFFECTTYPECLEARUNIVERSALCARD = 96;
     */
    EFFECTTYPECLEARUNIVERSALCARD = 96,
    /**
     * @generated from protobuf enum value: EFFECTTYPECHANGECAREER = 97;
     */
    EFFECTTYPECHANGECAREER = 97,
    /**
     * @generated from protobuf enum value: EFFECTTYPEFIXEDDAMAGE = 98;
     */
    EFFECTTYPEFIXEDDAMAGE = 98,
    /**
     * @generated from protobuf enum value: EFFECTTYPEPASSIVESKILLINVALID = 99;
     */
    EFFECTTYPEPASSIVESKILLINVALID = 99,
    /**
     * @generated from protobuf enum value: EFFECTTYPEHIDELIFE = 100;
     */
    EFFECTTYPEHIDELIFE = 100,
    /**
     * @generated from protobuf enum value: EFFECTTYPEBUFFADDACT = 101;
     */
    EFFECTTYPEBUFFADDACT = 101,
    /**
     * @generated from protobuf enum value: EFFECTTYPEADDCARDLIMIT = 102;
     */
    EFFECTTYPEADDCARDLIMIT = 102,
    /**
     * @generated from protobuf enum value: EFFECTTYPEADDBUFFROUNDBYTYPEGROUP = 103;
     */
    EFFECTTYPEADDBUFFROUNDBYTYPEGROUP = 103,
    /**
     * @generated from protobuf enum value: EFFECTTYPEFREEZE = 104;
     */
    EFFECTTYPEFREEZE = 104,
    /**
     * @generated from protobuf enum value: EFFECTTYPECANTSELECTEX = 105;
     */
    EFFECTTYPECANTSELECTEX = 105,
    /**
     * @generated from protobuf enum value: EFFECTTYPECARDDISAPPEAR = 106;
     */
    EFFECTTYPECARDDISAPPEAR = 106,
    /**
     * @generated from protobuf enum value: EFFECTTYPECHANGEHERO = 107;
     */
    EFFECTTYPECHANGEHERO = 107,
    /**
     * @generated from protobuf enum value: EFFECTTYPEMAXHPCHANGE = 108;
     */
    EFFECTTYPEMAXHPCHANGE = 108,
    /**
     * @generated from protobuf enum value: EFFECTTYPECURRENTHPCHANGE = 109;
     */
    EFFECTTYPECURRENTHPCHANGE = 109,
    /**
     * @generated from protobuf enum value: EFFECTTYPEKILL = 110;
     */
    EFFECTTYPEKILL = 110,
    /**
     * @generated from protobuf enum value: EFFECTTYPEEXPOINTCHANGE = 111;
     */
    EFFECTTYPEEXPOINTCHANGE = 111,
    /**
     * @generated from protobuf enum value: EFFECTTYPEMONSTERSPLIFE = 112;
     */
    EFFECTTYPEMONSTERSPLIFE = 112,
    /**
     * @generated from protobuf enum value: EFFECTTYPEEXSKILLPOINTCHANGE = 113;
     */
    EFFECTTYPEEXSKILLPOINTCHANGE = 113,
    /**
     * @generated from protobuf enum value: EFFECTTYPEHARMSTATISTIC = 114;
     */
    EFFECTTYPEHARMSTATISTIC = 114,
    /**
     * @generated from protobuf enum value: EFFECTTYPEOVERFLOWHEALTOSHIELD = 115;
     */
    EFFECTTYPEOVERFLOWHEALTOSHIELD = 115,
    /**
     * @generated from protobuf enum value: EFFECTTYPEADDSKILLBUFFCOUNTANDDURATION = 116;
     */
    EFFECTTYPEADDSKILLBUFFCOUNTANDDURATION = 116,
    /**
     * @generated from protobuf enum value: EFFECTTYPEINDICATORCHANGE = 117;
     */
    EFFECTTYPEINDICATORCHANGE = 117
}
// @generated message type with reflection information, may provide speed optimized methods
class MoveCardOper$Type extends MessageType<MoveCardOper> {
    constructor() {
        super("MoveCardOper", [
            { no: 1, name: "fromPosition", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "toPosition", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<MoveCardOper>): MoveCardOper {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<MoveCardOper>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MoveCardOper): MoveCardOper {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 fromPosition */ 1:
                    message.fromPosition = reader.int32();
                    break;
                case /* optional int32 toPosition */ 2:
                    message.toPosition = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MoveCardOper, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 fromPosition = 1; */
        if (message.fromPosition !== undefined)
            writer.tag(1, WireType.Varint).int32(message.fromPosition);
        /* optional int32 toPosition = 2; */
        if (message.toPosition !== undefined)
            writer.tag(2, WireType.Varint).int32(message.toPosition);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MoveCardOper
 */
export const MoveCardOper = new MoveCardOper$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FightRecord$Type extends MessageType<FightRecord> {
    constructor() {
        super("FightRecord", [
            { no: 1, name: "fightId", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "fightName", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "fightTime", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "fightResult", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "attackStatistics", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FightStatistics },
            { no: 6, name: "defenseStatistics", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FightStatistics }
        ]);
    }
    create(value?: PartialMessage<FightRecord>): FightRecord {
        const message = { attackStatistics: [], defenseStatistics: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FightRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FightRecord): FightRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 fightId */ 1:
                    message.fightId = reader.int64().toBigInt();
                    break;
                case /* optional string fightName */ 2:
                    message.fightName = reader.string();
                    break;
                case /* optional int64 fightTime */ 3:
                    message.fightTime = reader.int64().toBigInt();
                    break;
                case /* optional int32 fightResult */ 4:
                    message.fightResult = reader.int32();
                    break;
                case /* repeated FightStatistics attackStatistics */ 5:
                    message.attackStatistics.push(FightStatistics.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated FightStatistics defenseStatistics */ 6:
                    message.defenseStatistics.push(FightStatistics.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FightRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 fightId = 1; */
        if (message.fightId !== undefined)
            writer.tag(1, WireType.Varint).int64(message.fightId);
        /* optional string fightName = 2; */
        if (message.fightName !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.fightName);
        /* optional int64 fightTime = 3; */
        if (message.fightTime !== undefined)
            writer.tag(3, WireType.Varint).int64(message.fightTime);
        /* optional int32 fightResult = 4; */
        if (message.fightResult !== undefined)
            writer.tag(4, WireType.Varint).int32(message.fightResult);
        /* repeated FightStatistics attackStatistics = 5; */
        for (let i = 0; i < message.attackStatistics.length; i++)
            FightStatistics.internalBinaryWrite(message.attackStatistics[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated FightStatistics defenseStatistics = 6; */
        for (let i = 0; i < message.defenseStatistics.length; i++)
            FightStatistics.internalBinaryWrite(message.defenseStatistics[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FightRecord
 */
export const FightRecord = new FightRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FightExPointInfo$Type extends MessageType<FightExPointInfo> {
    constructor() {
        super("FightExPointInfo", [
            { no: 1, name: "uid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "exPoint", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<FightExPointInfo>): FightExPointInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FightExPointInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FightExPointInfo): FightExPointInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 uid */ 1:
                    message.uid = reader.int64().toBigInt();
                    break;
                case /* optional int32 exPoint */ 2:
                    message.exPoint = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FightExPointInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 uid = 1; */
        if (message.uid !== undefined)
            writer.tag(1, WireType.Varint).int64(message.uid);
        /* optional int32 exPoint = 2; */
        if (message.exPoint !== undefined)
            writer.tag(2, WireType.Varint).int32(message.exPoint);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FightExPointInfo
 */
export const FightExPointInfo = new FightExPointInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FightRound$Type extends MessageType<FightRound> {
    constructor() {
        super("FightRound", [
            { no: 1, name: "fightStep", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FightStep },
            { no: 2, name: "actPoint", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "isFinish", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "moveNum", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "exPointInfo", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FightExPointInfo },
            { no: 6, name: "aiUseCards", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CardInfo },
            { no: 7, name: "power", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "skillInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PlayerSkillInfo },
            { no: 9, name: "beforeCards1", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CardInfo },
            { no: 10, name: "teamACards1", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CardInfo },
            { no: 11, name: "beforeCards2", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CardInfo },
            { no: 12, name: "teamACards2", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CardInfo },
            { no: 13, name: "nextRoundBeginStep", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FightStep },
            { no: 14, name: "useCardList", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "beginExPointInfo", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FightExPointInfo }
        ]);
    }
    create(value?: PartialMessage<FightRound>): FightRound {
        const message = { fightStep: [], exPointInfo: [], aiUseCards: [], skillInfos: [], beforeCards1: [], teamACards1: [], beforeCards2: [], teamACards2: [], nextRoundBeginStep: [], useCardList: [], beginExPointInfo: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FightRound>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FightRound): FightRound {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated FightStep fightStep */ 1:
                    message.fightStep.push(FightStep.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 actPoint */ 2:
                    message.actPoint = reader.int32();
                    break;
                case /* optional bool isFinish */ 3:
                    message.isFinish = reader.bool();
                    break;
                case /* optional int32 moveNum */ 4:
                    message.moveNum = reader.int32();
                    break;
                case /* repeated FightExPointInfo exPointInfo */ 5:
                    message.exPointInfo.push(FightExPointInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CardInfo aiUseCards */ 6:
                    message.aiUseCards.push(CardInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 power */ 7:
                    message.power = reader.int32();
                    break;
                case /* repeated PlayerSkillInfo skillInfos */ 8:
                    message.skillInfos.push(PlayerSkillInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CardInfo beforeCards1 */ 9:
                    message.beforeCards1.push(CardInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CardInfo teamACards1 */ 10:
                    message.teamACards1.push(CardInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CardInfo beforeCards2 */ 11:
                    message.beforeCards2.push(CardInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated CardInfo teamACards2 */ 12:
                    message.teamACards2.push(CardInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated FightStep nextRoundBeginStep */ 13:
                    message.nextRoundBeginStep.push(FightStep.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated int32 useCardList */ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.useCardList.push(reader.int32());
                    else
                        message.useCardList.push(reader.int32());
                    break;
                case /* repeated FightExPointInfo beginExPointInfo */ 15:
                    message.beginExPointInfo.push(FightExPointInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FightRound, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated FightStep fightStep = 1; */
        for (let i = 0; i < message.fightStep.length; i++)
            FightStep.internalBinaryWrite(message.fightStep[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 actPoint = 2; */
        if (message.actPoint !== undefined)
            writer.tag(2, WireType.Varint).int32(message.actPoint);
        /* optional bool isFinish = 3; */
        if (message.isFinish !== undefined)
            writer.tag(3, WireType.Varint).bool(message.isFinish);
        /* optional int32 moveNum = 4; */
        if (message.moveNum !== undefined)
            writer.tag(4, WireType.Varint).int32(message.moveNum);
        /* repeated FightExPointInfo exPointInfo = 5; */
        for (let i = 0; i < message.exPointInfo.length; i++)
            FightExPointInfo.internalBinaryWrite(message.exPointInfo[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated CardInfo aiUseCards = 6; */
        for (let i = 0; i < message.aiUseCards.length; i++)
            CardInfo.internalBinaryWrite(message.aiUseCards[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 power = 7; */
        if (message.power !== undefined)
            writer.tag(7, WireType.Varint).int32(message.power);
        /* repeated PlayerSkillInfo skillInfos = 8; */
        for (let i = 0; i < message.skillInfos.length; i++)
            PlayerSkillInfo.internalBinaryWrite(message.skillInfos[i], writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* repeated CardInfo beforeCards1 = 9; */
        for (let i = 0; i < message.beforeCards1.length; i++)
            CardInfo.internalBinaryWrite(message.beforeCards1[i], writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* repeated CardInfo teamACards1 = 10; */
        for (let i = 0; i < message.teamACards1.length; i++)
            CardInfo.internalBinaryWrite(message.teamACards1[i], writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated CardInfo beforeCards2 = 11; */
        for (let i = 0; i < message.beforeCards2.length; i++)
            CardInfo.internalBinaryWrite(message.beforeCards2[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated CardInfo teamACards2 = 12; */
        for (let i = 0; i < message.teamACards2.length; i++)
            CardInfo.internalBinaryWrite(message.teamACards2[i], writer.tag(12, WireType.LengthDelimited).fork(), options).join();
        /* repeated FightStep nextRoundBeginStep = 13; */
        for (let i = 0; i < message.nextRoundBeginStep.length; i++)
            FightStep.internalBinaryWrite(message.nextRoundBeginStep[i], writer.tag(13, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 useCardList = 14; */
        for (let i = 0; i < message.useCardList.length; i++)
            writer.tag(14, WireType.Varint).int32(message.useCardList[i]);
        /* repeated FightExPointInfo beginExPointInfo = 15; */
        for (let i = 0; i < message.beginExPointInfo.length; i++)
            FightExPointInfo.internalBinaryWrite(message.beginExPointInfo[i], writer.tag(15, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FightRound
 */
export const FightRound = new FightRound$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrialHero$Type extends MessageType<TrialHero> {
    constructor() {
        super("TrialHero", [
            { no: 1, name: "trialId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "pos", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "equipUid", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TrialHero>): TrialHero {
        const message = { equipUid: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TrialHero>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrialHero): TrialHero {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 trialId */ 1:
                    message.trialId = reader.int32();
                    break;
                case /* optional int32 pos */ 2:
                    message.pos = reader.int32();
                    break;
                case /* repeated int64 equipUid */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.equipUid.push(reader.int64().toBigInt());
                    else
                        message.equipUid.push(reader.int64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrialHero, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 trialId = 1; */
        if (message.trialId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.trialId);
        /* optional int32 pos = 2; */
        if (message.pos !== undefined)
            writer.tag(2, WireType.Varint).int32(message.pos);
        /* repeated int64 equipUid = 3; */
        for (let i = 0; i < message.equipUid.length; i++)
            writer.tag(3, WireType.Varint).int64(message.equipUid[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TrialHero
 */
export const TrialHero = new TrialHero$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FightGroupRecord$Type extends MessageType<FightGroupRecord> {
    constructor() {
        super("FightGroupRecord", [
            { no: 1, name: "heroList", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FightHeroRecord },
            { no: 2, name: "subHeroList", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FightHeroRecord },
            { no: 3, name: "clothId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "equips", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FightEquipRecord },
            { no: 5, name: "trialHeroList", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TrialHeroRecord },
            { no: 6, name: "activity104Equips", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FightActivity104EquipRecord }
        ]);
    }
    create(value?: PartialMessage<FightGroupRecord>): FightGroupRecord {
        const message = { heroList: [], subHeroList: [], equips: [], trialHeroList: [], activity104Equips: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FightGroupRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FightGroupRecord): FightGroupRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated FightHeroRecord heroList */ 1:
                    message.heroList.push(FightHeroRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated FightHeroRecord subHeroList */ 2:
                    message.subHeroList.push(FightHeroRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 clothId */ 3:
                    message.clothId = reader.int32();
                    break;
                case /* repeated FightEquipRecord equips */ 4:
                    message.equips.push(FightEquipRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TrialHeroRecord trialHeroList */ 5:
                    message.trialHeroList.push(TrialHeroRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated FightActivity104EquipRecord activity104Equips */ 6:
                    message.activity104Equips.push(FightActivity104EquipRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FightGroupRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated FightHeroRecord heroList = 1; */
        for (let i = 0; i < message.heroList.length; i++)
            FightHeroRecord.internalBinaryWrite(message.heroList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated FightHeroRecord subHeroList = 2; */
        for (let i = 0; i < message.subHeroList.length; i++)
            FightHeroRecord.internalBinaryWrite(message.subHeroList[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 clothId = 3; */
        if (message.clothId !== undefined)
            writer.tag(3, WireType.Varint).int32(message.clothId);
        /* repeated FightEquipRecord equips = 4; */
        for (let i = 0; i < message.equips.length; i++)
            FightEquipRecord.internalBinaryWrite(message.equips[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated TrialHeroRecord trialHeroList = 5; */
        for (let i = 0; i < message.trialHeroList.length; i++)
            TrialHeroRecord.internalBinaryWrite(message.trialHeroList[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated FightActivity104EquipRecord activity104Equips = 6; */
        for (let i = 0; i < message.activity104Equips.length; i++)
            FightActivity104EquipRecord.internalBinaryWrite(message.activity104Equips[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FightGroupRecord
 */
export const FightGroupRecord = new FightGroupRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuffInfo$Type extends MessageType<BuffInfo> {
    constructor() {
        super("BuffInfo", [
            { no: 1, name: "buffId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "duration", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "uid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "exInfo", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "fromUid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 6, name: "count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BuffInfo>): BuffInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuffInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuffInfo): BuffInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 buffId */ 1:
                    message.buffId = reader.int32();
                    break;
                case /* optional int32 duration */ 2:
                    message.duration = reader.int32();
                    break;
                case /* optional int64 uid */ 3:
                    message.uid = reader.int64().toBigInt();
                    break;
                case /* optional int32 exInfo */ 4:
                    message.exInfo = reader.int32();
                    break;
                case /* optional int64 fromUid */ 5:
                    message.fromUid = reader.int64().toBigInt();
                    break;
                case /* optional int32 count */ 6:
                    message.count = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuffInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 buffId = 1; */
        if (message.buffId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.buffId);
        /* optional int32 duration = 2; */
        if (message.duration !== undefined)
            writer.tag(2, WireType.Varint).int32(message.duration);
        /* optional int64 uid = 3; */
        if (message.uid !== undefined)
            writer.tag(3, WireType.Varint).int64(message.uid);
        /* optional int32 exInfo = 4; */
        if (message.exInfo !== undefined)
            writer.tag(4, WireType.Varint).int32(message.exInfo);
        /* optional int64 fromUid = 5; */
        if (message.fromUid !== undefined)
            writer.tag(5, WireType.Varint).int64(message.fromUid);
        /* optional int32 count = 6; */
        if (message.count !== undefined)
            writer.tag(6, WireType.Varint).int32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BuffInfo
 */
export const BuffInfo = new BuffInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UseCardStatistics$Type extends MessageType<UseCardStatistics> {
    constructor() {
        super("UseCardStatistics", [
            { no: 1, name: "skillId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "useCount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<UseCardStatistics>): UseCardStatistics {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UseCardStatistics>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UseCardStatistics): UseCardStatistics {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 skillId */ 1:
                    message.skillId = reader.int32();
                    break;
                case /* optional int32 useCount */ 2:
                    message.useCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UseCardStatistics, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 skillId = 1; */
        if (message.skillId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.skillId);
        /* optional int32 useCount = 2; */
        if (message.useCount !== undefined)
            writer.tag(2, WireType.Varint).int32(message.useCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UseCardStatistics
 */
export const UseCardStatistics = new UseCardStatistics$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PlayerSkillInfo$Type extends MessageType<PlayerSkillInfo> {
    constructor() {
        super("PlayerSkillInfo", [
            { no: 1, name: "skillId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "cd", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "needPower", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<PlayerSkillInfo>): PlayerSkillInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PlayerSkillInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerSkillInfo): PlayerSkillInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 skillId */ 1:
                    message.skillId = reader.int32();
                    break;
                case /* optional int32 cd */ 2:
                    message.cd = reader.int32();
                    break;
                case /* optional int32 needPower */ 3:
                    message.needPower = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerSkillInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 skillId = 1; */
        if (message.skillId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.skillId);
        /* optional int32 cd = 2; */
        if (message.cd !== undefined)
            writer.tag(2, WireType.Varint).int32(message.cd);
        /* optional int32 needPower = 3; */
        if (message.needPower !== undefined)
            writer.tag(3, WireType.Varint).int32(message.needPower);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message PlayerSkillInfo
 */
export const PlayerSkillInfo = new PlayerSkillInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EquipRecord$Type extends MessageType<EquipRecord> {
    constructor() {
        super("EquipRecord", [
            { no: 1, name: "equipUid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "equipId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "equipLv", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "refineLv", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<EquipRecord>): EquipRecord {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<EquipRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EquipRecord): EquipRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 equipUid */ 1:
                    message.equipUid = reader.int64().toBigInt();
                    break;
                case /* optional int32 equipId */ 2:
                    message.equipId = reader.int32();
                    break;
                case /* optional int32 equipLv */ 3:
                    message.equipLv = reader.int32();
                    break;
                case /* optional int32 refineLv */ 4:
                    message.refineLv = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: EquipRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 equipUid = 1; */
        if (message.equipUid !== undefined)
            writer.tag(1, WireType.Varint).int64(message.equipUid);
        /* optional int32 equipId = 2; */
        if (message.equipId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.equipId);
        /* optional int32 equipLv = 3; */
        if (message.equipLv !== undefined)
            writer.tag(3, WireType.Varint).int32(message.equipLv);
        /* optional int32 refineLv = 4; */
        if (message.refineLv !== undefined)
            writer.tag(4, WireType.Varint).int32(message.refineLv);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message EquipRecord
 */
export const EquipRecord = new EquipRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FightTeam$Type extends MessageType<FightTeam> {
    constructor() {
        super("FightTeam", [
            { no: 1, name: "entitys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FightEntityInfo },
            { no: 2, name: "subEntitys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FightEntityInfo },
            { no: 3, name: "power", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "clothId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "skillInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => PlayerSkillInfo },
            { no: 6, name: "spEntitys", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FightEntityInfo },
            { no: 7, name: "indicators", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => IndicatorInfo }
        ]);
    }
    create(value?: PartialMessage<FightTeam>): FightTeam {
        const message = { entitys: [], subEntitys: [], skillInfos: [], spEntitys: [], indicators: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FightTeam>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FightTeam): FightTeam {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated FightEntityInfo entitys */ 1:
                    message.entitys.push(FightEntityInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated FightEntityInfo subEntitys */ 2:
                    message.subEntitys.push(FightEntityInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 power */ 3:
                    message.power = reader.int32();
                    break;
                case /* optional int32 clothId */ 4:
                    message.clothId = reader.int32();
                    break;
                case /* repeated PlayerSkillInfo skillInfos */ 5:
                    message.skillInfos.push(PlayerSkillInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated FightEntityInfo spEntitys */ 6:
                    message.spEntitys.push(FightEntityInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated IndicatorInfo indicators */ 7:
                    message.indicators.push(IndicatorInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FightTeam, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated FightEntityInfo entitys = 1; */
        for (let i = 0; i < message.entitys.length; i++)
            FightEntityInfo.internalBinaryWrite(message.entitys[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated FightEntityInfo subEntitys = 2; */
        for (let i = 0; i < message.subEntitys.length; i++)
            FightEntityInfo.internalBinaryWrite(message.subEntitys[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 power = 3; */
        if (message.power !== undefined)
            writer.tag(3, WireType.Varint).int32(message.power);
        /* optional int32 clothId = 4; */
        if (message.clothId !== undefined)
            writer.tag(4, WireType.Varint).int32(message.clothId);
        /* repeated PlayerSkillInfo skillInfos = 5; */
        for (let i = 0; i < message.skillInfos.length; i++)
            PlayerSkillInfo.internalBinaryWrite(message.skillInfos[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated FightEntityInfo spEntitys = 6; */
        for (let i = 0; i < message.spEntitys.length; i++)
            FightEntityInfo.internalBinaryWrite(message.spEntitys[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated IndicatorInfo indicators = 7; */
        for (let i = 0; i < message.indicators.length; i++)
            IndicatorInfo.internalBinaryWrite(message.indicators[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FightTeam
 */
export const FightTeam = new FightTeam$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FightActivity104EquipRecord$Type extends MessageType<FightActivity104EquipRecord> {
    constructor() {
        super("FightActivity104EquipRecord", [
            { no: 1, name: "heroUid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "activity104EquipRecords", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Activity104EquipRecord }
        ]);
    }
    create(value?: PartialMessage<FightActivity104EquipRecord>): FightActivity104EquipRecord {
        const message = { activity104EquipRecords: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FightActivity104EquipRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FightActivity104EquipRecord): FightActivity104EquipRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 heroUid */ 1:
                    message.heroUid = reader.int64().toBigInt();
                    break;
                case /* repeated Activity104EquipRecord activity104EquipRecords */ 2:
                    message.activity104EquipRecords.push(Activity104EquipRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FightActivity104EquipRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 heroUid = 1; */
        if (message.heroUid !== undefined)
            writer.tag(1, WireType.Varint).int64(message.heroUid);
        /* repeated Activity104EquipRecord activity104EquipRecords = 2; */
        for (let i = 0; i < message.activity104EquipRecords.length; i++)
            Activity104EquipRecord.internalBinaryWrite(message.activity104EquipRecords[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FightActivity104EquipRecord
 */
export const FightActivity104EquipRecord = new FightActivity104EquipRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FightStatistics$Type extends MessageType<FightStatistics> {
    constructor() {
        super("FightStatistics", [
            { no: 1, name: "heroUid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "harm", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "hurt", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "heal", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 5, name: "cards", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UseCardStatistics }
        ]);
    }
    create(value?: PartialMessage<FightStatistics>): FightStatistics {
        const message = { cards: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FightStatistics>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FightStatistics): FightStatistics {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 heroUid */ 1:
                    message.heroUid = reader.int64().toBigInt();
                    break;
                case /* optional int64 harm */ 2:
                    message.harm = reader.int64().toBigInt();
                    break;
                case /* optional int64 hurt */ 3:
                    message.hurt = reader.int64().toBigInt();
                    break;
                case /* optional int64 heal */ 4:
                    message.heal = reader.int64().toBigInt();
                    break;
                case /* repeated UseCardStatistics cards */ 5:
                    message.cards.push(UseCardStatistics.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FightStatistics, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 heroUid = 1; */
        if (message.heroUid !== undefined)
            writer.tag(1, WireType.Varint).int64(message.heroUid);
        /* optional int64 harm = 2; */
        if (message.harm !== undefined)
            writer.tag(2, WireType.Varint).int64(message.harm);
        /* optional int64 hurt = 3; */
        if (message.hurt !== undefined)
            writer.tag(3, WireType.Varint).int64(message.hurt);
        /* optional int64 heal = 4; */
        if (message.heal !== undefined)
            writer.tag(4, WireType.Varint).int64(message.heal);
        /* repeated UseCardStatistics cards = 5; */
        for (let i = 0; i < message.cards.length; i++)
            UseCardStatistics.internalBinaryWrite(message.cards[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FightStatistics
 */
export const FightStatistics = new FightStatistics$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FightEquip$Type extends MessageType<FightEquip> {
    constructor() {
        super("FightEquip", [
            { no: 1, name: "heroUid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "equipUid", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<FightEquip>): FightEquip {
        const message = { equipUid: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FightEquip>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FightEquip): FightEquip {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 heroUid */ 1:
                    message.heroUid = reader.int64().toBigInt();
                    break;
                case /* repeated int64 equipUid */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.equipUid.push(reader.int64().toBigInt());
                    else
                        message.equipUid.push(reader.int64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FightEquip, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 heroUid = 1; */
        if (message.heroUid !== undefined)
            writer.tag(1, WireType.Varint).int64(message.heroUid);
        /* repeated int64 equipUid = 2; */
        for (let i = 0; i < message.equipUid.length; i++)
            writer.tag(2, WireType.Varint).int64(message.equipUid[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FightEquip
 */
export const FightEquip = new FightEquip$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FightHeroRecord$Type extends MessageType<FightHeroRecord> {
    constructor() {
        super("FightHeroRecord", [
            { no: 1, name: "heroUid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "level", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "skin", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<FightHeroRecord>): FightHeroRecord {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FightHeroRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FightHeroRecord): FightHeroRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 heroUid */ 1:
                    message.heroUid = reader.int64().toBigInt();
                    break;
                case /* optional int32 heroId */ 2:
                    message.heroId = reader.int32();
                    break;
                case /* optional int32 level */ 3:
                    message.level = reader.int32();
                    break;
                case /* optional int32 skin */ 4:
                    message.skin = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FightHeroRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 heroUid = 1; */
        if (message.heroUid !== undefined)
            writer.tag(1, WireType.Varint).int64(message.heroUid);
        /* optional int32 heroId = 2; */
        if (message.heroId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.heroId);
        /* optional int32 level = 3; */
        if (message.level !== undefined)
            writer.tag(3, WireType.Varint).int32(message.level);
        /* optional int32 skin = 4; */
        if (message.skin !== undefined)
            writer.tag(4, WireType.Varint).int32(message.skin);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FightHeroRecord
 */
export const FightHeroRecord = new FightHeroRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Activity104EquipRecord$Type extends MessageType<Activity104EquipRecord> {
    constructor() {
        super("Activity104EquipRecord", [
            { no: 1, name: "equipUid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "equipId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Activity104EquipRecord>): Activity104EquipRecord {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Activity104EquipRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Activity104EquipRecord): Activity104EquipRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 equipUid */ 1:
                    message.equipUid = reader.int64().toBigInt();
                    break;
                case /* optional int32 equipId */ 2:
                    message.equipId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Activity104EquipRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 equipUid = 1; */
        if (message.equipUid !== undefined)
            writer.tag(1, WireType.Varint).int64(message.equipUid);
        /* optional int32 equipId = 2; */
        if (message.equipId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.equipId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Activity104EquipRecord
 */
export const Activity104EquipRecord = new Activity104EquipRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FightEntityInfo$Type extends MessageType<FightEntityInfo> {
    constructor() {
        super("FightEntityInfo", [
            { no: 1, name: "uid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "modelId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "skin", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "position", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "entityType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "userId", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 7, name: "exPoint", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "level", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 9, name: "currentHp", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "attr", kind: "message", T: () => HeroAttribute },
            { no: 11, name: "buffs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BuffInfo },
            { no: 12, name: "skillGroup1", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 13, name: "skillGroup2", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 14, name: "passiveSkill", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 15, name: "exSkill", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 16, name: "shieldValue", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 17, name: "noEffectBuffs", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BuffInfo },
            { no: 18, name: "expointMaxAdd", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 19, name: "buffHarmStatistic", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<FightEntityInfo>): FightEntityInfo {
        const message = { buffs: [], skillGroup1: [], skillGroup2: [], passiveSkill: [], noEffectBuffs: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FightEntityInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FightEntityInfo): FightEntityInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 uid */ 1:
                    message.uid = reader.int64().toBigInt();
                    break;
                case /* optional int32 modelId */ 2:
                    message.modelId = reader.int32();
                    break;
                case /* optional int32 skin */ 3:
                    message.skin = reader.int32();
                    break;
                case /* optional int32 position */ 4:
                    message.position = reader.int32();
                    break;
                case /* optional int32 entityType */ 5:
                    message.entityType = reader.int32();
                    break;
                case /* optional int64 userId */ 6:
                    message.userId = reader.int64().toBigInt();
                    break;
                case /* optional int32 exPoint */ 7:
                    message.exPoint = reader.int32();
                    break;
                case /* optional int32 level */ 8:
                    message.level = reader.int32();
                    break;
                case /* optional int32 currentHp */ 9:
                    message.currentHp = reader.int32();
                    break;
                case /* optional HeroAttribute attr */ 10:
                    message.attr = HeroAttribute.internalBinaryRead(reader, reader.uint32(), options, message.attr);
                    break;
                case /* repeated BuffInfo buffs */ 11:
                    message.buffs.push(BuffInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated int32 skillGroup1 */ 12:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.skillGroup1.push(reader.int32());
                    else
                        message.skillGroup1.push(reader.int32());
                    break;
                case /* repeated int32 skillGroup2 */ 13:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.skillGroup2.push(reader.int32());
                    else
                        message.skillGroup2.push(reader.int32());
                    break;
                case /* repeated int32 passiveSkill */ 14:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.passiveSkill.push(reader.int32());
                    else
                        message.passiveSkill.push(reader.int32());
                    break;
                case /* optional int32 exSkill */ 15:
                    message.exSkill = reader.int32();
                    break;
                case /* optional int32 shieldValue */ 16:
                    message.shieldValue = reader.int32();
                    break;
                case /* repeated BuffInfo noEffectBuffs */ 17:
                    message.noEffectBuffs.push(BuffInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 expointMaxAdd */ 18:
                    message.expointMaxAdd = reader.int32();
                    break;
                case /* optional int32 buffHarmStatistic */ 19:
                    message.buffHarmStatistic = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FightEntityInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 uid = 1; */
        if (message.uid !== undefined)
            writer.tag(1, WireType.Varint).int64(message.uid);
        /* optional int32 modelId = 2; */
        if (message.modelId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.modelId);
        /* optional int32 skin = 3; */
        if (message.skin !== undefined)
            writer.tag(3, WireType.Varint).int32(message.skin);
        /* optional int32 position = 4; */
        if (message.position !== undefined)
            writer.tag(4, WireType.Varint).int32(message.position);
        /* optional int32 entityType = 5; */
        if (message.entityType !== undefined)
            writer.tag(5, WireType.Varint).int32(message.entityType);
        /* optional int64 userId = 6; */
        if (message.userId !== undefined)
            writer.tag(6, WireType.Varint).int64(message.userId);
        /* optional int32 exPoint = 7; */
        if (message.exPoint !== undefined)
            writer.tag(7, WireType.Varint).int32(message.exPoint);
        /* optional int32 level = 8; */
        if (message.level !== undefined)
            writer.tag(8, WireType.Varint).int32(message.level);
        /* optional int32 currentHp = 9; */
        if (message.currentHp !== undefined)
            writer.tag(9, WireType.Varint).int32(message.currentHp);
        /* optional HeroAttribute attr = 10; */
        if (message.attr)
            HeroAttribute.internalBinaryWrite(message.attr, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
        /* repeated BuffInfo buffs = 11; */
        for (let i = 0; i < message.buffs.length; i++)
            BuffInfo.internalBinaryWrite(message.buffs[i], writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 skillGroup1 = 12; */
        for (let i = 0; i < message.skillGroup1.length; i++)
            writer.tag(12, WireType.Varint).int32(message.skillGroup1[i]);
        /* repeated int32 skillGroup2 = 13; */
        for (let i = 0; i < message.skillGroup2.length; i++)
            writer.tag(13, WireType.Varint).int32(message.skillGroup2[i]);
        /* repeated int32 passiveSkill = 14; */
        for (let i = 0; i < message.passiveSkill.length; i++)
            writer.tag(14, WireType.Varint).int32(message.passiveSkill[i]);
        /* optional int32 exSkill = 15; */
        if (message.exSkill !== undefined)
            writer.tag(15, WireType.Varint).int32(message.exSkill);
        /* optional int32 shieldValue = 16; */
        if (message.shieldValue !== undefined)
            writer.tag(16, WireType.Varint).int32(message.shieldValue);
        /* repeated BuffInfo noEffectBuffs = 17; */
        for (let i = 0; i < message.noEffectBuffs.length; i++)
            BuffInfo.internalBinaryWrite(message.noEffectBuffs[i], writer.tag(17, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 expointMaxAdd = 18; */
        if (message.expointMaxAdd !== undefined)
            writer.tag(18, WireType.Varint).int32(message.expointMaxAdd);
        /* optional int32 buffHarmStatistic = 19; */
        if (message.buffHarmStatistic !== undefined)
            writer.tag(19, WireType.Varint).int32(message.buffHarmStatistic);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FightEntityInfo
 */
export const FightEntityInfo = new FightEntityInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BeginRoundOper$Type extends MessageType<BeginRoundOper> {
    constructor() {
        super("BeginRoundOper", [
            { no: 1, name: "operType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "param1", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "param2", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "toId", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<BeginRoundOper>): BeginRoundOper {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BeginRoundOper>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BeginRoundOper): BeginRoundOper {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 operType */ 1:
                    message.operType = reader.int32();
                    break;
                case /* optional int32 param1 */ 2:
                    message.param1 = reader.int32();
                    break;
                case /* optional int32 param2 */ 3:
                    message.param2 = reader.int32();
                    break;
                case /* optional int64 toId */ 4:
                    message.toId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BeginRoundOper, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 operType = 1; */
        if (message.operType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.operType);
        /* optional int32 param1 = 2; */
        if (message.param1 !== undefined)
            writer.tag(2, WireType.Varint).int32(message.param1);
        /* optional int32 param2 = 3; */
        if (message.param2 !== undefined)
            writer.tag(3, WireType.Varint).int32(message.param2);
        /* optional int64 toId = 4; */
        if (message.toId !== undefined)
            writer.tag(4, WireType.Varint).int64(message.toId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BeginRoundOper
 */
export const BeginRoundOper = new BeginRoundOper$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CardInfo$Type extends MessageType<CardInfo> {
    constructor() {
        super("CardInfo", [
            { no: 1, name: "uid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "skillId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "cardEffect", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CardInfo>): CardInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CardInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CardInfo): CardInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 uid */ 1:
                    message.uid = reader.int64().toBigInt();
                    break;
                case /* optional int32 skillId */ 2:
                    message.skillId = reader.int32();
                    break;
                case /* optional int32 cardEffect */ 3:
                    message.cardEffect = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CardInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 uid = 1; */
        if (message.uid !== undefined)
            writer.tag(1, WireType.Varint).int64(message.uid);
        /* optional int32 skillId = 2; */
        if (message.skillId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.skillId);
        /* optional int32 cardEffect = 3; */
        if (message.cardEffect !== undefined)
            writer.tag(3, WireType.Varint).int32(message.cardEffect);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CardInfo
 */
export const CardInfo = new CardInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FightStep$Type extends MessageType<FightStep> {
    constructor() {
        super("FightStep", [
            { no: 1, name: "actType", kind: "enum", opt: true, T: () => ["FightStep.ActType", FightStep_ActType] },
            { no: 2, name: "fromId", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "toId", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "actId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "actEffect", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ActEffect }
        ]);
    }
    create(value?: PartialMessage<FightStep>): FightStep {
        const message = { actEffect: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FightStep>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FightStep): FightStep {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional FightStep.ActType actType */ 1:
                    message.actType = reader.int32();
                    break;
                case /* optional int64 fromId */ 2:
                    message.fromId = reader.int64().toBigInt();
                    break;
                case /* optional int64 toId */ 3:
                    message.toId = reader.int64().toBigInt();
                    break;
                case /* optional int32 actId */ 4:
                    message.actId = reader.int32();
                    break;
                case /* repeated ActEffect actEffect */ 5:
                    message.actEffect.push(ActEffect.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FightStep, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional FightStep.ActType actType = 1; */
        if (message.actType !== undefined)
            writer.tag(1, WireType.Varint).int32(message.actType);
        /* optional int64 fromId = 2; */
        if (message.fromId !== undefined)
            writer.tag(2, WireType.Varint).int64(message.fromId);
        /* optional int64 toId = 3; */
        if (message.toId !== undefined)
            writer.tag(3, WireType.Varint).int64(message.toId);
        /* optional int32 actId = 4; */
        if (message.actId !== undefined)
            writer.tag(4, WireType.Varint).int32(message.actId);
        /* repeated ActEffect actEffect = 5; */
        for (let i = 0; i < message.actEffect.length; i++)
            ActEffect.internalBinaryWrite(message.actEffect[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FightStep
 */
export const FightStep = new FightStep$Type();
// @generated message type with reflection information, may provide speed optimized methods
class IndicatorInfo$Type extends MessageType<IndicatorInfo> {
    constructor() {
        super("IndicatorInfo", [
            { no: 1, name: "inticatorId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "num", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<IndicatorInfo>): IndicatorInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<IndicatorInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: IndicatorInfo): IndicatorInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 inticatorId */ 1:
                    message.inticatorId = reader.int32();
                    break;
                case /* optional int32 num */ 2:
                    message.num = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: IndicatorInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 inticatorId = 1; */
        if (message.inticatorId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.inticatorId);
        /* optional int32 num = 2; */
        if (message.num !== undefined)
            writer.tag(2, WireType.Varint).int32(message.num);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message IndicatorInfo
 */
export const IndicatorInfo = new IndicatorInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ActEffect$Type extends MessageType<ActEffect> {
    constructor() {
        super("ActEffect", [
            { no: 1, name: "targetId", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "effectType", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "effectNum", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "buff", kind: "message", T: () => BuffInfo },
            { no: 5, name: "entity", kind: "message", T: () => FightEntityInfo },
            { no: 6, name: "configEffect", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "buffActId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 8, name: "reserveId", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "reserveStr", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ActEffect>): ActEffect {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ActEffect>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ActEffect): ActEffect {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 targetId */ 1:
                    message.targetId = reader.int64().toBigInt();
                    break;
                case /* optional int32 effectType */ 2:
                    message.effectType = reader.int32();
                    break;
                case /* optional int32 effectNum */ 3:
                    message.effectNum = reader.int32();
                    break;
                case /* optional BuffInfo buff */ 4:
                    message.buff = BuffInfo.internalBinaryRead(reader, reader.uint32(), options, message.buff);
                    break;
                case /* optional FightEntityInfo entity */ 5:
                    message.entity = FightEntityInfo.internalBinaryRead(reader, reader.uint32(), options, message.entity);
                    break;
                case /* optional int32 configEffect */ 6:
                    message.configEffect = reader.int32();
                    break;
                case /* optional int32 buffActId */ 7:
                    message.buffActId = reader.int32();
                    break;
                case /* optional int64 reserveId */ 8:
                    message.reserveId = reader.int64().toBigInt();
                    break;
                case /* optional string reserveStr */ 9:
                    message.reserveStr = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ActEffect, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 targetId = 1; */
        if (message.targetId !== undefined)
            writer.tag(1, WireType.Varint).int64(message.targetId);
        /* optional int32 effectType = 2; */
        if (message.effectType !== undefined)
            writer.tag(2, WireType.Varint).int32(message.effectType);
        /* optional int32 effectNum = 3; */
        if (message.effectNum !== undefined)
            writer.tag(3, WireType.Varint).int32(message.effectNum);
        /* optional BuffInfo buff = 4; */
        if (message.buff)
            BuffInfo.internalBinaryWrite(message.buff, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* optional FightEntityInfo entity = 5; */
        if (message.entity)
            FightEntityInfo.internalBinaryWrite(message.entity, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 configEffect = 6; */
        if (message.configEffect !== undefined)
            writer.tag(6, WireType.Varint).int32(message.configEffect);
        /* optional int32 buffActId = 7; */
        if (message.buffActId !== undefined)
            writer.tag(7, WireType.Varint).int32(message.buffActId);
        /* optional int64 reserveId = 8; */
        if (message.reserveId !== undefined)
            writer.tag(8, WireType.Varint).int64(message.reserveId);
        /* optional string reserveStr = 9; */
        if (message.reserveStr !== undefined)
            writer.tag(9, WireType.LengthDelimited).string(message.reserveStr);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ActEffect
 */
export const ActEffect = new ActEffect$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TargetInfo$Type extends MessageType<TargetInfo> {
    constructor() {
        super("TargetInfo", [
            { no: 1, name: "cardIndex", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "toId", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<TargetInfo>): TargetInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TargetInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TargetInfo): TargetInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 cardIndex */ 1:
                    message.cardIndex = reader.int32();
                    break;
                case /* optional int64 toId */ 2:
                    message.toId = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TargetInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 cardIndex = 1; */
        if (message.cardIndex !== undefined)
            writer.tag(1, WireType.Varint).int32(message.cardIndex);
        /* optional int64 toId = 2; */
        if (message.toId !== undefined)
            writer.tag(2, WireType.Varint).int64(message.toId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TargetInfo
 */
export const TargetInfo = new TargetInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FightGroup$Type extends MessageType<FightGroup> {
    constructor() {
        super("FightGroup", [
            { no: 1, name: "heroList", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "subHeroList", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "clothId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "equips", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FightEquip },
            { no: 5, name: "trialHeroList", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => TrialHero },
            { no: 6, name: "activity104Equips", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FightEquip }
        ]);
    }
    create(value?: PartialMessage<FightGroup>): FightGroup {
        const message = { heroList: [], subHeroList: [], equips: [], trialHeroList: [], activity104Equips: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FightGroup>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FightGroup): FightGroup {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int64 heroList */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.heroList.push(reader.int64().toBigInt());
                    else
                        message.heroList.push(reader.int64().toBigInt());
                    break;
                case /* repeated int64 subHeroList */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.subHeroList.push(reader.int64().toBigInt());
                    else
                        message.subHeroList.push(reader.int64().toBigInt());
                    break;
                case /* optional int32 clothId */ 3:
                    message.clothId = reader.int32();
                    break;
                case /* repeated FightEquip equips */ 4:
                    message.equips.push(FightEquip.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated TrialHero trialHeroList */ 5:
                    message.trialHeroList.push(TrialHero.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated FightEquip activity104Equips */ 6:
                    message.activity104Equips.push(FightEquip.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FightGroup, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int64 heroList = 1; */
        for (let i = 0; i < message.heroList.length; i++)
            writer.tag(1, WireType.Varint).int64(message.heroList[i]);
        /* repeated int64 subHeroList = 2; */
        for (let i = 0; i < message.subHeroList.length; i++)
            writer.tag(2, WireType.Varint).int64(message.subHeroList[i]);
        /* optional int32 clothId = 3; */
        if (message.clothId !== undefined)
            writer.tag(3, WireType.Varint).int32(message.clothId);
        /* repeated FightEquip equips = 4; */
        for (let i = 0; i < message.equips.length; i++)
            FightEquip.internalBinaryWrite(message.equips[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated TrialHero trialHeroList = 5; */
        for (let i = 0; i < message.trialHeroList.length; i++)
            TrialHero.internalBinaryWrite(message.trialHeroList[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated FightEquip activity104Equips = 6; */
        for (let i = 0; i < message.activity104Equips.length; i++)
            FightEquip.internalBinaryWrite(message.activity104Equips[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FightGroup
 */
export const FightGroup = new FightGroup$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TrialHeroRecord$Type extends MessageType<TrialHeroRecord> {
    constructor() {
        super("TrialHeroRecord", [
            { no: 1, name: "trialId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "pos", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "equipRecords", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => EquipRecord }
        ]);
    }
    create(value?: PartialMessage<TrialHeroRecord>): TrialHeroRecord {
        const message = { equipRecords: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<TrialHeroRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TrialHeroRecord): TrialHeroRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 trialId */ 1:
                    message.trialId = reader.int32();
                    break;
                case /* optional int32 pos */ 2:
                    message.pos = reader.int32();
                    break;
                case /* repeated EquipRecord equipRecords */ 3:
                    message.equipRecords.push(EquipRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TrialHeroRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 trialId = 1; */
        if (message.trialId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.trialId);
        /* optional int32 pos = 2; */
        if (message.pos !== undefined)
            writer.tag(2, WireType.Varint).int32(message.pos);
        /* repeated EquipRecord equipRecords = 3; */
        for (let i = 0; i < message.equipRecords.length; i++)
            EquipRecord.internalBinaryWrite(message.equipRecords[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message TrialHeroRecord
 */
export const TrialHeroRecord = new TrialHeroRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UseClothSkillRound$Type extends MessageType<UseClothSkillRound> {
    constructor() {
        super("UseClothSkillRound", [
            { no: 1, name: "skillId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "fromId", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "toId", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "round", kind: "message", T: () => FightRound }
        ]);
    }
    create(value?: PartialMessage<UseClothSkillRound>): UseClothSkillRound {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UseClothSkillRound>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UseClothSkillRound): UseClothSkillRound {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 skillId */ 1:
                    message.skillId = reader.int32();
                    break;
                case /* optional int64 fromId */ 2:
                    message.fromId = reader.int64().toBigInt();
                    break;
                case /* optional int64 toId */ 3:
                    message.toId = reader.int64().toBigInt();
                    break;
                case /* optional FightRound round */ 4:
                    message.round = FightRound.internalBinaryRead(reader, reader.uint32(), options, message.round);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UseClothSkillRound, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 skillId = 1; */
        if (message.skillId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.skillId);
        /* optional int64 fromId = 2; */
        if (message.fromId !== undefined)
            writer.tag(2, WireType.Varint).int64(message.fromId);
        /* optional int64 toId = 3; */
        if (message.toId !== undefined)
            writer.tag(3, WireType.Varint).int64(message.toId);
        /* optional FightRound round = 4; */
        if (message.round)
            FightRound.internalBinaryWrite(message.round, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UseClothSkillRound
 */
export const UseClothSkillRound = new UseClothSkillRound$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Fight$Type extends MessageType<Fight> {
    constructor() {
        super("Fight", [
            { no: 1, name: "attacker", kind: "message", T: () => FightTeam },
            { no: 2, name: "defender", kind: "message", T: () => FightTeam },
            { no: 3, name: "curRound", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "maxRound", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "isFinish", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 6, name: "curWave", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 7, name: "battleId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<Fight>): Fight {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Fight>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Fight): Fight {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional FightTeam attacker */ 1:
                    message.attacker = FightTeam.internalBinaryRead(reader, reader.uint32(), options, message.attacker);
                    break;
                case /* optional FightTeam defender */ 2:
                    message.defender = FightTeam.internalBinaryRead(reader, reader.uint32(), options, message.defender);
                    break;
                case /* optional int32 curRound */ 3:
                    message.curRound = reader.int32();
                    break;
                case /* optional int32 maxRound */ 4:
                    message.maxRound = reader.int32();
                    break;
                case /* optional bool isFinish */ 5:
                    message.isFinish = reader.bool();
                    break;
                case /* optional int32 curWave */ 6:
                    message.curWave = reader.int32();
                    break;
                case /* optional int32 battleId */ 7:
                    message.battleId = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Fight, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional FightTeam attacker = 1; */
        if (message.attacker)
            FightTeam.internalBinaryWrite(message.attacker, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional FightTeam defender = 2; */
        if (message.defender)
            FightTeam.internalBinaryWrite(message.defender, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 curRound = 3; */
        if (message.curRound !== undefined)
            writer.tag(3, WireType.Varint).int32(message.curRound);
        /* optional int32 maxRound = 4; */
        if (message.maxRound !== undefined)
            writer.tag(4, WireType.Varint).int32(message.maxRound);
        /* optional bool isFinish = 5; */
        if (message.isFinish !== undefined)
            writer.tag(5, WireType.Varint).bool(message.isFinish);
        /* optional int32 curWave = 6; */
        if (message.curWave !== undefined)
            writer.tag(6, WireType.Varint).int32(message.curWave);
        /* optional int32 battleId = 7; */
        if (message.battleId !== undefined)
            writer.tag(7, WireType.Varint).int32(message.battleId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message Fight
 */
export const Fight = new Fight$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FightReason$Type extends MessageType<FightReason> {
    constructor() {
        super("FightReason", [
            { no: 1, name: "type", kind: "enum", opt: true, T: () => ["FightReason.FightType", FightReason_FightType] },
            { no: 2, name: "content", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "battleId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "multiplication", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "data", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FightReason>): FightReason {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FightReason>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FightReason): FightReason {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional FightReason.FightType type */ 1:
                    message.type = reader.int32();
                    break;
                case /* optional string content */ 2:
                    message.content = reader.string();
                    break;
                case /* optional int32 battleId */ 3:
                    message.battleId = reader.int32();
                    break;
                case /* optional int32 multiplication */ 4:
                    message.multiplication = reader.int32();
                    break;
                case /* optional string data */ 5:
                    message.data = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FightReason, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional FightReason.FightType type = 1; */
        if (message.type !== undefined)
            writer.tag(1, WireType.Varint).int32(message.type);
        /* optional string content = 2; */
        if (message.content !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.content);
        /* optional int32 battleId = 3; */
        if (message.battleId !== undefined)
            writer.tag(3, WireType.Varint).int32(message.battleId);
        /* optional int32 multiplication = 4; */
        if (message.multiplication !== undefined)
            writer.tag(4, WireType.Varint).int32(message.multiplication);
        /* optional string data = 5; */
        if (message.data !== undefined)
            writer.tag(5, WireType.LengthDelimited).string(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FightReason
 */
export const FightReason = new FightReason$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FightEquipRecord$Type extends MessageType<FightEquipRecord> {
    constructor() {
        super("FightEquipRecord", [
            { no: 1, name: "heroUid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "equipRecords", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => EquipRecord }
        ]);
    }
    create(value?: PartialMessage<FightEquipRecord>): FightEquipRecord {
        const message = { equipRecords: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FightEquipRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FightEquipRecord): FightEquipRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 heroUid */ 1:
                    message.heroUid = reader.int64().toBigInt();
                    break;
                case /* repeated EquipRecord equipRecords */ 2:
                    message.equipRecords.push(EquipRecord.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FightEquipRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 heroUid = 1; */
        if (message.heroUid !== undefined)
            writer.tag(1, WireType.Varint).int64(message.heroUid);
        /* repeated EquipRecord equipRecords = 2; */
        for (let i = 0; i < message.equipRecords.length; i++)
            EquipRecord.internalBinaryWrite(message.equipRecords[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FightEquipRecord
 */
export const FightEquipRecord = new FightEquipRecord$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FightRoundRecord$Type extends MessageType<FightRoundRecord> {
    constructor() {
        super("FightRoundRecord", [
            { no: 1, name: "clothSkills", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => UseClothSkillRound },
            { no: 2, name: "opers", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BeginRoundOper },
            { no: 3, name: "round", kind: "message", T: () => FightRound },
            { no: 4, name: "newWave", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<FightRoundRecord>): FightRoundRecord {
        const message = { clothSkills: [], opers: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FightRoundRecord>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FightRoundRecord): FightRoundRecord {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated UseClothSkillRound clothSkills */ 1:
                    message.clothSkills.push(UseClothSkillRound.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated BeginRoundOper opers */ 2:
                    message.opers.push(BeginRoundOper.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional FightRound round */ 3:
                    message.round = FightRound.internalBinaryRead(reader, reader.uint32(), options, message.round);
                    break;
                case /* optional bool newWave */ 4:
                    message.newWave = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FightRoundRecord, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated UseClothSkillRound clothSkills = 1; */
        for (let i = 0; i < message.clothSkills.length; i++)
            UseClothSkillRound.internalBinaryWrite(message.clothSkills[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated BeginRoundOper opers = 2; */
        for (let i = 0; i < message.opers.length; i++)
            BeginRoundOper.internalBinaryWrite(message.opers[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional FightRound round = 3; */
        if (message.round)
            FightRound.internalBinaryWrite(message.round, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional bool newWave = 4; */
        if (message.newWave !== undefined)
            writer.tag(4, WireType.Varint).bool(message.newWave);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FightRoundRecord
 */
export const FightRoundRecord = new FightRoundRecord$Type();
