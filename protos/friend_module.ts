// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "friend_module.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message HandleApplyRequest
 */
export interface HandleApplyRequest {
    /**
     * @generated from protobuf field: optional uint64 friendId = 1;
     */
    friendId?: bigint;
    /**
     * @generated from protobuf field: optional bool isAgree = 2;
     */
    isAgree?: boolean;
}
/**
 * @generated from protobuf message SearchRequest
 */
export interface SearchRequest {
    /**
     * @generated from protobuf field: optional string value = 1;
     */
    value?: string;
}
/**
 * @generated from protobuf message RemoveBlacklistReply
 */
export interface RemoveBlacklistReply {
    /**
     * @generated from protobuf field: optional uint64 friendId = 1;
     */
    friendId?: bigint;
}
/**
 * @generated from protobuf message SearchReply
 */
export interface SearchReply {
    /**
     * @generated from protobuf field: repeated FriendInfo info = 1;
     */
    info: FriendInfo[];
}
/**
 * @generated from protobuf message LoadFriendInfosReply
 */
export interface LoadFriendInfosReply {
    /**
     * @generated from protobuf field: repeated uint64 friendIds = 1;
     */
    friendIds: bigint[];
    /**
     * @generated from protobuf field: repeated uint64 blackListIds = 2;
     */
    blackListIds: bigint[];
}
/**
 * @generated from protobuf message RejectAllReply
 */
export interface RejectAllReply {
}
/**
 * @generated from protobuf message FriendInfo
 */
export interface FriendInfo {
    /**
     * @generated from protobuf field: optional uint64 userId = 1;
     */
    userId?: bigint;
    /**
     * @generated from protobuf field: optional string name = 2;
     */
    name?: string;
    /**
     * @generated from protobuf field: optional uint32 level = 3;
     */
    level?: number;
    /**
     * @generated from protobuf field: optional uint32 portrait = 4;
     */
    portrait?: number;
    /**
     * @generated from protobuf field: optional uint64 time = 5;
     */
    time?: bigint;
}
/**
 * @generated from protobuf message GetApplyListReply
 */
export interface GetApplyListReply {
    /**
     * @generated from protobuf field: repeated FriendInfo info = 1;
     */
    info: FriendInfo[];
}
/**
 * @generated from protobuf message ApplyReply
 */
export interface ApplyReply {
    /**
     * @generated from protobuf field: optional string messsage = 1;
     */
    messsage?: string;
    /**
     * @generated from protobuf field: optional uint64 friendId = 2;
     */
    friendId?: bigint;
}
/**
 * @generated from protobuf message GetFriendInfoListReply
 */
export interface GetFriendInfoListReply {
    /**
     * @generated from protobuf field: repeated FriendInfo info = 1;
     */
    info: FriendInfo[];
}
/**
 * @generated from protobuf message GetBlacklistRequest
 */
export interface GetBlacklistRequest {
}
/**
 * @generated from protobuf message RemoveFriendReply
 */
export interface RemoveFriendReply {
    /**
     * @generated from protobuf field: optional uint64 friendId = 1;
     */
    friendId?: bigint;
}
/**
 * @generated from protobuf message FriendChangePush
 */
export interface FriendChangePush {
    /**
     * @generated from protobuf field: optional uint64 friendId = 1;
     */
    friendId?: bigint;
    /**
     * @generated from protobuf field: optional bool isAdd = 2;
     */
    isAdd?: boolean;
}
/**
 * @generated from protobuf message BlacklistChangePush
 */
export interface BlacklistChangePush {
    /**
     * @generated from protobuf field: optional uint64 userId = 1;
     */
    userId?: bigint;
    /**
     * @generated from protobuf field: optional int32 change = 2;
     */
    change?: number;
}
/**
 * @generated from protobuf message GetBlacklistReply
 */
export interface GetBlacklistReply {
    /**
     * @generated from protobuf field: repeated FriendInfo info = 1;
     */
    info: FriendInfo[];
}
/**
 * @generated from protobuf message AddBlacklistReply
 */
export interface AddBlacklistReply {
    /**
     * @generated from protobuf field: optional uint64 friendId = 1;
     */
    friendId?: bigint;
}
/**
 * @generated from protobuf message AgreeAllReply
 */
export interface AgreeAllReply {
    /**
     * @generated from protobuf field: repeated FriendInfo applyList = 1;
     */
    applyList: FriendInfo[];
    /**
     * @generated from protobuf field: repeated int32 resultCode = 2;
     */
    resultCode: number[];
}
/**
 * @generated from protobuf message AddBlacklistRequest
 */
export interface AddBlacklistRequest {
    /**
     * @generated from protobuf field: optional uint64 friendId = 1;
     */
    friendId?: bigint;
}
/**
 * @generated from protobuf message GetApplyListRequest
 */
export interface GetApplyListRequest {
}
/**
 * @generated from protobuf message RemoveBlacklistRequest
 */
export interface RemoveBlacklistRequest {
    /**
     * @generated from protobuf field: optional uint64 friendId = 1;
     */
    friendId?: bigint;
}
/**
 * @generated from protobuf message LoadFriendInfosRequest
 */
export interface LoadFriendInfosRequest {
}
/**
 * @generated from protobuf message AgreeAllRequest
 */
export interface AgreeAllRequest {
}
/**
 * @generated from protobuf message HandleApplyReply
 */
export interface HandleApplyReply {
    /**
     * @generated from protobuf field: optional uint64 friendId = 1;
     */
    friendId?: bigint;
    /**
     * @generated from protobuf field: optional bool isAgree = 2;
     */
    isAgree?: boolean;
    /**
     * @generated from protobuf field: optional string messsage = 3;
     */
    messsage?: string;
}
/**
 * @generated from protobuf message RejectAllRequest
 */
export interface RejectAllRequest {
}
/**
 * @generated from protobuf message ApplyRequest
 */
export interface ApplyRequest {
    /**
     * @generated from protobuf field: optional uint64 friendId = 1;
     */
    friendId?: bigint;
}
/**
 * @generated from protobuf message GetFriendInfoListRequest
 */
export interface GetFriendInfoListRequest {
}
/**
 * @generated from protobuf message RemoveFriendRequest
 */
export interface RemoveFriendRequest {
    /**
     * @generated from protobuf field: optional uint64 friendId = 1;
     */
    friendId?: bigint;
}
// @generated message type with reflection information, may provide speed optimized methods
class HandleApplyRequest$Type extends MessageType<HandleApplyRequest> {
    constructor() {
        super("HandleApplyRequest", [
            { no: 1, name: "friendId", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "isAgree", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<HandleApplyRequest>): HandleApplyRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HandleApplyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HandleApplyRequest): HandleApplyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 friendId */ 1:
                    message.friendId = reader.uint64().toBigInt();
                    break;
                case /* optional bool isAgree */ 2:
                    message.isAgree = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HandleApplyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 friendId = 1; */
        if (message.friendId !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.friendId);
        /* optional bool isAgree = 2; */
        if (message.isAgree !== undefined)
            writer.tag(2, WireType.Varint).bool(message.isAgree);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HandleApplyRequest
 */
export const HandleApplyRequest = new HandleApplyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SearchRequest$Type extends MessageType<SearchRequest> {
    constructor() {
        super("SearchRequest", [
            { no: 1, name: "value", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SearchRequest>): SearchRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SearchRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SearchRequest): SearchRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string value */ 1:
                    message.value = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SearchRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string value = 1; */
        if (message.value !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.value);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SearchRequest
 */
export const SearchRequest = new SearchRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveBlacklistReply$Type extends MessageType<RemoveBlacklistReply> {
    constructor() {
        super("RemoveBlacklistReply", [
            { no: 1, name: "friendId", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RemoveBlacklistReply>): RemoveBlacklistReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RemoveBlacklistReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveBlacklistReply): RemoveBlacklistReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 friendId */ 1:
                    message.friendId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveBlacklistReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 friendId = 1; */
        if (message.friendId !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.friendId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RemoveBlacklistReply
 */
export const RemoveBlacklistReply = new RemoveBlacklistReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SearchReply$Type extends MessageType<SearchReply> {
    constructor() {
        super("SearchReply", [
            { no: 1, name: "info", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FriendInfo }
        ]);
    }
    create(value?: PartialMessage<SearchReply>): SearchReply {
        const message = { info: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SearchReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SearchReply): SearchReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated FriendInfo info */ 1:
                    message.info.push(FriendInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SearchReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated FriendInfo info = 1; */
        for (let i = 0; i < message.info.length; i++)
            FriendInfo.internalBinaryWrite(message.info[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SearchReply
 */
export const SearchReply = new SearchReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoadFriendInfosReply$Type extends MessageType<LoadFriendInfosReply> {
    constructor() {
        super("LoadFriendInfosReply", [
            { no: 1, name: "friendIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "blackListIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<LoadFriendInfosReply>): LoadFriendInfosReply {
        const message = { friendIds: [], blackListIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LoadFriendInfosReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoadFriendInfosReply): LoadFriendInfosReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint64 friendIds */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.friendIds.push(reader.uint64().toBigInt());
                    else
                        message.friendIds.push(reader.uint64().toBigInt());
                    break;
                case /* repeated uint64 blackListIds */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.blackListIds.push(reader.uint64().toBigInt());
                    else
                        message.blackListIds.push(reader.uint64().toBigInt());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: LoadFriendInfosReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint64 friendIds = 1; */
        for (let i = 0; i < message.friendIds.length; i++)
            writer.tag(1, WireType.Varint).uint64(message.friendIds[i]);
        /* repeated uint64 blackListIds = 2; */
        for (let i = 0; i < message.blackListIds.length; i++)
            writer.tag(2, WireType.Varint).uint64(message.blackListIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LoadFriendInfosReply
 */
export const LoadFriendInfosReply = new LoadFriendInfosReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RejectAllReply$Type extends MessageType<RejectAllReply> {
    constructor() {
        super("RejectAllReply", []);
    }
    create(value?: PartialMessage<RejectAllReply>): RejectAllReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RejectAllReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RejectAllReply): RejectAllReply {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RejectAllReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RejectAllReply
 */
export const RejectAllReply = new RejectAllReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FriendInfo$Type extends MessageType<FriendInfo> {
    constructor() {
        super("FriendInfo", [
            { no: 1, name: "userId", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "name", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "level", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "portrait", kind: "scalar", opt: true, T: 13 /*ScalarType.UINT32*/ },
            { no: 5, name: "time", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<FriendInfo>): FriendInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FriendInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FriendInfo): FriendInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 userId */ 1:
                    message.userId = reader.uint64().toBigInt();
                    break;
                case /* optional string name */ 2:
                    message.name = reader.string();
                    break;
                case /* optional uint32 level */ 3:
                    message.level = reader.uint32();
                    break;
                case /* optional uint32 portrait */ 4:
                    message.portrait = reader.uint32();
                    break;
                case /* optional uint64 time */ 5:
                    message.time = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FriendInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 userId = 1; */
        if (message.userId !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.userId);
        /* optional string name = 2; */
        if (message.name !== undefined)
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* optional uint32 level = 3; */
        if (message.level !== undefined)
            writer.tag(3, WireType.Varint).uint32(message.level);
        /* optional uint32 portrait = 4; */
        if (message.portrait !== undefined)
            writer.tag(4, WireType.Varint).uint32(message.portrait);
        /* optional uint64 time = 5; */
        if (message.time !== undefined)
            writer.tag(5, WireType.Varint).uint64(message.time);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FriendInfo
 */
export const FriendInfo = new FriendInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetApplyListReply$Type extends MessageType<GetApplyListReply> {
    constructor() {
        super("GetApplyListReply", [
            { no: 1, name: "info", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FriendInfo }
        ]);
    }
    create(value?: PartialMessage<GetApplyListReply>): GetApplyListReply {
        const message = { info: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetApplyListReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetApplyListReply): GetApplyListReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated FriendInfo info */ 1:
                    message.info.push(FriendInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetApplyListReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated FriendInfo info = 1; */
        for (let i = 0; i < message.info.length; i++)
            FriendInfo.internalBinaryWrite(message.info[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetApplyListReply
 */
export const GetApplyListReply = new GetApplyListReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplyReply$Type extends MessageType<ApplyReply> {
    constructor() {
        super("ApplyReply", [
            { no: 1, name: "messsage", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "friendId", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ApplyReply>): ApplyReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ApplyReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApplyReply): ApplyReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional string messsage */ 1:
                    message.messsage = reader.string();
                    break;
                case /* optional uint64 friendId */ 2:
                    message.friendId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApplyReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional string messsage = 1; */
        if (message.messsage !== undefined)
            writer.tag(1, WireType.LengthDelimited).string(message.messsage);
        /* optional uint64 friendId = 2; */
        if (message.friendId !== undefined)
            writer.tag(2, WireType.Varint).uint64(message.friendId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ApplyReply
 */
export const ApplyReply = new ApplyReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFriendInfoListReply$Type extends MessageType<GetFriendInfoListReply> {
    constructor() {
        super("GetFriendInfoListReply", [
            { no: 1, name: "info", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FriendInfo }
        ]);
    }
    create(value?: PartialMessage<GetFriendInfoListReply>): GetFriendInfoListReply {
        const message = { info: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetFriendInfoListReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFriendInfoListReply): GetFriendInfoListReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated FriendInfo info */ 1:
                    message.info.push(FriendInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetFriendInfoListReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated FriendInfo info = 1; */
        for (let i = 0; i < message.info.length; i++)
            FriendInfo.internalBinaryWrite(message.info[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetFriendInfoListReply
 */
export const GetFriendInfoListReply = new GetFriendInfoListReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBlacklistRequest$Type extends MessageType<GetBlacklistRequest> {
    constructor() {
        super("GetBlacklistRequest", []);
    }
    create(value?: PartialMessage<GetBlacklistRequest>): GetBlacklistRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetBlacklistRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBlacklistRequest): GetBlacklistRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetBlacklistRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetBlacklistRequest
 */
export const GetBlacklistRequest = new GetBlacklistRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveFriendReply$Type extends MessageType<RemoveFriendReply> {
    constructor() {
        super("RemoveFriendReply", [
            { no: 1, name: "friendId", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RemoveFriendReply>): RemoveFriendReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RemoveFriendReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveFriendReply): RemoveFriendReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 friendId */ 1:
                    message.friendId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveFriendReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 friendId = 1; */
        if (message.friendId !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.friendId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RemoveFriendReply
 */
export const RemoveFriendReply = new RemoveFriendReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FriendChangePush$Type extends MessageType<FriendChangePush> {
    constructor() {
        super("FriendChangePush", [
            { no: 1, name: "friendId", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "isAdd", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<FriendChangePush>): FriendChangePush {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FriendChangePush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FriendChangePush): FriendChangePush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 friendId */ 1:
                    message.friendId = reader.uint64().toBigInt();
                    break;
                case /* optional bool isAdd */ 2:
                    message.isAdd = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FriendChangePush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 friendId = 1; */
        if (message.friendId !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.friendId);
        /* optional bool isAdd = 2; */
        if (message.isAdd !== undefined)
            writer.tag(2, WireType.Varint).bool(message.isAdd);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FriendChangePush
 */
export const FriendChangePush = new FriendChangePush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlacklistChangePush$Type extends MessageType<BlacklistChangePush> {
    constructor() {
        super("BlacklistChangePush", [
            { no: 1, name: "userId", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "change", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BlacklistChangePush>): BlacklistChangePush {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BlacklistChangePush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlacklistChangePush): BlacklistChangePush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 userId */ 1:
                    message.userId = reader.uint64().toBigInt();
                    break;
                case /* optional int32 change */ 2:
                    message.change = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlacklistChangePush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 userId = 1; */
        if (message.userId !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.userId);
        /* optional int32 change = 2; */
        if (message.change !== undefined)
            writer.tag(2, WireType.Varint).int32(message.change);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BlacklistChangePush
 */
export const BlacklistChangePush = new BlacklistChangePush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBlacklistReply$Type extends MessageType<GetBlacklistReply> {
    constructor() {
        super("GetBlacklistReply", [
            { no: 1, name: "info", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FriendInfo }
        ]);
    }
    create(value?: PartialMessage<GetBlacklistReply>): GetBlacklistReply {
        const message = { info: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetBlacklistReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBlacklistReply): GetBlacklistReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated FriendInfo info */ 1:
                    message.info.push(FriendInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBlacklistReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated FriendInfo info = 1; */
        for (let i = 0; i < message.info.length; i++)
            FriendInfo.internalBinaryWrite(message.info[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetBlacklistReply
 */
export const GetBlacklistReply = new GetBlacklistReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddBlacklistReply$Type extends MessageType<AddBlacklistReply> {
    constructor() {
        super("AddBlacklistReply", [
            { no: 1, name: "friendId", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AddBlacklistReply>): AddBlacklistReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AddBlacklistReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddBlacklistReply): AddBlacklistReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 friendId */ 1:
                    message.friendId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddBlacklistReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 friendId = 1; */
        if (message.friendId !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.friendId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AddBlacklistReply
 */
export const AddBlacklistReply = new AddBlacklistReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AgreeAllReply$Type extends MessageType<AgreeAllReply> {
    constructor() {
        super("AgreeAllReply", [
            { no: 1, name: "applyList", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FriendInfo },
            { no: 2, name: "resultCode", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<AgreeAllReply>): AgreeAllReply {
        const message = { applyList: [], resultCode: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AgreeAllReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AgreeAllReply): AgreeAllReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated FriendInfo applyList */ 1:
                    message.applyList.push(FriendInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated int32 resultCode */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.resultCode.push(reader.int32());
                    else
                        message.resultCode.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AgreeAllReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated FriendInfo applyList = 1; */
        for (let i = 0; i < message.applyList.length; i++)
            FriendInfo.internalBinaryWrite(message.applyList[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated int32 resultCode = 2; */
        for (let i = 0; i < message.resultCode.length; i++)
            writer.tag(2, WireType.Varint).int32(message.resultCode[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AgreeAllReply
 */
export const AgreeAllReply = new AgreeAllReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AddBlacklistRequest$Type extends MessageType<AddBlacklistRequest> {
    constructor() {
        super("AddBlacklistRequest", [
            { no: 1, name: "friendId", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<AddBlacklistRequest>): AddBlacklistRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AddBlacklistRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AddBlacklistRequest): AddBlacklistRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 friendId */ 1:
                    message.friendId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AddBlacklistRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 friendId = 1; */
        if (message.friendId !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.friendId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AddBlacklistRequest
 */
export const AddBlacklistRequest = new AddBlacklistRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetApplyListRequest$Type extends MessageType<GetApplyListRequest> {
    constructor() {
        super("GetApplyListRequest", []);
    }
    create(value?: PartialMessage<GetApplyListRequest>): GetApplyListRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetApplyListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetApplyListRequest): GetApplyListRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetApplyListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetApplyListRequest
 */
export const GetApplyListRequest = new GetApplyListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveBlacklistRequest$Type extends MessageType<RemoveBlacklistRequest> {
    constructor() {
        super("RemoveBlacklistRequest", [
            { no: 1, name: "friendId", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RemoveBlacklistRequest>): RemoveBlacklistRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RemoveBlacklistRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveBlacklistRequest): RemoveBlacklistRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 friendId */ 1:
                    message.friendId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveBlacklistRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 friendId = 1; */
        if (message.friendId !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.friendId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RemoveBlacklistRequest
 */
export const RemoveBlacklistRequest = new RemoveBlacklistRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class LoadFriendInfosRequest$Type extends MessageType<LoadFriendInfosRequest> {
    constructor() {
        super("LoadFriendInfosRequest", []);
    }
    create(value?: PartialMessage<LoadFriendInfosRequest>): LoadFriendInfosRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<LoadFriendInfosRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: LoadFriendInfosRequest): LoadFriendInfosRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: LoadFriendInfosRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message LoadFriendInfosRequest
 */
export const LoadFriendInfosRequest = new LoadFriendInfosRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AgreeAllRequest$Type extends MessageType<AgreeAllRequest> {
    constructor() {
        super("AgreeAllRequest", []);
    }
    create(value?: PartialMessage<AgreeAllRequest>): AgreeAllRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<AgreeAllRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AgreeAllRequest): AgreeAllRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: AgreeAllRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message AgreeAllRequest
 */
export const AgreeAllRequest = new AgreeAllRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HandleApplyReply$Type extends MessageType<HandleApplyReply> {
    constructor() {
        super("HandleApplyReply", [
            { no: 1, name: "friendId", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "isAgree", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "messsage", kind: "scalar", opt: true, T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HandleApplyReply>): HandleApplyReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HandleApplyReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HandleApplyReply): HandleApplyReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 friendId */ 1:
                    message.friendId = reader.uint64().toBigInt();
                    break;
                case /* optional bool isAgree */ 2:
                    message.isAgree = reader.bool();
                    break;
                case /* optional string messsage */ 3:
                    message.messsage = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HandleApplyReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 friendId = 1; */
        if (message.friendId !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.friendId);
        /* optional bool isAgree = 2; */
        if (message.isAgree !== undefined)
            writer.tag(2, WireType.Varint).bool(message.isAgree);
        /* optional string messsage = 3; */
        if (message.messsage !== undefined)
            writer.tag(3, WireType.LengthDelimited).string(message.messsage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HandleApplyReply
 */
export const HandleApplyReply = new HandleApplyReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RejectAllRequest$Type extends MessageType<RejectAllRequest> {
    constructor() {
        super("RejectAllRequest", []);
    }
    create(value?: PartialMessage<RejectAllRequest>): RejectAllRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RejectAllRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RejectAllRequest): RejectAllRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RejectAllRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RejectAllRequest
 */
export const RejectAllRequest = new RejectAllRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ApplyRequest$Type extends MessageType<ApplyRequest> {
    constructor() {
        super("ApplyRequest", [
            { no: 1, name: "friendId", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<ApplyRequest>): ApplyRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ApplyRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ApplyRequest): ApplyRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 friendId */ 1:
                    message.friendId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ApplyRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 friendId = 1; */
        if (message.friendId !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.friendId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ApplyRequest
 */
export const ApplyRequest = new ApplyRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFriendInfoListRequest$Type extends MessageType<GetFriendInfoListRequest> {
    constructor() {
        super("GetFriendInfoListRequest", []);
    }
    create(value?: PartialMessage<GetFriendInfoListRequest>): GetFriendInfoListRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetFriendInfoListRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFriendInfoListRequest): GetFriendInfoListRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetFriendInfoListRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetFriendInfoListRequest
 */
export const GetFriendInfoListRequest = new GetFriendInfoListRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RemoveFriendRequest$Type extends MessageType<RemoveFriendRequest> {
    constructor() {
        super("RemoveFriendRequest", [
            { no: 1, name: "friendId", kind: "scalar", opt: true, T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<RemoveFriendRequest>): RemoveFriendRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RemoveFriendRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RemoveFriendRequest): RemoveFriendRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional uint64 friendId */ 1:
                    message.friendId = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RemoveFriendRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional uint64 friendId = 1; */
        if (message.friendId !== undefined)
            writer.tag(1, WireType.Varint).uint64(message.friendId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RemoveFriendRequest
 */
export const RemoveFriendRequest = new RemoveFriendRequest$Type();
