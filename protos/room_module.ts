// @generated by protobuf-ts 2.8.2
// @generated from protobuf file "room_module.proto" (syntax proto2)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message UnUseBuildingReply
 */
export interface UnUseBuildingReply {
    /**
     * @generated from protobuf field: optional BuildingInfo buildingInfo = 1;
     */
    buildingInfo?: BuildingInfo;
}
/**
 * @generated from protobuf message GetBlockPackageInfoReply
 */
export interface GetBlockPackageInfoReply {
    /**
     * @generated from protobuf field: repeated int32 blockPackageIds = 1;
     */
    blockPackageIds: number[];
    /**
     * @generated from protobuf field: repeated SpecialBlockInfo specialBlocks = 2;
     */
    specialBlocks: SpecialBlockInfo[];
}
/**
 * @generated from protobuf message GetCharacterInteractionBonusReply
 */
export interface GetCharacterInteractionBonusReply {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
    /**
     * @generated from protobuf field: repeated int32 selectIds = 2;
     */
    selectIds: number[];
}
/**
 * @generated from protobuf message GetCharacterInteractionBonusRequest
 */
export interface GetCharacterInteractionBonusRequest {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
    /**
     * @generated from protobuf field: repeated int32 selectIds = 2;
     */
    selectIds: number[];
}
/**
 * @generated from protobuf message UnUseBlockRequest
 */
export interface UnUseBlockRequest {
    /**
     * @generated from protobuf field: repeated int32 blockIds = 1;
     */
    blockIds: number[];
}
/**
 * @generated from protobuf message HideBuildingReddotReply
 */
export interface HideBuildingReddotReply {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
}
/**
 * @generated from protobuf message UnUseBuildingRequest
 */
export interface UnUseBuildingRequest {
    /**
     * @generated from protobuf field: optional int64 uid = 1;
     */
    uid?: bigint;
}
/**
 * @generated from protobuf message BuildingInfo
 */
export interface BuildingInfo {
    /**
     * @generated from protobuf field: optional int64 uid = 1;
     */
    uid?: bigint;
    /**
     * @generated from protobuf field: optional int32 defineId = 2;
     */
    defineId?: number;
    /**
     * @generated from protobuf field: optional bool use = 3;
     */
    use?: boolean;
    /**
     * @generated from protobuf field: optional int32 x = 4;
     */
    x?: number;
    /**
     * @generated from protobuf field: optional int32 y = 5;
     */
    y?: number;
    /**
     * @generated from protobuf field: optional int32 rotate = 6;
     */
    rotate?: number;
}
/**
 * @generated from protobuf message GetRoomObInfoReply
 */
export interface GetRoomObInfoReply {
    /**
     * @generated from protobuf field: repeated BlockInfo infos = 1;
     */
    infos: BlockInfo[];
    /**
     * @generated from protobuf field: repeated BuildingInfo buildingInfos = 2;
     */
    buildingInfos: BuildingInfo[];
    /**
     * @generated from protobuf field: repeated FormulaInfo formulaInfos = 3;
     */
    formulaInfos: FormulaInfo[];
    /**
     * @generated from protobuf field: optional int32 roomLevel = 4;
     */
    roomLevel?: number;
    /**
     * @generated from protobuf field: repeated RoomHeroData roomHeroDatas = 5;
     */
    roomHeroDatas: RoomHeroData[];
    /**
     * @generated from protobuf field: repeated ProductionLineInfo productionLines = 6;
     */
    productionLines: ProductionLineInfo[];
}
/**
 * @generated from protobuf message UseBlockRequest
 */
export interface UseBlockRequest {
    /**
     * @generated from protobuf field: optional int32 blockId = 1;
     */
    blockId?: number;
    /**
     * @generated from protobuf field: optional int32 blockPackageId = 2;
     */
    blockPackageId?: number;
    /**
     * @generated from protobuf field: optional int32 rotate = 3;
     */
    rotate?: number;
    /**
     * @generated from protobuf field: optional int32 x = 4;
     */
    x?: number;
    /**
     * @generated from protobuf field: optional int32 y = 5;
     */
    y?: number;
}
/**
 * @generated from protobuf message GainRoomHeroFaithRequest
 */
export interface GainRoomHeroFaithRequest {
    /**
     * @generated from protobuf field: repeated int32 heroIds = 1;
     */
    heroIds: number[];
}
/**
 * @generated from protobuf message SpecialBlockInfo
 */
export interface SpecialBlockInfo {
    /**
     * @generated from protobuf field: optional int32 blockId = 1;
     */
    blockId?: number;
    /**
     * @generated from protobuf field: optional int32 createTime = 2;
     */
    createTime?: number;
}
/**
 * @generated from protobuf message GetRoomInfoReply
 */
export interface GetRoomInfoReply {
    /**
     * @generated from protobuf field: repeated BlockInfo infos = 1;
     */
    infos: BlockInfo[];
    /**
     * @generated from protobuf field: optional bool isReset = 2;
     */
    isReset?: boolean;
    /**
     * @generated from protobuf field: repeated BuildingInfo buildingInfos = 3;
     */
    buildingInfos: BuildingInfo[];
    /**
     * @generated from protobuf field: repeated BlockPackageInfo blockPackages = 4;
     */
    blockPackages: BlockPackageInfo[];
}
/**
 * @generated from protobuf message ProductionLineAccelerateReply
 */
export interface ProductionLineAccelerateReply {
    /**
     * @generated from protobuf field: optional ProductionLineInfo productionLine = 1;
     */
    productionLine?: ProductionLineInfo;
}
/**
 * @generated from protobuf message RoomHeroData
 */
export interface RoomHeroData {
    /**
     * @generated from protobuf field: optional int32 heroId = 1;
     */
    heroId?: number;
    /**
     * @generated from protobuf field: optional int32 currentFaith = 2;
     */
    currentFaith?: number;
    /**
     * @generated from protobuf field: optional int32 nextRefreshTime = 3;
     */
    nextRefreshTime?: number;
    /**
     * @generated from protobuf field: optional int32 skin = 4;
     */
    skin?: number;
    /**
     * @generated from protobuf field: optional int32 currentMinute = 5;
     */
    currentMinute?: number;
}
/**
 * @generated from protobuf message FormulaInfo
 */
export interface FormulaInfo {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
}
/**
 * @generated from protobuf message GetBuildingInfoRequest
 */
export interface GetBuildingInfoRequest {
}
/**
 * @generated from protobuf message UpdateRoomHeroDataRequest
 */
export interface UpdateRoomHeroDataRequest {
    /**
     * @generated from protobuf field: repeated int32 roomHeroIds = 1;
     */
    roomHeroIds: number[];
}
/**
 * @generated from protobuf message HideBuildingReddotRequset
 */
export interface HideBuildingReddotRequset {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
}
/**
 * @generated from protobuf message UpdateRoomHeroDataReply
 */
export interface UpdateRoomHeroDataReply {
    /**
     * @generated from protobuf field: repeated RoomHeroData roomHeroDatas = 1;
     */
    roomHeroDatas: RoomHeroData[];
}
/**
 * @generated from protobuf message UseBuildingRequest
 */
export interface UseBuildingRequest {
    /**
     * @generated from protobuf field: optional int64 uid = 1;
     */
    uid?: bigint;
    /**
     * @generated from protobuf field: optional int32 rotate = 2;
     */
    rotate?: number;
    /**
     * @generated from protobuf field: optional int32 x = 3;
     */
    x?: number;
    /**
     * @generated from protobuf field: optional int32 y = 4;
     */
    y?: number;
}
/**
 * @generated from protobuf message BlockPackageInfo
 */
export interface BlockPackageInfo {
    /**
     * @generated from protobuf field: optional int32 blockPackageId = 1;
     */
    blockPackageId?: number;
    /**
     * @generated from protobuf field: repeated int32 unUseBlockIds = 2;
     */
    unUseBlockIds: number[];
    /**
     * @generated from protobuf field: repeated int32 useBlockIds = 3;
     */
    useBlockIds: number[];
}
/**
 * @generated from protobuf message FormulaGainPush
 */
export interface FormulaGainPush {
    /**
     * @generated from protobuf field: repeated FormulaInfo formulaInfos = 1;
     */
    formulaInfos: FormulaInfo[];
}
/**
 * @generated from protobuf message ProductionLineLvUpRequest
 */
export interface ProductionLineLvUpRequest {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional int32 newLevel = 2;
     */
    newLevel?: number;
}
/**
 * @generated from protobuf message HideBlockPackageReddotReply
 */
export interface HideBlockPackageReddotReply {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
}
/**
 * @generated from protobuf message GetRoomInfoRequest
 */
export interface GetRoomInfoRequest {
}
/**
 * @generated from protobuf message BlockPackageGainPush
 */
export interface BlockPackageGainPush {
    /**
     * @generated from protobuf field: repeated BlockPackageInfo blockPackages = 1;
     */
    blockPackages: BlockPackageInfo[];
}
/**
 * @generated from protobuf message GainRoomHeroFaithReply
 */
export interface GainRoomHeroFaithReply {
    /**
     * @generated from protobuf field: repeated RoomHeroData roomHeroDatas = 1;
     */
    roomHeroDatas: RoomHeroData[];
}
/**
 * @generated from protobuf message CharacterInteractionInfo
 */
export interface CharacterInteractionInfo {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional bool finish = 2;
     */
    finish?: boolean;
    /**
     * @generated from protobuf field: repeated int32 selectIds = 3;
     */
    selectIds: number[];
}
/**
 * @generated from protobuf message ResetRoomReply
 */
export interface ResetRoomReply {
    /**
     * @generated from protobuf field: repeated BlockInfo infos = 1;
     */
    infos: BlockInfo[];
    /**
     * @generated from protobuf field: repeated BlockPackageInfo blockPackages = 2;
     */
    blockPackages: BlockPackageInfo[];
}
/**
 * @generated from protobuf message GainProductionLineRequest
 */
export interface GainProductionLineRequest {
    /**
     * @generated from protobuf field: repeated int32 ids = 1;
     */
    ids: number[];
}
/**
 * @generated from protobuf message ProductionLineInfoRequest
 */
export interface ProductionLineInfoRequest {
    /**
     * @generated from protobuf field: repeated int32 ids = 1;
     */
    ids: number[];
}
/**
 * @generated from protobuf message StartCharacterInteractionReply
 */
export interface StartCharacterInteractionReply {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
}
/**
 * @generated from protobuf message RoomConfirmReply
 */
export interface RoomConfirmReply {
    /**
     * @generated from protobuf field: repeated BlockInfo infos = 1;
     */
    infos: BlockInfo[];
    /**
     * @generated from protobuf field: repeated BuildingInfo buildingInfos = 2;
     */
    buildingInfos: BuildingInfo[];
    /**
     * @generated from protobuf field: repeated FormulaInfo formulaInfos = 3;
     */
    formulaInfos: FormulaInfo[];
    /**
     * @generated from protobuf field: optional int32 roomLevel = 4;
     */
    roomLevel?: number;
    /**
     * @generated from protobuf field: repeated RoomHeroData roomHeroDatas = 5;
     */
    roomHeroDatas: RoomHeroData[];
    /**
     * @generated from protobuf field: repeated ProductionLineInfo productionLines = 6;
     */
    productionLines: ProductionLineInfo[];
}
/**
 * @generated from protobuf message RoomRevertReply
 */
export interface RoomRevertReply {
    /**
     * @generated from protobuf field: repeated BlockInfo infos = 1;
     */
    infos: BlockInfo[];
    /**
     * @generated from protobuf field: repeated BlockPackageInfo blockPackages = 2;
     */
    blockPackages: BlockPackageInfo[];
    /**
     * @generated from protobuf field: repeated BuildingInfo buildingInfos = 3;
     */
    buildingInfos: BuildingInfo[];
}
/**
 * @generated from protobuf message ProductionLineLvUpReply
 */
export interface ProductionLineLvUpReply {
    /**
     * @generated from protobuf field: optional ProductionLineInfo productionLine = 1;
     */
    productionLine?: ProductionLineInfo;
}
/**
 * @generated from protobuf message GetBuildingInfoReply
 */
export interface GetBuildingInfoReply {
    /**
     * @generated from protobuf field: repeated BuildingInfo buildingInfos = 1;
     */
    buildingInfos: BuildingInfo[];
}
/**
 * @generated from protobuf message ProductionLineInfo
 */
export interface ProductionLineInfo {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional int32 formulaId = 2;
     */
    formulaId?: number;
    /**
     * @generated from protobuf field: optional int32 finishCount = 3;
     */
    finishCount?: number;
    /**
     * @generated from protobuf field: optional int32 nextFinishTime = 4;
     */
    nextFinishTime?: number;
    /**
     * @generated from protobuf field: optional int32 pauseTime = 5;
     */
    pauseTime?: number;
    /**
     * @generated from protobuf field: optional int32 level = 6;
     */
    level?: number;
}
/**
 * @generated from protobuf message ResetRoomRequest
 */
export interface ResetRoomRequest {
}
/**
 * @generated from protobuf message GainProductionLineReply
 */
export interface GainProductionLineReply {
    /**
     * @generated from protobuf field: repeated ProductionLineInfo productionLines = 1;
     */
    productionLines: ProductionLineInfo[];
}
/**
 * @generated from protobuf message UseBuildingReply
 */
export interface UseBuildingReply {
    /**
     * @generated from protobuf field: optional BuildingInfo buildingInfo = 1;
     */
    buildingInfo?: BuildingInfo;
}
/**
 * @generated from protobuf message ProductionLineInfoReply
 */
export interface ProductionLineInfoReply {
    /**
     * @generated from protobuf field: repeated ProductionLineInfo productionLines = 1;
     */
    productionLines: ProductionLineInfo[];
}
/**
 * @generated from protobuf message HideBlockPackageReddotRequest
 */
export interface HideBlockPackageReddotRequest {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
}
/**
 * @generated from protobuf message BlockInfo
 */
export interface BlockInfo {
    /**
     * @generated from protobuf field: optional int32 blockId = 1;
     */
    blockId?: number;
    /**
     * @generated from protobuf field: optional int32 x = 2;
     */
    x?: number;
    /**
     * @generated from protobuf field: optional int32 y = 3;
     */
    y?: number;
    /**
     * @generated from protobuf field: optional int32 rotate = 4;
     */
    rotate?: number;
}
/**
 * @generated from protobuf message BuildingGainPush
 */
export interface BuildingGainPush {
    /**
     * @generated from protobuf field: repeated BuildingInfo buildingInfos = 1;
     */
    buildingInfos: BuildingInfo[];
}
/**
 * @generated from protobuf message RoomConfirmRequest
 */
export interface RoomConfirmRequest {
}
/**
 * @generated from protobuf message StartProductionLineRequest
 */
export interface StartProductionLineRequest {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional int32 formulaId = 2;
     */
    formulaId?: number;
    /**
     * @generated from protobuf field: optional int32 count = 3;
     */
    count?: number;
}
/**
 * @generated from protobuf message RoomLevelUpRequest
 */
export interface RoomLevelUpRequest {
}
/**
 * @generated from protobuf message ProductionLineAccelerateRequest
 */
export interface ProductionLineAccelerateRequest {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
    /**
     * @generated from protobuf field: optional int32 useItemCount = 2;
     */
    useItemCount?: number;
}
/**
 * @generated from protobuf message RoomLevelUpReply
 */
export interface RoomLevelUpReply {
    /**
     * @generated from protobuf field: optional int32 roomLevel = 1;
     */
    roomLevel?: number;
    /**
     * @generated from protobuf field: repeated ProductionLineInfo productionLines = 2;
     */
    productionLines: ProductionLineInfo[];
}
/**
 * @generated from protobuf message RoomRevertRequest
 */
export interface RoomRevertRequest {
}
/**
 * @generated from protobuf message GetOtherRoomObInfoRequest
 */
export interface GetOtherRoomObInfoRequest {
    /**
     * @generated from protobuf field: optional int64 targetUid = 1;
     */
    targetUid?: bigint;
}
/**
 * @generated from protobuf message GainSpecialBlockPush
 */
export interface GainSpecialBlockPush {
    /**
     * @generated from protobuf field: repeated int32 specialBlocks = 1;
     */
    specialBlocks: number[];
}
/**
 * @generated from protobuf message UseBlockReply
 */
export interface UseBlockReply {
    /**
     * @generated from protobuf field: optional int32 blockId = 1;
     */
    blockId?: number;
    /**
     * @generated from protobuf field: optional int32 rotate = 2;
     */
    rotate?: number;
    /**
     * @generated from protobuf field: optional int32 x = 3;
     */
    x?: number;
    /**
     * @generated from protobuf field: optional int32 y = 4;
     */
    y?: number;
}
/**
 * @generated from protobuf message StartProductionLineReply
 */
export interface StartProductionLineReply {
    /**
     * @generated from protobuf field: optional ProductionLineInfo productionLine = 1;
     */
    productionLine?: ProductionLineInfo;
}
/**
 * @generated from protobuf message GetRoomObInfoRequest
 */
export interface GetRoomObInfoRequest {
    /**
     * @generated from protobuf field: optional bool needBlockData = 1;
     */
    needBlockData?: boolean;
}
/**
 * @generated from protobuf message GetCharacterInteractionInfoReply
 */
export interface GetCharacterInteractionInfoReply {
    /**
     * @generated from protobuf field: repeated CharacterInteractionInfo infos = 1;
     */
    infos: CharacterInteractionInfo[];
    /**
     * @generated from protobuf field: optional int32 interactionCount = 2;
     */
    interactionCount?: number;
}
/**
 * @generated from protobuf message GetCharacterInteractionInfoRequest
 */
export interface GetCharacterInteractionInfoRequest {
}
/**
 * @generated from protobuf message GetBlockPackageInfoRequset
 */
export interface GetBlockPackageInfoRequset {
}
/**
 * @generated from protobuf message StartCharacterInteractionRequest
 */
export interface StartCharacterInteractionRequest {
    /**
     * @generated from protobuf field: optional int32 id = 1;
     */
    id?: number;
}
/**
 * @generated from protobuf message UnUseBlockReply
 */
export interface UnUseBlockReply {
    /**
     * @generated from protobuf field: repeated int32 blockIds = 1;
     */
    blockIds: number[];
    /**
     * @generated from protobuf field: repeated BuildingInfo buildingInfos = 2;
     */
    buildingInfos: BuildingInfo[];
}
/**
 * @generated from protobuf message GetOtherRoomObInfoReply
 */
export interface GetOtherRoomObInfoReply {
    /**
     * @generated from protobuf field: repeated BlockInfo infos = 1;
     */
    infos: BlockInfo[];
    /**
     * @generated from protobuf field: repeated BuildingInfo buildingInfos = 2;
     */
    buildingInfos: BuildingInfo[];
    /**
     * @generated from protobuf field: optional int64 targetUid = 3;
     */
    targetUid?: bigint;
    /**
     * @generated from protobuf field: optional int32 roomLevel = 4;
     */
    roomLevel?: number;
    /**
     * @generated from protobuf field: repeated RoomHeroData roomHeroDatas = 5;
     */
    roomHeroDatas: RoomHeroData[];
    /**
     * @generated from protobuf field: repeated ProductionLineInfo productionLines = 6;
     */
    productionLines: ProductionLineInfo[];
}
// @generated message type with reflection information, may provide speed optimized methods
class UnUseBuildingReply$Type extends MessageType<UnUseBuildingReply> {
    constructor() {
        super("UnUseBuildingReply", [
            { no: 1, name: "buildingInfo", kind: "message", T: () => BuildingInfo }
        ]);
    }
    create(value?: PartialMessage<UnUseBuildingReply>): UnUseBuildingReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UnUseBuildingReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnUseBuildingReply): UnUseBuildingReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional BuildingInfo buildingInfo */ 1:
                    message.buildingInfo = BuildingInfo.internalBinaryRead(reader, reader.uint32(), options, message.buildingInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnUseBuildingReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional BuildingInfo buildingInfo = 1; */
        if (message.buildingInfo)
            BuildingInfo.internalBinaryWrite(message.buildingInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UnUseBuildingReply
 */
export const UnUseBuildingReply = new UnUseBuildingReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBlockPackageInfoReply$Type extends MessageType<GetBlockPackageInfoReply> {
    constructor() {
        super("GetBlockPackageInfoReply", [
            { no: 1, name: "blockPackageIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "specialBlocks", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => SpecialBlockInfo }
        ]);
    }
    create(value?: PartialMessage<GetBlockPackageInfoReply>): GetBlockPackageInfoReply {
        const message = { blockPackageIds: [], specialBlocks: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetBlockPackageInfoReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBlockPackageInfoReply): GetBlockPackageInfoReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 blockPackageIds */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.blockPackageIds.push(reader.int32());
                    else
                        message.blockPackageIds.push(reader.int32());
                    break;
                case /* repeated SpecialBlockInfo specialBlocks */ 2:
                    message.specialBlocks.push(SpecialBlockInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBlockPackageInfoReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 blockPackageIds = 1; */
        for (let i = 0; i < message.blockPackageIds.length; i++)
            writer.tag(1, WireType.Varint).int32(message.blockPackageIds[i]);
        /* repeated SpecialBlockInfo specialBlocks = 2; */
        for (let i = 0; i < message.specialBlocks.length; i++)
            SpecialBlockInfo.internalBinaryWrite(message.specialBlocks[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetBlockPackageInfoReply
 */
export const GetBlockPackageInfoReply = new GetBlockPackageInfoReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCharacterInteractionBonusReply$Type extends MessageType<GetCharacterInteractionBonusReply> {
    constructor() {
        super("GetCharacterInteractionBonusReply", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "selectIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetCharacterInteractionBonusReply>): GetCharacterInteractionBonusReply {
        const message = { selectIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetCharacterInteractionBonusReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCharacterInteractionBonusReply): GetCharacterInteractionBonusReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* repeated int32 selectIds */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.selectIds.push(reader.int32());
                    else
                        message.selectIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCharacterInteractionBonusReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* repeated int32 selectIds = 2; */
        for (let i = 0; i < message.selectIds.length; i++)
            writer.tag(2, WireType.Varint).int32(message.selectIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetCharacterInteractionBonusReply
 */
export const GetCharacterInteractionBonusReply = new GetCharacterInteractionBonusReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCharacterInteractionBonusRequest$Type extends MessageType<GetCharacterInteractionBonusRequest> {
    constructor() {
        super("GetCharacterInteractionBonusRequest", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "selectIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetCharacterInteractionBonusRequest>): GetCharacterInteractionBonusRequest {
        const message = { selectIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetCharacterInteractionBonusRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCharacterInteractionBonusRequest): GetCharacterInteractionBonusRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* repeated int32 selectIds */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.selectIds.push(reader.int32());
                    else
                        message.selectIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCharacterInteractionBonusRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* repeated int32 selectIds = 2; */
        for (let i = 0; i < message.selectIds.length; i++)
            writer.tag(2, WireType.Varint).int32(message.selectIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetCharacterInteractionBonusRequest
 */
export const GetCharacterInteractionBonusRequest = new GetCharacterInteractionBonusRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnUseBlockRequest$Type extends MessageType<UnUseBlockRequest> {
    constructor() {
        super("UnUseBlockRequest", [
            { no: 1, name: "blockIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<UnUseBlockRequest>): UnUseBlockRequest {
        const message = { blockIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UnUseBlockRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnUseBlockRequest): UnUseBlockRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 blockIds */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.blockIds.push(reader.int32());
                    else
                        message.blockIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnUseBlockRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 blockIds = 1; */
        for (let i = 0; i < message.blockIds.length; i++)
            writer.tag(1, WireType.Varint).int32(message.blockIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UnUseBlockRequest
 */
export const UnUseBlockRequest = new UnUseBlockRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HideBuildingReddotReply$Type extends MessageType<HideBuildingReddotReply> {
    constructor() {
        super("HideBuildingReddotReply", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HideBuildingReddotReply>): HideBuildingReddotReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HideBuildingReddotReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HideBuildingReddotReply): HideBuildingReddotReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HideBuildingReddotReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HideBuildingReddotReply
 */
export const HideBuildingReddotReply = new HideBuildingReddotReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnUseBuildingRequest$Type extends MessageType<UnUseBuildingRequest> {
    constructor() {
        super("UnUseBuildingRequest", [
            { no: 1, name: "uid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<UnUseBuildingRequest>): UnUseBuildingRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UnUseBuildingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnUseBuildingRequest): UnUseBuildingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 uid */ 1:
                    message.uid = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnUseBuildingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 uid = 1; */
        if (message.uid !== undefined)
            writer.tag(1, WireType.Varint).int64(message.uid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UnUseBuildingRequest
 */
export const UnUseBuildingRequest = new UnUseBuildingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuildingInfo$Type extends MessageType<BuildingInfo> {
    constructor() {
        super("BuildingInfo", [
            { no: 1, name: "uid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "defineId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "use", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 4, name: "x", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "y", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "rotate", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BuildingInfo>): BuildingInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuildingInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuildingInfo): BuildingInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 uid */ 1:
                    message.uid = reader.int64().toBigInt();
                    break;
                case /* optional int32 defineId */ 2:
                    message.defineId = reader.int32();
                    break;
                case /* optional bool use */ 3:
                    message.use = reader.bool();
                    break;
                case /* optional int32 x */ 4:
                    message.x = reader.int32();
                    break;
                case /* optional int32 y */ 5:
                    message.y = reader.int32();
                    break;
                case /* optional int32 rotate */ 6:
                    message.rotate = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuildingInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 uid = 1; */
        if (message.uid !== undefined)
            writer.tag(1, WireType.Varint).int64(message.uid);
        /* optional int32 defineId = 2; */
        if (message.defineId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.defineId);
        /* optional bool use = 3; */
        if (message.use !== undefined)
            writer.tag(3, WireType.Varint).bool(message.use);
        /* optional int32 x = 4; */
        if (message.x !== undefined)
            writer.tag(4, WireType.Varint).int32(message.x);
        /* optional int32 y = 5; */
        if (message.y !== undefined)
            writer.tag(5, WireType.Varint).int32(message.y);
        /* optional int32 rotate = 6; */
        if (message.rotate !== undefined)
            writer.tag(6, WireType.Varint).int32(message.rotate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BuildingInfo
 */
export const BuildingInfo = new BuildingInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRoomObInfoReply$Type extends MessageType<GetRoomObInfoReply> {
    constructor() {
        super("GetRoomObInfoReply", [
            { no: 1, name: "infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BlockInfo },
            { no: 2, name: "buildingInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BuildingInfo },
            { no: 3, name: "formulaInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FormulaInfo },
            { no: 4, name: "roomLevel", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "roomHeroDatas", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RoomHeroData },
            { no: 6, name: "productionLines", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ProductionLineInfo }
        ]);
    }
    create(value?: PartialMessage<GetRoomObInfoReply>): GetRoomObInfoReply {
        const message = { infos: [], buildingInfos: [], formulaInfos: [], roomHeroDatas: [], productionLines: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetRoomObInfoReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRoomObInfoReply): GetRoomObInfoReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated BlockInfo infos */ 1:
                    message.infos.push(BlockInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated BuildingInfo buildingInfos */ 2:
                    message.buildingInfos.push(BuildingInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated FormulaInfo formulaInfos */ 3:
                    message.formulaInfos.push(FormulaInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 roomLevel */ 4:
                    message.roomLevel = reader.int32();
                    break;
                case /* repeated RoomHeroData roomHeroDatas */ 5:
                    message.roomHeroDatas.push(RoomHeroData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ProductionLineInfo productionLines */ 6:
                    message.productionLines.push(ProductionLineInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRoomObInfoReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated BlockInfo infos = 1; */
        for (let i = 0; i < message.infos.length; i++)
            BlockInfo.internalBinaryWrite(message.infos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated BuildingInfo buildingInfos = 2; */
        for (let i = 0; i < message.buildingInfos.length; i++)
            BuildingInfo.internalBinaryWrite(message.buildingInfos[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated FormulaInfo formulaInfos = 3; */
        for (let i = 0; i < message.formulaInfos.length; i++)
            FormulaInfo.internalBinaryWrite(message.formulaInfos[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 roomLevel = 4; */
        if (message.roomLevel !== undefined)
            writer.tag(4, WireType.Varint).int32(message.roomLevel);
        /* repeated RoomHeroData roomHeroDatas = 5; */
        for (let i = 0; i < message.roomHeroDatas.length; i++)
            RoomHeroData.internalBinaryWrite(message.roomHeroDatas[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated ProductionLineInfo productionLines = 6; */
        for (let i = 0; i < message.productionLines.length; i++)
            ProductionLineInfo.internalBinaryWrite(message.productionLines[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetRoomObInfoReply
 */
export const GetRoomObInfoReply = new GetRoomObInfoReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UseBlockRequest$Type extends MessageType<UseBlockRequest> {
    constructor() {
        super("UseBlockRequest", [
            { no: 1, name: "blockId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "blockPackageId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "rotate", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "x", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "y", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<UseBlockRequest>): UseBlockRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UseBlockRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UseBlockRequest): UseBlockRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 blockId */ 1:
                    message.blockId = reader.int32();
                    break;
                case /* optional int32 blockPackageId */ 2:
                    message.blockPackageId = reader.int32();
                    break;
                case /* optional int32 rotate */ 3:
                    message.rotate = reader.int32();
                    break;
                case /* optional int32 x */ 4:
                    message.x = reader.int32();
                    break;
                case /* optional int32 y */ 5:
                    message.y = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UseBlockRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 blockId = 1; */
        if (message.blockId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.blockId);
        /* optional int32 blockPackageId = 2; */
        if (message.blockPackageId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.blockPackageId);
        /* optional int32 rotate = 3; */
        if (message.rotate !== undefined)
            writer.tag(3, WireType.Varint).int32(message.rotate);
        /* optional int32 x = 4; */
        if (message.x !== undefined)
            writer.tag(4, WireType.Varint).int32(message.x);
        /* optional int32 y = 5; */
        if (message.y !== undefined)
            writer.tag(5, WireType.Varint).int32(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UseBlockRequest
 */
export const UseBlockRequest = new UseBlockRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GainRoomHeroFaithRequest$Type extends MessageType<GainRoomHeroFaithRequest> {
    constructor() {
        super("GainRoomHeroFaithRequest", [
            { no: 1, name: "heroIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GainRoomHeroFaithRequest>): GainRoomHeroFaithRequest {
        const message = { heroIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GainRoomHeroFaithRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GainRoomHeroFaithRequest): GainRoomHeroFaithRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 heroIds */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.heroIds.push(reader.int32());
                    else
                        message.heroIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GainRoomHeroFaithRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 heroIds = 1; */
        for (let i = 0; i < message.heroIds.length; i++)
            writer.tag(1, WireType.Varint).int32(message.heroIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GainRoomHeroFaithRequest
 */
export const GainRoomHeroFaithRequest = new GainRoomHeroFaithRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SpecialBlockInfo$Type extends MessageType<SpecialBlockInfo> {
    constructor() {
        super("SpecialBlockInfo", [
            { no: 1, name: "blockId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "createTime", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<SpecialBlockInfo>): SpecialBlockInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<SpecialBlockInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SpecialBlockInfo): SpecialBlockInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 blockId */ 1:
                    message.blockId = reader.int32();
                    break;
                case /* optional int32 createTime */ 2:
                    message.createTime = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SpecialBlockInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 blockId = 1; */
        if (message.blockId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.blockId);
        /* optional int32 createTime = 2; */
        if (message.createTime !== undefined)
            writer.tag(2, WireType.Varint).int32(message.createTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SpecialBlockInfo
 */
export const SpecialBlockInfo = new SpecialBlockInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRoomInfoReply$Type extends MessageType<GetRoomInfoReply> {
    constructor() {
        super("GetRoomInfoReply", [
            { no: 1, name: "infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BlockInfo },
            { no: 2, name: "isReset", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "buildingInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BuildingInfo },
            { no: 4, name: "blockPackages", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BlockPackageInfo }
        ]);
    }
    create(value?: PartialMessage<GetRoomInfoReply>): GetRoomInfoReply {
        const message = { infos: [], buildingInfos: [], blockPackages: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetRoomInfoReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRoomInfoReply): GetRoomInfoReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated BlockInfo infos */ 1:
                    message.infos.push(BlockInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional bool isReset */ 2:
                    message.isReset = reader.bool();
                    break;
                case /* repeated BuildingInfo buildingInfos */ 3:
                    message.buildingInfos.push(BuildingInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated BlockPackageInfo blockPackages */ 4:
                    message.blockPackages.push(BlockPackageInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRoomInfoReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated BlockInfo infos = 1; */
        for (let i = 0; i < message.infos.length; i++)
            BlockInfo.internalBinaryWrite(message.infos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional bool isReset = 2; */
        if (message.isReset !== undefined)
            writer.tag(2, WireType.Varint).bool(message.isReset);
        /* repeated BuildingInfo buildingInfos = 3; */
        for (let i = 0; i < message.buildingInfos.length; i++)
            BuildingInfo.internalBinaryWrite(message.buildingInfos[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* repeated BlockPackageInfo blockPackages = 4; */
        for (let i = 0; i < message.blockPackages.length; i++)
            BlockPackageInfo.internalBinaryWrite(message.blockPackages[i], writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetRoomInfoReply
 */
export const GetRoomInfoReply = new GetRoomInfoReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProductionLineAccelerateReply$Type extends MessageType<ProductionLineAccelerateReply> {
    constructor() {
        super("ProductionLineAccelerateReply", [
            { no: 1, name: "productionLine", kind: "message", T: () => ProductionLineInfo }
        ]);
    }
    create(value?: PartialMessage<ProductionLineAccelerateReply>): ProductionLineAccelerateReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ProductionLineAccelerateReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProductionLineAccelerateReply): ProductionLineAccelerateReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional ProductionLineInfo productionLine */ 1:
                    message.productionLine = ProductionLineInfo.internalBinaryRead(reader, reader.uint32(), options, message.productionLine);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProductionLineAccelerateReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional ProductionLineInfo productionLine = 1; */
        if (message.productionLine)
            ProductionLineInfo.internalBinaryWrite(message.productionLine, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ProductionLineAccelerateReply
 */
export const ProductionLineAccelerateReply = new ProductionLineAccelerateReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoomHeroData$Type extends MessageType<RoomHeroData> {
    constructor() {
        super("RoomHeroData", [
            { no: 1, name: "heroId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "currentFaith", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "nextRefreshTime", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "skin", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "currentMinute", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<RoomHeroData>): RoomHeroData {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RoomHeroData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoomHeroData): RoomHeroData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 heroId */ 1:
                    message.heroId = reader.int32();
                    break;
                case /* optional int32 currentFaith */ 2:
                    message.currentFaith = reader.int32();
                    break;
                case /* optional int32 nextRefreshTime */ 3:
                    message.nextRefreshTime = reader.int32();
                    break;
                case /* optional int32 skin */ 4:
                    message.skin = reader.int32();
                    break;
                case /* optional int32 currentMinute */ 5:
                    message.currentMinute = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoomHeroData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 heroId = 1; */
        if (message.heroId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.heroId);
        /* optional int32 currentFaith = 2; */
        if (message.currentFaith !== undefined)
            writer.tag(2, WireType.Varint).int32(message.currentFaith);
        /* optional int32 nextRefreshTime = 3; */
        if (message.nextRefreshTime !== undefined)
            writer.tag(3, WireType.Varint).int32(message.nextRefreshTime);
        /* optional int32 skin = 4; */
        if (message.skin !== undefined)
            writer.tag(4, WireType.Varint).int32(message.skin);
        /* optional int32 currentMinute = 5; */
        if (message.currentMinute !== undefined)
            writer.tag(5, WireType.Varint).int32(message.currentMinute);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RoomHeroData
 */
export const RoomHeroData = new RoomHeroData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormulaInfo$Type extends MessageType<FormulaInfo> {
    constructor() {
        super("FormulaInfo", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<FormulaInfo>): FormulaInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FormulaInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FormulaInfo): FormulaInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FormulaInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FormulaInfo
 */
export const FormulaInfo = new FormulaInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBuildingInfoRequest$Type extends MessageType<GetBuildingInfoRequest> {
    constructor() {
        super("GetBuildingInfoRequest", []);
    }
    create(value?: PartialMessage<GetBuildingInfoRequest>): GetBuildingInfoRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetBuildingInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBuildingInfoRequest): GetBuildingInfoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetBuildingInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetBuildingInfoRequest
 */
export const GetBuildingInfoRequest = new GetBuildingInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateRoomHeroDataRequest$Type extends MessageType<UpdateRoomHeroDataRequest> {
    constructor() {
        super("UpdateRoomHeroDataRequest", [
            { no: 1, name: "roomHeroIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateRoomHeroDataRequest>): UpdateRoomHeroDataRequest {
        const message = { roomHeroIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateRoomHeroDataRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateRoomHeroDataRequest): UpdateRoomHeroDataRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 roomHeroIds */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.roomHeroIds.push(reader.int32());
                    else
                        message.roomHeroIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateRoomHeroDataRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 roomHeroIds = 1; */
        for (let i = 0; i < message.roomHeroIds.length; i++)
            writer.tag(1, WireType.Varint).int32(message.roomHeroIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateRoomHeroDataRequest
 */
export const UpdateRoomHeroDataRequest = new UpdateRoomHeroDataRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HideBuildingReddotRequset$Type extends MessageType<HideBuildingReddotRequset> {
    constructor() {
        super("HideBuildingReddotRequset", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HideBuildingReddotRequset>): HideBuildingReddotRequset {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HideBuildingReddotRequset>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HideBuildingReddotRequset): HideBuildingReddotRequset {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HideBuildingReddotRequset, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HideBuildingReddotRequset
 */
export const HideBuildingReddotRequset = new HideBuildingReddotRequset$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateRoomHeroDataReply$Type extends MessageType<UpdateRoomHeroDataReply> {
    constructor() {
        super("UpdateRoomHeroDataReply", [
            { no: 1, name: "roomHeroDatas", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RoomHeroData }
        ]);
    }
    create(value?: PartialMessage<UpdateRoomHeroDataReply>): UpdateRoomHeroDataReply {
        const message = { roomHeroDatas: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UpdateRoomHeroDataReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateRoomHeroDataReply): UpdateRoomHeroDataReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated RoomHeroData roomHeroDatas */ 1:
                    message.roomHeroDatas.push(RoomHeroData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateRoomHeroDataReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated RoomHeroData roomHeroDatas = 1; */
        for (let i = 0; i < message.roomHeroDatas.length; i++)
            RoomHeroData.internalBinaryWrite(message.roomHeroDatas[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateRoomHeroDataReply
 */
export const UpdateRoomHeroDataReply = new UpdateRoomHeroDataReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UseBuildingRequest$Type extends MessageType<UseBuildingRequest> {
    constructor() {
        super("UseBuildingRequest", [
            { no: 1, name: "uid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 2, name: "rotate", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "x", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "y", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<UseBuildingRequest>): UseBuildingRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UseBuildingRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UseBuildingRequest): UseBuildingRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 uid */ 1:
                    message.uid = reader.int64().toBigInt();
                    break;
                case /* optional int32 rotate */ 2:
                    message.rotate = reader.int32();
                    break;
                case /* optional int32 x */ 3:
                    message.x = reader.int32();
                    break;
                case /* optional int32 y */ 4:
                    message.y = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UseBuildingRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 uid = 1; */
        if (message.uid !== undefined)
            writer.tag(1, WireType.Varint).int64(message.uid);
        /* optional int32 rotate = 2; */
        if (message.rotate !== undefined)
            writer.tag(2, WireType.Varint).int32(message.rotate);
        /* optional int32 x = 3; */
        if (message.x !== undefined)
            writer.tag(3, WireType.Varint).int32(message.x);
        /* optional int32 y = 4; */
        if (message.y !== undefined)
            writer.tag(4, WireType.Varint).int32(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UseBuildingRequest
 */
export const UseBuildingRequest = new UseBuildingRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockPackageInfo$Type extends MessageType<BlockPackageInfo> {
    constructor() {
        super("BlockPackageInfo", [
            { no: 1, name: "blockPackageId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "unUseBlockIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "useBlockIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BlockPackageInfo>): BlockPackageInfo {
        const message = { unUseBlockIds: [], useBlockIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BlockPackageInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlockPackageInfo): BlockPackageInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 blockPackageId */ 1:
                    message.blockPackageId = reader.int32();
                    break;
                case /* repeated int32 unUseBlockIds */ 2:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.unUseBlockIds.push(reader.int32());
                    else
                        message.unUseBlockIds.push(reader.int32());
                    break;
                case /* repeated int32 useBlockIds */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.useBlockIds.push(reader.int32());
                    else
                        message.useBlockIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlockPackageInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 blockPackageId = 1; */
        if (message.blockPackageId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.blockPackageId);
        /* repeated int32 unUseBlockIds = 2; */
        for (let i = 0; i < message.unUseBlockIds.length; i++)
            writer.tag(2, WireType.Varint).int32(message.unUseBlockIds[i]);
        /* repeated int32 useBlockIds = 3; */
        for (let i = 0; i < message.useBlockIds.length; i++)
            writer.tag(3, WireType.Varint).int32(message.useBlockIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BlockPackageInfo
 */
export const BlockPackageInfo = new BlockPackageInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FormulaGainPush$Type extends MessageType<FormulaGainPush> {
    constructor() {
        super("FormulaGainPush", [
            { no: 1, name: "formulaInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FormulaInfo }
        ]);
    }
    create(value?: PartialMessage<FormulaGainPush>): FormulaGainPush {
        const message = { formulaInfos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<FormulaGainPush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FormulaGainPush): FormulaGainPush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated FormulaInfo formulaInfos */ 1:
                    message.formulaInfos.push(FormulaInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FormulaGainPush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated FormulaInfo formulaInfos = 1; */
        for (let i = 0; i < message.formulaInfos.length; i++)
            FormulaInfo.internalBinaryWrite(message.formulaInfos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FormulaGainPush
 */
export const FormulaGainPush = new FormulaGainPush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProductionLineLvUpRequest$Type extends MessageType<ProductionLineLvUpRequest> {
    constructor() {
        super("ProductionLineLvUpRequest", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "newLevel", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ProductionLineLvUpRequest>): ProductionLineLvUpRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ProductionLineLvUpRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProductionLineLvUpRequest): ProductionLineLvUpRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* optional int32 newLevel */ 2:
                    message.newLevel = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProductionLineLvUpRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* optional int32 newLevel = 2; */
        if (message.newLevel !== undefined)
            writer.tag(2, WireType.Varint).int32(message.newLevel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ProductionLineLvUpRequest
 */
export const ProductionLineLvUpRequest = new ProductionLineLvUpRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HideBlockPackageReddotReply$Type extends MessageType<HideBlockPackageReddotReply> {
    constructor() {
        super("HideBlockPackageReddotReply", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HideBlockPackageReddotReply>): HideBlockPackageReddotReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HideBlockPackageReddotReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HideBlockPackageReddotReply): HideBlockPackageReddotReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HideBlockPackageReddotReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HideBlockPackageReddotReply
 */
export const HideBlockPackageReddotReply = new HideBlockPackageReddotReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRoomInfoRequest$Type extends MessageType<GetRoomInfoRequest> {
    constructor() {
        super("GetRoomInfoRequest", []);
    }
    create(value?: PartialMessage<GetRoomInfoRequest>): GetRoomInfoRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetRoomInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRoomInfoRequest): GetRoomInfoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetRoomInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetRoomInfoRequest
 */
export const GetRoomInfoRequest = new GetRoomInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockPackageGainPush$Type extends MessageType<BlockPackageGainPush> {
    constructor() {
        super("BlockPackageGainPush", [
            { no: 1, name: "blockPackages", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BlockPackageInfo }
        ]);
    }
    create(value?: PartialMessage<BlockPackageGainPush>): BlockPackageGainPush {
        const message = { blockPackages: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BlockPackageGainPush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlockPackageGainPush): BlockPackageGainPush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated BlockPackageInfo blockPackages */ 1:
                    message.blockPackages.push(BlockPackageInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlockPackageGainPush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated BlockPackageInfo blockPackages = 1; */
        for (let i = 0; i < message.blockPackages.length; i++)
            BlockPackageInfo.internalBinaryWrite(message.blockPackages[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BlockPackageGainPush
 */
export const BlockPackageGainPush = new BlockPackageGainPush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GainRoomHeroFaithReply$Type extends MessageType<GainRoomHeroFaithReply> {
    constructor() {
        super("GainRoomHeroFaithReply", [
            { no: 1, name: "roomHeroDatas", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RoomHeroData }
        ]);
    }
    create(value?: PartialMessage<GainRoomHeroFaithReply>): GainRoomHeroFaithReply {
        const message = { roomHeroDatas: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GainRoomHeroFaithReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GainRoomHeroFaithReply): GainRoomHeroFaithReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated RoomHeroData roomHeroDatas */ 1:
                    message.roomHeroDatas.push(RoomHeroData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GainRoomHeroFaithReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated RoomHeroData roomHeroDatas = 1; */
        for (let i = 0; i < message.roomHeroDatas.length; i++)
            RoomHeroData.internalBinaryWrite(message.roomHeroDatas[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GainRoomHeroFaithReply
 */
export const GainRoomHeroFaithReply = new GainRoomHeroFaithReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CharacterInteractionInfo$Type extends MessageType<CharacterInteractionInfo> {
    constructor() {
        super("CharacterInteractionInfo", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "finish", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "selectIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<CharacterInteractionInfo>): CharacterInteractionInfo {
        const message = { selectIds: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<CharacterInteractionInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CharacterInteractionInfo): CharacterInteractionInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* optional bool finish */ 2:
                    message.finish = reader.bool();
                    break;
                case /* repeated int32 selectIds */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.selectIds.push(reader.int32());
                    else
                        message.selectIds.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CharacterInteractionInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* optional bool finish = 2; */
        if (message.finish !== undefined)
            writer.tag(2, WireType.Varint).bool(message.finish);
        /* repeated int32 selectIds = 3; */
        for (let i = 0; i < message.selectIds.length; i++)
            writer.tag(3, WireType.Varint).int32(message.selectIds[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message CharacterInteractionInfo
 */
export const CharacterInteractionInfo = new CharacterInteractionInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResetRoomReply$Type extends MessageType<ResetRoomReply> {
    constructor() {
        super("ResetRoomReply", [
            { no: 1, name: "infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BlockInfo },
            { no: 2, name: "blockPackages", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BlockPackageInfo }
        ]);
    }
    create(value?: PartialMessage<ResetRoomReply>): ResetRoomReply {
        const message = { infos: [], blockPackages: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResetRoomReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResetRoomReply): ResetRoomReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated BlockInfo infos */ 1:
                    message.infos.push(BlockInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated BlockPackageInfo blockPackages */ 2:
                    message.blockPackages.push(BlockPackageInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResetRoomReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated BlockInfo infos = 1; */
        for (let i = 0; i < message.infos.length; i++)
            BlockInfo.internalBinaryWrite(message.infos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated BlockPackageInfo blockPackages = 2; */
        for (let i = 0; i < message.blockPackages.length; i++)
            BlockPackageInfo.internalBinaryWrite(message.blockPackages[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ResetRoomReply
 */
export const ResetRoomReply = new ResetRoomReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GainProductionLineRequest$Type extends MessageType<GainProductionLineRequest> {
    constructor() {
        super("GainProductionLineRequest", [
            { no: 1, name: "ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GainProductionLineRequest>): GainProductionLineRequest {
        const message = { ids: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GainProductionLineRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GainProductionLineRequest): GainProductionLineRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ids.push(reader.int32());
                    else
                        message.ids.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GainProductionLineRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 ids = 1; */
        for (let i = 0; i < message.ids.length; i++)
            writer.tag(1, WireType.Varint).int32(message.ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GainProductionLineRequest
 */
export const GainProductionLineRequest = new GainProductionLineRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProductionLineInfoRequest$Type extends MessageType<ProductionLineInfoRequest> {
    constructor() {
        super("ProductionLineInfoRequest", [
            { no: 1, name: "ids", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ProductionLineInfoRequest>): ProductionLineInfoRequest {
        const message = { ids: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ProductionLineInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProductionLineInfoRequest): ProductionLineInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 ids */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.ids.push(reader.int32());
                    else
                        message.ids.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProductionLineInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 ids = 1; */
        for (let i = 0; i < message.ids.length; i++)
            writer.tag(1, WireType.Varint).int32(message.ids[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ProductionLineInfoRequest
 */
export const ProductionLineInfoRequest = new ProductionLineInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartCharacterInteractionReply$Type extends MessageType<StartCharacterInteractionReply> {
    constructor() {
        super("StartCharacterInteractionReply", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<StartCharacterInteractionReply>): StartCharacterInteractionReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StartCharacterInteractionReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartCharacterInteractionReply): StartCharacterInteractionReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartCharacterInteractionReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StartCharacterInteractionReply
 */
export const StartCharacterInteractionReply = new StartCharacterInteractionReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoomConfirmReply$Type extends MessageType<RoomConfirmReply> {
    constructor() {
        super("RoomConfirmReply", [
            { no: 1, name: "infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BlockInfo },
            { no: 2, name: "buildingInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BuildingInfo },
            { no: 3, name: "formulaInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FormulaInfo },
            { no: 4, name: "roomLevel", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "roomHeroDatas", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RoomHeroData },
            { no: 6, name: "productionLines", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ProductionLineInfo }
        ]);
    }
    create(value?: PartialMessage<RoomConfirmReply>): RoomConfirmReply {
        const message = { infos: [], buildingInfos: [], formulaInfos: [], roomHeroDatas: [], productionLines: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RoomConfirmReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoomConfirmReply): RoomConfirmReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated BlockInfo infos */ 1:
                    message.infos.push(BlockInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated BuildingInfo buildingInfos */ 2:
                    message.buildingInfos.push(BuildingInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated FormulaInfo formulaInfos */ 3:
                    message.formulaInfos.push(FormulaInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 roomLevel */ 4:
                    message.roomLevel = reader.int32();
                    break;
                case /* repeated RoomHeroData roomHeroDatas */ 5:
                    message.roomHeroDatas.push(RoomHeroData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ProductionLineInfo productionLines */ 6:
                    message.productionLines.push(ProductionLineInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoomConfirmReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated BlockInfo infos = 1; */
        for (let i = 0; i < message.infos.length; i++)
            BlockInfo.internalBinaryWrite(message.infos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated BuildingInfo buildingInfos = 2; */
        for (let i = 0; i < message.buildingInfos.length; i++)
            BuildingInfo.internalBinaryWrite(message.buildingInfos[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated FormulaInfo formulaInfos = 3; */
        for (let i = 0; i < message.formulaInfos.length; i++)
            FormulaInfo.internalBinaryWrite(message.formulaInfos[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 roomLevel = 4; */
        if (message.roomLevel !== undefined)
            writer.tag(4, WireType.Varint).int32(message.roomLevel);
        /* repeated RoomHeroData roomHeroDatas = 5; */
        for (let i = 0; i < message.roomHeroDatas.length; i++)
            RoomHeroData.internalBinaryWrite(message.roomHeroDatas[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated ProductionLineInfo productionLines = 6; */
        for (let i = 0; i < message.productionLines.length; i++)
            ProductionLineInfo.internalBinaryWrite(message.productionLines[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RoomConfirmReply
 */
export const RoomConfirmReply = new RoomConfirmReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoomRevertReply$Type extends MessageType<RoomRevertReply> {
    constructor() {
        super("RoomRevertReply", [
            { no: 1, name: "infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BlockInfo },
            { no: 2, name: "blockPackages", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BlockPackageInfo },
            { no: 3, name: "buildingInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BuildingInfo }
        ]);
    }
    create(value?: PartialMessage<RoomRevertReply>): RoomRevertReply {
        const message = { infos: [], blockPackages: [], buildingInfos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RoomRevertReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoomRevertReply): RoomRevertReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated BlockInfo infos */ 1:
                    message.infos.push(BlockInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated BlockPackageInfo blockPackages */ 2:
                    message.blockPackages.push(BlockPackageInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated BuildingInfo buildingInfos */ 3:
                    message.buildingInfos.push(BuildingInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoomRevertReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated BlockInfo infos = 1; */
        for (let i = 0; i < message.infos.length; i++)
            BlockInfo.internalBinaryWrite(message.infos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated BlockPackageInfo blockPackages = 2; */
        for (let i = 0; i < message.blockPackages.length; i++)
            BlockPackageInfo.internalBinaryWrite(message.blockPackages[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated BuildingInfo buildingInfos = 3; */
        for (let i = 0; i < message.buildingInfos.length; i++)
            BuildingInfo.internalBinaryWrite(message.buildingInfos[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RoomRevertReply
 */
export const RoomRevertReply = new RoomRevertReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProductionLineLvUpReply$Type extends MessageType<ProductionLineLvUpReply> {
    constructor() {
        super("ProductionLineLvUpReply", [
            { no: 1, name: "productionLine", kind: "message", T: () => ProductionLineInfo }
        ]);
    }
    create(value?: PartialMessage<ProductionLineLvUpReply>): ProductionLineLvUpReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ProductionLineLvUpReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProductionLineLvUpReply): ProductionLineLvUpReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional ProductionLineInfo productionLine */ 1:
                    message.productionLine = ProductionLineInfo.internalBinaryRead(reader, reader.uint32(), options, message.productionLine);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProductionLineLvUpReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional ProductionLineInfo productionLine = 1; */
        if (message.productionLine)
            ProductionLineInfo.internalBinaryWrite(message.productionLine, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ProductionLineLvUpReply
 */
export const ProductionLineLvUpReply = new ProductionLineLvUpReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBuildingInfoReply$Type extends MessageType<GetBuildingInfoReply> {
    constructor() {
        super("GetBuildingInfoReply", [
            { no: 1, name: "buildingInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BuildingInfo }
        ]);
    }
    create(value?: PartialMessage<GetBuildingInfoReply>): GetBuildingInfoReply {
        const message = { buildingInfos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetBuildingInfoReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBuildingInfoReply): GetBuildingInfoReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated BuildingInfo buildingInfos */ 1:
                    message.buildingInfos.push(BuildingInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetBuildingInfoReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated BuildingInfo buildingInfos = 1; */
        for (let i = 0; i < message.buildingInfos.length; i++)
            BuildingInfo.internalBinaryWrite(message.buildingInfos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetBuildingInfoReply
 */
export const GetBuildingInfoReply = new GetBuildingInfoReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProductionLineInfo$Type extends MessageType<ProductionLineInfo> {
    constructor() {
        super("ProductionLineInfo", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "formulaId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "finishCount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "nextFinishTime", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "pauseTime", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "level", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ProductionLineInfo>): ProductionLineInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ProductionLineInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProductionLineInfo): ProductionLineInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* optional int32 formulaId */ 2:
                    message.formulaId = reader.int32();
                    break;
                case /* optional int32 finishCount */ 3:
                    message.finishCount = reader.int32();
                    break;
                case /* optional int32 nextFinishTime */ 4:
                    message.nextFinishTime = reader.int32();
                    break;
                case /* optional int32 pauseTime */ 5:
                    message.pauseTime = reader.int32();
                    break;
                case /* optional int32 level */ 6:
                    message.level = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProductionLineInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* optional int32 formulaId = 2; */
        if (message.formulaId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.formulaId);
        /* optional int32 finishCount = 3; */
        if (message.finishCount !== undefined)
            writer.tag(3, WireType.Varint).int32(message.finishCount);
        /* optional int32 nextFinishTime = 4; */
        if (message.nextFinishTime !== undefined)
            writer.tag(4, WireType.Varint).int32(message.nextFinishTime);
        /* optional int32 pauseTime = 5; */
        if (message.pauseTime !== undefined)
            writer.tag(5, WireType.Varint).int32(message.pauseTime);
        /* optional int32 level = 6; */
        if (message.level !== undefined)
            writer.tag(6, WireType.Varint).int32(message.level);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ProductionLineInfo
 */
export const ProductionLineInfo = new ProductionLineInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResetRoomRequest$Type extends MessageType<ResetRoomRequest> {
    constructor() {
        super("ResetRoomRequest", []);
    }
    create(value?: PartialMessage<ResetRoomRequest>): ResetRoomRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ResetRoomRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResetRoomRequest): ResetRoomRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: ResetRoomRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ResetRoomRequest
 */
export const ResetRoomRequest = new ResetRoomRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GainProductionLineReply$Type extends MessageType<GainProductionLineReply> {
    constructor() {
        super("GainProductionLineReply", [
            { no: 1, name: "productionLines", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ProductionLineInfo }
        ]);
    }
    create(value?: PartialMessage<GainProductionLineReply>): GainProductionLineReply {
        const message = { productionLines: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GainProductionLineReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GainProductionLineReply): GainProductionLineReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ProductionLineInfo productionLines */ 1:
                    message.productionLines.push(ProductionLineInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GainProductionLineReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ProductionLineInfo productionLines = 1; */
        for (let i = 0; i < message.productionLines.length; i++)
            ProductionLineInfo.internalBinaryWrite(message.productionLines[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GainProductionLineReply
 */
export const GainProductionLineReply = new GainProductionLineReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UseBuildingReply$Type extends MessageType<UseBuildingReply> {
    constructor() {
        super("UseBuildingReply", [
            { no: 1, name: "buildingInfo", kind: "message", T: () => BuildingInfo }
        ]);
    }
    create(value?: PartialMessage<UseBuildingReply>): UseBuildingReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UseBuildingReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UseBuildingReply): UseBuildingReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional BuildingInfo buildingInfo */ 1:
                    message.buildingInfo = BuildingInfo.internalBinaryRead(reader, reader.uint32(), options, message.buildingInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UseBuildingReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional BuildingInfo buildingInfo = 1; */
        if (message.buildingInfo)
            BuildingInfo.internalBinaryWrite(message.buildingInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UseBuildingReply
 */
export const UseBuildingReply = new UseBuildingReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProductionLineInfoReply$Type extends MessageType<ProductionLineInfoReply> {
    constructor() {
        super("ProductionLineInfoReply", [
            { no: 1, name: "productionLines", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ProductionLineInfo }
        ]);
    }
    create(value?: PartialMessage<ProductionLineInfoReply>): ProductionLineInfoReply {
        const message = { productionLines: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ProductionLineInfoReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProductionLineInfoReply): ProductionLineInfoReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ProductionLineInfo productionLines */ 1:
                    message.productionLines.push(ProductionLineInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProductionLineInfoReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ProductionLineInfo productionLines = 1; */
        for (let i = 0; i < message.productionLines.length; i++)
            ProductionLineInfo.internalBinaryWrite(message.productionLines[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ProductionLineInfoReply
 */
export const ProductionLineInfoReply = new ProductionLineInfoReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HideBlockPackageReddotRequest$Type extends MessageType<HideBlockPackageReddotRequest> {
    constructor() {
        super("HideBlockPackageReddotRequest", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<HideBlockPackageReddotRequest>): HideBlockPackageReddotRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<HideBlockPackageReddotRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HideBlockPackageReddotRequest): HideBlockPackageReddotRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HideBlockPackageReddotRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HideBlockPackageReddotRequest
 */
export const HideBlockPackageReddotRequest = new HideBlockPackageReddotRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BlockInfo$Type extends MessageType<BlockInfo> {
    constructor() {
        super("BlockInfo", [
            { no: 1, name: "blockId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "x", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "y", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "rotate", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<BlockInfo>): BlockInfo {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BlockInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BlockInfo): BlockInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 blockId */ 1:
                    message.blockId = reader.int32();
                    break;
                case /* optional int32 x */ 2:
                    message.x = reader.int32();
                    break;
                case /* optional int32 y */ 3:
                    message.y = reader.int32();
                    break;
                case /* optional int32 rotate */ 4:
                    message.rotate = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BlockInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 blockId = 1; */
        if (message.blockId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.blockId);
        /* optional int32 x = 2; */
        if (message.x !== undefined)
            writer.tag(2, WireType.Varint).int32(message.x);
        /* optional int32 y = 3; */
        if (message.y !== undefined)
            writer.tag(3, WireType.Varint).int32(message.y);
        /* optional int32 rotate = 4; */
        if (message.rotate !== undefined)
            writer.tag(4, WireType.Varint).int32(message.rotate);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BlockInfo
 */
export const BlockInfo = new BlockInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BuildingGainPush$Type extends MessageType<BuildingGainPush> {
    constructor() {
        super("BuildingGainPush", [
            { no: 1, name: "buildingInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BuildingInfo }
        ]);
    }
    create(value?: PartialMessage<BuildingGainPush>): BuildingGainPush {
        const message = { buildingInfos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<BuildingGainPush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BuildingGainPush): BuildingGainPush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated BuildingInfo buildingInfos */ 1:
                    message.buildingInfos.push(BuildingInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: BuildingGainPush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated BuildingInfo buildingInfos = 1; */
        for (let i = 0; i < message.buildingInfos.length; i++)
            BuildingInfo.internalBinaryWrite(message.buildingInfos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message BuildingGainPush
 */
export const BuildingGainPush = new BuildingGainPush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoomConfirmRequest$Type extends MessageType<RoomConfirmRequest> {
    constructor() {
        super("RoomConfirmRequest", []);
    }
    create(value?: PartialMessage<RoomConfirmRequest>): RoomConfirmRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RoomConfirmRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoomConfirmRequest): RoomConfirmRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RoomConfirmRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RoomConfirmRequest
 */
export const RoomConfirmRequest = new RoomConfirmRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartProductionLineRequest$Type extends MessageType<StartProductionLineRequest> {
    constructor() {
        super("StartProductionLineRequest", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "formulaId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "count", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<StartProductionLineRequest>): StartProductionLineRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StartProductionLineRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartProductionLineRequest): StartProductionLineRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* optional int32 formulaId */ 2:
                    message.formulaId = reader.int32();
                    break;
                case /* optional int32 count */ 3:
                    message.count = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartProductionLineRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* optional int32 formulaId = 2; */
        if (message.formulaId !== undefined)
            writer.tag(2, WireType.Varint).int32(message.formulaId);
        /* optional int32 count = 3; */
        if (message.count !== undefined)
            writer.tag(3, WireType.Varint).int32(message.count);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StartProductionLineRequest
 */
export const StartProductionLineRequest = new StartProductionLineRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoomLevelUpRequest$Type extends MessageType<RoomLevelUpRequest> {
    constructor() {
        super("RoomLevelUpRequest", []);
    }
    create(value?: PartialMessage<RoomLevelUpRequest>): RoomLevelUpRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RoomLevelUpRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoomLevelUpRequest): RoomLevelUpRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RoomLevelUpRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RoomLevelUpRequest
 */
export const RoomLevelUpRequest = new RoomLevelUpRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ProductionLineAccelerateRequest$Type extends MessageType<ProductionLineAccelerateRequest> {
    constructor() {
        super("ProductionLineAccelerateRequest", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "useItemCount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ProductionLineAccelerateRequest>): ProductionLineAccelerateRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<ProductionLineAccelerateRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ProductionLineAccelerateRequest): ProductionLineAccelerateRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                case /* optional int32 useItemCount */ 2:
                    message.useItemCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ProductionLineAccelerateRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        /* optional int32 useItemCount = 2; */
        if (message.useItemCount !== undefined)
            writer.tag(2, WireType.Varint).int32(message.useItemCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ProductionLineAccelerateRequest
 */
export const ProductionLineAccelerateRequest = new ProductionLineAccelerateRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoomLevelUpReply$Type extends MessageType<RoomLevelUpReply> {
    constructor() {
        super("RoomLevelUpReply", [
            { no: 1, name: "roomLevel", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "productionLines", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ProductionLineInfo }
        ]);
    }
    create(value?: PartialMessage<RoomLevelUpReply>): RoomLevelUpReply {
        const message = { productionLines: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RoomLevelUpReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoomLevelUpReply): RoomLevelUpReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 roomLevel */ 1:
                    message.roomLevel = reader.int32();
                    break;
                case /* repeated ProductionLineInfo productionLines */ 2:
                    message.productionLines.push(ProductionLineInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoomLevelUpReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 roomLevel = 1; */
        if (message.roomLevel !== undefined)
            writer.tag(1, WireType.Varint).int32(message.roomLevel);
        /* repeated ProductionLineInfo productionLines = 2; */
        for (let i = 0; i < message.productionLines.length; i++)
            ProductionLineInfo.internalBinaryWrite(message.productionLines[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RoomLevelUpReply
 */
export const RoomLevelUpReply = new RoomLevelUpReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoomRevertRequest$Type extends MessageType<RoomRevertRequest> {
    constructor() {
        super("RoomRevertRequest", []);
    }
    create(value?: PartialMessage<RoomRevertRequest>): RoomRevertRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<RoomRevertRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoomRevertRequest): RoomRevertRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: RoomRevertRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message RoomRevertRequest
 */
export const RoomRevertRequest = new RoomRevertRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOtherRoomObInfoRequest$Type extends MessageType<GetOtherRoomObInfoRequest> {
    constructor() {
        super("GetOtherRoomObInfoRequest", [
            { no: 1, name: "targetUid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<GetOtherRoomObInfoRequest>): GetOtherRoomObInfoRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetOtherRoomObInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOtherRoomObInfoRequest): GetOtherRoomObInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int64 targetUid */ 1:
                    message.targetUid = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOtherRoomObInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int64 targetUid = 1; */
        if (message.targetUid !== undefined)
            writer.tag(1, WireType.Varint).int64(message.targetUid);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetOtherRoomObInfoRequest
 */
export const GetOtherRoomObInfoRequest = new GetOtherRoomObInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GainSpecialBlockPush$Type extends MessageType<GainSpecialBlockPush> {
    constructor() {
        super("GainSpecialBlockPush", [
            { no: 1, name: "specialBlocks", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GainSpecialBlockPush>): GainSpecialBlockPush {
        const message = { specialBlocks: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GainSpecialBlockPush>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GainSpecialBlockPush): GainSpecialBlockPush {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 specialBlocks */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.specialBlocks.push(reader.int32());
                    else
                        message.specialBlocks.push(reader.int32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GainSpecialBlockPush, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 specialBlocks = 1; */
        for (let i = 0; i < message.specialBlocks.length; i++)
            writer.tag(1, WireType.Varint).int32(message.specialBlocks[i]);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GainSpecialBlockPush
 */
export const GainSpecialBlockPush = new GainSpecialBlockPush$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UseBlockReply$Type extends MessageType<UseBlockReply> {
    constructor() {
        super("UseBlockReply", [
            { no: 1, name: "blockId", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "rotate", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "x", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "y", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<UseBlockReply>): UseBlockReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UseBlockReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UseBlockReply): UseBlockReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 blockId */ 1:
                    message.blockId = reader.int32();
                    break;
                case /* optional int32 rotate */ 2:
                    message.rotate = reader.int32();
                    break;
                case /* optional int32 x */ 3:
                    message.x = reader.int32();
                    break;
                case /* optional int32 y */ 4:
                    message.y = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UseBlockReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 blockId = 1; */
        if (message.blockId !== undefined)
            writer.tag(1, WireType.Varint).int32(message.blockId);
        /* optional int32 rotate = 2; */
        if (message.rotate !== undefined)
            writer.tag(2, WireType.Varint).int32(message.rotate);
        /* optional int32 x = 3; */
        if (message.x !== undefined)
            writer.tag(3, WireType.Varint).int32(message.x);
        /* optional int32 y = 4; */
        if (message.y !== undefined)
            writer.tag(4, WireType.Varint).int32(message.y);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UseBlockReply
 */
export const UseBlockReply = new UseBlockReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartProductionLineReply$Type extends MessageType<StartProductionLineReply> {
    constructor() {
        super("StartProductionLineReply", [
            { no: 1, name: "productionLine", kind: "message", T: () => ProductionLineInfo }
        ]);
    }
    create(value?: PartialMessage<StartProductionLineReply>): StartProductionLineReply {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StartProductionLineReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartProductionLineReply): StartProductionLineReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional ProductionLineInfo productionLine */ 1:
                    message.productionLine = ProductionLineInfo.internalBinaryRead(reader, reader.uint32(), options, message.productionLine);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartProductionLineReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional ProductionLineInfo productionLine = 1; */
        if (message.productionLine)
            ProductionLineInfo.internalBinaryWrite(message.productionLine, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StartProductionLineReply
 */
export const StartProductionLineReply = new StartProductionLineReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetRoomObInfoRequest$Type extends MessageType<GetRoomObInfoRequest> {
    constructor() {
        super("GetRoomObInfoRequest", [
            { no: 1, name: "needBlockData", kind: "scalar", opt: true, T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<GetRoomObInfoRequest>): GetRoomObInfoRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetRoomObInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetRoomObInfoRequest): GetRoomObInfoRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bool needBlockData */ 1:
                    message.needBlockData = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetRoomObInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bool needBlockData = 1; */
        if (message.needBlockData !== undefined)
            writer.tag(1, WireType.Varint).bool(message.needBlockData);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetRoomObInfoRequest
 */
export const GetRoomObInfoRequest = new GetRoomObInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCharacterInteractionInfoReply$Type extends MessageType<GetCharacterInteractionInfoReply> {
    constructor() {
        super("GetCharacterInteractionInfoReply", [
            { no: 1, name: "infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => CharacterInteractionInfo },
            { no: 2, name: "interactionCount", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<GetCharacterInteractionInfoReply>): GetCharacterInteractionInfoReply {
        const message = { infos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetCharacterInteractionInfoReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCharacterInteractionInfoReply): GetCharacterInteractionInfoReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated CharacterInteractionInfo infos */ 1:
                    message.infos.push(CharacterInteractionInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int32 interactionCount */ 2:
                    message.interactionCount = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetCharacterInteractionInfoReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated CharacterInteractionInfo infos = 1; */
        for (let i = 0; i < message.infos.length; i++)
            CharacterInteractionInfo.internalBinaryWrite(message.infos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* optional int32 interactionCount = 2; */
        if (message.interactionCount !== undefined)
            writer.tag(2, WireType.Varint).int32(message.interactionCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetCharacterInteractionInfoReply
 */
export const GetCharacterInteractionInfoReply = new GetCharacterInteractionInfoReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetCharacterInteractionInfoRequest$Type extends MessageType<GetCharacterInteractionInfoRequest> {
    constructor() {
        super("GetCharacterInteractionInfoRequest", []);
    }
    create(value?: PartialMessage<GetCharacterInteractionInfoRequest>): GetCharacterInteractionInfoRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetCharacterInteractionInfoRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetCharacterInteractionInfoRequest): GetCharacterInteractionInfoRequest {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetCharacterInteractionInfoRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetCharacterInteractionInfoRequest
 */
export const GetCharacterInteractionInfoRequest = new GetCharacterInteractionInfoRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetBlockPackageInfoRequset$Type extends MessageType<GetBlockPackageInfoRequset> {
    constructor() {
        super("GetBlockPackageInfoRequset", []);
    }
    create(value?: PartialMessage<GetBlockPackageInfoRequset>): GetBlockPackageInfoRequset {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetBlockPackageInfoRequset>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetBlockPackageInfoRequset): GetBlockPackageInfoRequset {
        return target ?? this.create();
    }
    internalBinaryWrite(message: GetBlockPackageInfoRequset, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetBlockPackageInfoRequset
 */
export const GetBlockPackageInfoRequset = new GetBlockPackageInfoRequset$Type();
// @generated message type with reflection information, may provide speed optimized methods
class StartCharacterInteractionRequest$Type extends MessageType<StartCharacterInteractionRequest> {
    constructor() {
        super("StartCharacterInteractionRequest", [
            { no: 1, name: "id", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<StartCharacterInteractionRequest>): StartCharacterInteractionRequest {
        const message = {};
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<StartCharacterInteractionRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: StartCharacterInteractionRequest): StartCharacterInteractionRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional int32 id */ 1:
                    message.id = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: StartCharacterInteractionRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional int32 id = 1; */
        if (message.id !== undefined)
            writer.tag(1, WireType.Varint).int32(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message StartCharacterInteractionRequest
 */
export const StartCharacterInteractionRequest = new StartCharacterInteractionRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UnUseBlockReply$Type extends MessageType<UnUseBlockReply> {
    constructor() {
        super("UnUseBlockReply", [
            { no: 1, name: "blockIds", kind: "scalar", repeat: 2 /*RepeatType.UNPACKED*/, T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "buildingInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BuildingInfo }
        ]);
    }
    create(value?: PartialMessage<UnUseBlockReply>): UnUseBlockReply {
        const message = { blockIds: [], buildingInfos: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<UnUseBlockReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UnUseBlockReply): UnUseBlockReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated int32 blockIds */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.blockIds.push(reader.int32());
                    else
                        message.blockIds.push(reader.int32());
                    break;
                case /* repeated BuildingInfo buildingInfos */ 2:
                    message.buildingInfos.push(BuildingInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UnUseBlockReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated int32 blockIds = 1; */
        for (let i = 0; i < message.blockIds.length; i++)
            writer.tag(1, WireType.Varint).int32(message.blockIds[i]);
        /* repeated BuildingInfo buildingInfos = 2; */
        for (let i = 0; i < message.buildingInfos.length; i++)
            BuildingInfo.internalBinaryWrite(message.buildingInfos[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UnUseBlockReply
 */
export const UnUseBlockReply = new UnUseBlockReply$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetOtherRoomObInfoReply$Type extends MessageType<GetOtherRoomObInfoReply> {
    constructor() {
        super("GetOtherRoomObInfoReply", [
            { no: 1, name: "infos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BlockInfo },
            { no: 2, name: "buildingInfos", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => BuildingInfo },
            { no: 3, name: "targetUid", kind: "scalar", opt: true, T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 4, name: "roomLevel", kind: "scalar", opt: true, T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "roomHeroDatas", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => RoomHeroData },
            { no: 6, name: "productionLines", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ProductionLineInfo }
        ]);
    }
    create(value?: PartialMessage<GetOtherRoomObInfoReply>): GetOtherRoomObInfoReply {
        const message = { infos: [], buildingInfos: [], roomHeroDatas: [], productionLines: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<GetOtherRoomObInfoReply>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetOtherRoomObInfoReply): GetOtherRoomObInfoReply {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated BlockInfo infos */ 1:
                    message.infos.push(BlockInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated BuildingInfo buildingInfos */ 2:
                    message.buildingInfos.push(BuildingInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* optional int64 targetUid */ 3:
                    message.targetUid = reader.int64().toBigInt();
                    break;
                case /* optional int32 roomLevel */ 4:
                    message.roomLevel = reader.int32();
                    break;
                case /* repeated RoomHeroData roomHeroDatas */ 5:
                    message.roomHeroDatas.push(RoomHeroData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated ProductionLineInfo productionLines */ 6:
                    message.productionLines.push(ProductionLineInfo.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetOtherRoomObInfoReply, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated BlockInfo infos = 1; */
        for (let i = 0; i < message.infos.length; i++)
            BlockInfo.internalBinaryWrite(message.infos[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated BuildingInfo buildingInfos = 2; */
        for (let i = 0; i < message.buildingInfos.length; i++)
            BuildingInfo.internalBinaryWrite(message.buildingInfos[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* optional int64 targetUid = 3; */
        if (message.targetUid !== undefined)
            writer.tag(3, WireType.Varint).int64(message.targetUid);
        /* optional int32 roomLevel = 4; */
        if (message.roomLevel !== undefined)
            writer.tag(4, WireType.Varint).int32(message.roomLevel);
        /* repeated RoomHeroData roomHeroDatas = 5; */
        for (let i = 0; i < message.roomHeroDatas.length; i++)
            RoomHeroData.internalBinaryWrite(message.roomHeroDatas[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* repeated ProductionLineInfo productionLines = 6; */
        for (let i = 0; i < message.productionLines.length; i++)
            ProductionLineInfo.internalBinaryWrite(message.productionLines[i], writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetOtherRoomObInfoReply
 */
export const GetOtherRoomObInfoReply = new GetOtherRoomObInfoReply$Type();
